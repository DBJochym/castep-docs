{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CASTEP Documentation This is the CASTEP community documentation and tutorial site. For an overview of CASTEP, and to obtain a licence please see the castep website For the Dassault Syst\u00e8mes BIOVIA (Materials Studio) documentation for CASTEP see HTML documentation and a downloadable pdf user guide Contributors:","title":"Home"},{"location":"#castep-documentation","text":"This is the CASTEP community documentation and tutorial site. For an overview of CASTEP, and to obtain a licence please see the castep website For the Dassault Syst\u00e8mes BIOVIA (Materials Studio) documentation for CASTEP see HTML documentation and a downloadable pdf user guide","title":"CASTEP Documentation"},{"location":"#contributors","text":"","title":"Contributors:"},{"location":"documentation/EPR/overview/","text":"In crystalline materials, electron paramagnetic resonance (EPR) can be used to study paramagnetic defects. EPR spectra of spin \u00bd centers have two contributions: the hyperfine tensor {\\bf A} {\\bf A} and the g-tensor {\\bf g} {\\bf g} , which are defined through the following effective Hamiltonian \\begin{equation} H_{eff}=\\frac{\\alpha}{2}{\\bf S}\\cdot{\\bf g}\\cdot{\\bf B} + \\sum_I {\\bf S}\\cdot{\\bf A}_{I}\\cdot{\\bf I}_I \\end{equation} where \\alpha \\alpha is the fine structure constant and the summation I I runs over nuclei. The hyperfine tensor arises from the interaction of the nuclei with the ground-state spin density. This term has been calculated within the planewave-pseudopotential approach; indeed it was for this property that the PAW scheme was first introduced.\\cite{walle93} The g-tensor arises from the interaction of the electronic spin with the external magnetic field. This term plays an somewhat similar role to the shielding in NMR; induced electronic currents in the sample modify the g-tensor from its vacuum value. The GIPAW approach has been used to compute g-tensors in several crystalline materials including defects in \\alpha \\alpha -quartz and zirconia.","title":"EPR Overview"},{"location":"documentation/Geometry_Optimisation/constraints/","text":"Atomic constraints CASTEP can impose various forms of linear or non-linear constraints upon the positions of the atoms. This can be used with all forms of geometry optimization and molecular dynamics. Some simple short cuts exist, such as to keep all the atoms fixed: FIX_ALL_IONS : T or to fix the Centre of Mass: FIX_COM : T It is also possible to specify constraints on individual atoms, using the IONIC_CONSTRAINTS block. The simplest case is to control which atoms remain fixed during a geometry optimisation. e.g. %BLOCK IONIC_CONSTRAINTS fix: C 1 !fix position of atom C 1 %ENDBLOCK IONIC_CONSTRAINTS Some further examples include fix: all !fix all atoms\u2028 fix: C N !fix species C and N\u2028 fix: C 1 !fix position of atom C 1\u2028 fix: C{1,3,5-10} !fix positions of atoms C1, C3, C5,C6,C7,C8,C9,C10\u2028 fix: all unfix: H !fix positions of all atoms except H The last example in particularly useful in the case of molecular crystals, when you might want to allow the H atoms to move but keep all of the heavy atoms in the positions determined by diffraction. To fix the individual Cartesian components of an atom's position use the full syntax of the ionic_constraints block, where each constraint removes one degree of freedom. For example %BLOCK IONIC_CONSTRAINTS 1 W 1 1.0000000000 0.0000000000 0.0000000000 2 W 1 0.0000000000 1.0000000000 0.0000000000 3 W 1 0.0000000000 0.0000000000 1.0000000000 4 W 2 1.0000000000 0.0000000000 0.0000000000 %ENDBLOCK IONIC_CONSTRAINTS The 1 st line says that constraint number 1 is to fix the x coordinate of Tungston atom 1. The 2 nd line says that constraint number 2 is to fix the y coordinate of Tungston atom 1. etc. To fix an atom in 3D requires 3 constraints to remove all 3 degrees of freedom. The ionic_constraints block can also be used to impose any arbitary linear constraint, such as to restrict an atom to move in a plane or along a line, or to fix the centre of mass. A constraint may involve more than 1 atom, and hence can span mulitple lines, but each constraint operates on 1 degree of freedom. It cannot be used to fix a bond length - that is a non-linear constraint - see below for more details. The general syntax for constraint i i operating on atom j j of element X at position r^j r^j is %BLOCK IONIC_CONSTRAINTS ... i X j a1 a2 a3 ... %ENDBLOCK IONIC_CONSTRAINTS and the constraint is specfied as \\begin{equation} C^i={\\bf a^i}\\cdot{\\bf r^j} \\end{equation} where C^i C^i is given by the initial conditions. For example to fix the second S atom to move in the plane parallel to y=x y=x use this: %BLOCK IONIC_CONSTRAINTS 1 S 2 -1 1 0 %ENDBLOCK IONIC_CONSTRAINTS Cell Constraints Cell constraints can be used with all forms of geometry optimization and molecular dynamics that all the cell size/shape to vary. Some simple short cuts exist, such as to keep the unit cell fixed during the optimisation FIX_CELL : T To fix the volume of the unit cell FIX_VOL : T It is also possible to apply an arbitary set of constraints to the cell angles and cell lengths using the CELL_CONSTRAINTS block. %BLOCK CELL_CONSTRAINTS a b c alpha beta gamma %ENDBLOCK CELL_CONSTRAINTS Setting an element to zero means to keep it fixed. Two or more elements set to the same positive integer, means that these elements should be kept equal during the geometry optimisation. For example %BLOCK CELL_CONSTRAINTS 0 0 0 4 5 6 %ENDBLOCK CELL_CONSTRAINTS would keep all cell lengths fixed, and allow the three cell angles to vary independently, and %BLOCK CELL_CONSTRAINTS 0 0 0 4 4 6 %ENDBLOCK CELL_CONSTRAINTS would enforce \\alpha=\\beta\\neq\\gamma \\alpha=\\beta\\neq\\gamma and keep the cell lengths fixed. Symmetry The application of symmetry with constraints (for ionic positions and/or cell vectors) needs to be considered carefully. In general, if symmetry is on, then there is no need to add a constraint to explicitly impose a restriction that is implied by the symmetry. If there is a need for an additional restriction, then that can be added on top of the symmetry, but the user needs to be careful that the additional constraint does not conflict with symmetry. If in doubt, turn symmetry off and impose all the desired constraints explicitly. Non-linear Constraints CASTEP can also support non-linear constraints, such as fixed bond length, in both molecular dynamics and geometry optimization if using GEOM_METHOD=DELOCALISED : %BLOCK NONLINEAR_CONSTRAINTS constraint_type atom1 atom2 (atom3 (atom 4)) ... %ENDBLOCK NONLINEAR_CONSTRAINTS where the first element specifies a constraint type (distance, bend or torsion). Then depending on the type of constraint, either 2, 3 or 4 atoms need to be specified. As for ionic constraints, atoms are specified by species and number within that species. In addition, it is necessary to specify which periodic image of the cell the atom is located in (so constraints can straddle a cell boundary). For instance %BLOCK NONLINEAR_CONSTRAINTS distance H 4 0 0 0 O 2 0 1 0 bend H 5 0 0 0 C 1 1 0 1 H 2 0 0 0 torsion H 6 0 0 0 H 3 1 0 0 H 1 0 0 1 H 9 1 1 1 0 %ENDBLOCK NONLINEAR_CONSTRAINTS specifies: the distance between the 4 th hydrogen atom and the 2 nd oxygen atom in the adjacent ( 0 1 0 ) cell the bend angle defined by the 5 th hydrogen atom, the 1 st carbon atom in the ( 1 0 1 ) cell and the 2 nd hydrogen atom the torsion angle defined by 4 hydrogen atoms, etc.","title":"Constraints"},{"location":"documentation/Geometry_Optimisation/constraints/#atomic-constraints","text":"CASTEP can impose various forms of linear or non-linear constraints upon the positions of the atoms. This can be used with all forms of geometry optimization and molecular dynamics. Some simple short cuts exist, such as to keep all the atoms fixed: FIX_ALL_IONS : T or to fix the Centre of Mass: FIX_COM : T It is also possible to specify constraints on individual atoms, using the IONIC_CONSTRAINTS block. The simplest case is to control which atoms remain fixed during a geometry optimisation. e.g. %BLOCK IONIC_CONSTRAINTS fix: C 1 !fix position of atom C 1 %ENDBLOCK IONIC_CONSTRAINTS Some further examples include fix: all !fix all atoms\u2028 fix: C N !fix species C and N\u2028 fix: C 1 !fix position of atom C 1\u2028 fix: C{1,3,5-10} !fix positions of atoms C1, C3, C5,C6,C7,C8,C9,C10\u2028 fix: all unfix: H !fix positions of all atoms except H The last example in particularly useful in the case of molecular crystals, when you might want to allow the H atoms to move but keep all of the heavy atoms in the positions determined by diffraction. To fix the individual Cartesian components of an atom's position use the full syntax of the ionic_constraints block, where each constraint removes one degree of freedom. For example %BLOCK IONIC_CONSTRAINTS 1 W 1 1.0000000000 0.0000000000 0.0000000000 2 W 1 0.0000000000 1.0000000000 0.0000000000 3 W 1 0.0000000000 0.0000000000 1.0000000000 4 W 2 1.0000000000 0.0000000000 0.0000000000 %ENDBLOCK IONIC_CONSTRAINTS The 1 st line says that constraint number 1 is to fix the x coordinate of Tungston atom 1. The 2 nd line says that constraint number 2 is to fix the y coordinate of Tungston atom 1. etc. To fix an atom in 3D requires 3 constraints to remove all 3 degrees of freedom. The ionic_constraints block can also be used to impose any arbitary linear constraint, such as to restrict an atom to move in a plane or along a line, or to fix the centre of mass. A constraint may involve more than 1 atom, and hence can span mulitple lines, but each constraint operates on 1 degree of freedom. It cannot be used to fix a bond length - that is a non-linear constraint - see below for more details. The general syntax for constraint i i operating on atom j j of element X at position r^j r^j is %BLOCK IONIC_CONSTRAINTS ... i X j a1 a2 a3 ... %ENDBLOCK IONIC_CONSTRAINTS and the constraint is specfied as \\begin{equation} C^i={\\bf a^i}\\cdot{\\bf r^j} \\end{equation} where C^i C^i is given by the initial conditions. For example to fix the second S atom to move in the plane parallel to y=x y=x use this: %BLOCK IONIC_CONSTRAINTS 1 S 2 -1 1 0 %ENDBLOCK IONIC_CONSTRAINTS","title":"Atomic constraints"},{"location":"documentation/Geometry_Optimisation/constraints/#cell-constraints","text":"Cell constraints can be used with all forms of geometry optimization and molecular dynamics that all the cell size/shape to vary. Some simple short cuts exist, such as to keep the unit cell fixed during the optimisation FIX_CELL : T To fix the volume of the unit cell FIX_VOL : T It is also possible to apply an arbitary set of constraints to the cell angles and cell lengths using the CELL_CONSTRAINTS block. %BLOCK CELL_CONSTRAINTS a b c alpha beta gamma %ENDBLOCK CELL_CONSTRAINTS Setting an element to zero means to keep it fixed. Two or more elements set to the same positive integer, means that these elements should be kept equal during the geometry optimisation. For example %BLOCK CELL_CONSTRAINTS 0 0 0 4 5 6 %ENDBLOCK CELL_CONSTRAINTS would keep all cell lengths fixed, and allow the three cell angles to vary independently, and %BLOCK CELL_CONSTRAINTS 0 0 0 4 4 6 %ENDBLOCK CELL_CONSTRAINTS would enforce \\alpha=\\beta\\neq\\gamma \\alpha=\\beta\\neq\\gamma and keep the cell lengths fixed.","title":"Cell Constraints"},{"location":"documentation/Geometry_Optimisation/constraints/#symmetry","text":"The application of symmetry with constraints (for ionic positions and/or cell vectors) needs to be considered carefully. In general, if symmetry is on, then there is no need to add a constraint to explicitly impose a restriction that is implied by the symmetry. If there is a need for an additional restriction, then that can be added on top of the symmetry, but the user needs to be careful that the additional constraint does not conflict with symmetry. If in doubt, turn symmetry off and impose all the desired constraints explicitly.","title":"Symmetry"},{"location":"documentation/Geometry_Optimisation/constraints/#non-linear-constraints","text":"CASTEP can also support non-linear constraints, such as fixed bond length, in both molecular dynamics and geometry optimization if using GEOM_METHOD=DELOCALISED : %BLOCK NONLINEAR_CONSTRAINTS constraint_type atom1 atom2 (atom3 (atom 4)) ... %ENDBLOCK NONLINEAR_CONSTRAINTS where the first element specifies a constraint type (distance, bend or torsion). Then depending on the type of constraint, either 2, 3 or 4 atoms need to be specified. As for ionic constraints, atoms are specified by species and number within that species. In addition, it is necessary to specify which periodic image of the cell the atom is located in (so constraints can straddle a cell boundary). For instance %BLOCK NONLINEAR_CONSTRAINTS distance H 4 0 0 0 O 2 0 1 0 bend H 5 0 0 0 C 1 1 0 1 H 2 0 0 0 torsion H 6 0 0 0 H 3 1 0 0 H 1 0 0 1 H 9 1 1 1 0 %ENDBLOCK NONLINEAR_CONSTRAINTS specifies: the distance between the 4 th hydrogen atom and the 2 nd oxygen atom in the adjacent ( 0 1 0 ) cell the bend angle defined by the 5 th hydrogen atom, the 1 st carbon atom in the ( 1 0 1 ) cell and the 2 nd hydrogen atom the torsion angle defined by 4 hydrogen atoms, etc.","title":"Non-linear Constraints"},{"location":"documentation/Geometry_Optimisation/files/","text":".geom The .geom file is the primary output file, and contains the unit cell, positions of the atoms and the forces on the atoms for each step of the geometry optimisation. The format of this file is the same as the .md file () BEGIN header END header 0 F F F F <-- c -1.1089287934762380E+000 -1.1089287934762380E+000 <-- E 1.1338356755021575E+001 0.0000000000000000E+000 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 1.1338356755021575E+001 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 6.9427411538139708E-016 1.1338356755021575E+001 <-- h H 1 0.0000000000000000E+000 0.0000000000000000E+000 0.0000000000000000E+000 <-- R H 2 0.0000000000000000E+000 0.0000000000000000E+000 1.8897261258369291E+000 <-- R H 1 5.2328399876121735E-008 -1.0421543664521416E-007 7.0009877481903737E-002 <-- F H 2 -5.2328399876121735E-008 1.0421543664521414E-007 -7.0009877481903737E-002 <-- F 1 F F F T <-- c -1.1238786617585625E+000 -1.1238786617585625E+000 <-- E 1.1338356755021575E+001 0.0000000000000000E+000 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 1.1338356755021575E+001 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 6.9427411538139708E-016 1.1338356755021575E+001 <-- h H 1 9.4833861449528325E-008 -1.8886784811136898E-007 1.2687770000486739E-001 <-- R H 2 -9.4833861449528339E-008 1.8886784811136895E-007 1.7628484258320618E+000 <-- R H 1 -3.5821658412345467E-009 7.1341230429117867E-009 4.3459352502549203E-002 <-- F H 2 3.5821658412345467E-009 -7.1341230429117867E-009 -4.3459352502549203E-002 <-- F 5 T T T T <-- c -1.1282766172341445E+000 -1.1282766172341445E+000 <-- E 1.1338356755021575E+001 0.0000000000000000E+000 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 1.1338356755021575E+001 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 6.9427411538139708E-016 1.1338356755021575E+001 <-- h H 1 -3.9595146097124387E-007 7.8856409239690845E-007 2.1772199021621047E-001 <-- R H 2 3.9595146097124376E-007 -7.8856409239690845E-007 1.6720041356207189E+000 <-- R H 1 -8.2747158669639466E-009 1.6479675454026804E-008 1.5340573808683700E-006 <-- F H 2 8.2747158669639466E-009 -1.6479675454026804E-008 -1.5340573808683700E-006 <-- F All quantities are reported in atomic units (this cannot be changed by any parameter) <-- c Reports the iteration number and whether the convergence criteria are satisfied. <-- E Energy (total energy, enthalpy) <-- h Unit cell vectors <-- S Stress on unit cell (only reported if the cell is allowed to change) <-- R Cartesian positions of atoms <-- F Force on atoms The '\u2190 c' line also reports the status of 4 convergence flags (either F=false or T=true). These are (in order): dE - has the energy change/atom been below geom_energy_tol for at geom_convergence_win steps? Fmax - is the largest component of any force below geom_force_tol? dRmax - is the largest change in position for any atom below geom_disp_tol? Smax- is the largest component of the stress tensor below geom_stress_tol?","title":"Files"},{"location":"documentation/Geometry_Optimisation/files/#geom","text":"The .geom file is the primary output file, and contains the unit cell, positions of the atoms and the forces on the atoms for each step of the geometry optimisation. The format of this file is the same as the .md file () BEGIN header END header 0 F F F F <-- c -1.1089287934762380E+000 -1.1089287934762380E+000 <-- E 1.1338356755021575E+001 0.0000000000000000E+000 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 1.1338356755021575E+001 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 6.9427411538139708E-016 1.1338356755021575E+001 <-- h H 1 0.0000000000000000E+000 0.0000000000000000E+000 0.0000000000000000E+000 <-- R H 2 0.0000000000000000E+000 0.0000000000000000E+000 1.8897261258369291E+000 <-- R H 1 5.2328399876121735E-008 -1.0421543664521416E-007 7.0009877481903737E-002 <-- F H 2 -5.2328399876121735E-008 1.0421543664521414E-007 -7.0009877481903737E-002 <-- F 1 F F F T <-- c -1.1238786617585625E+000 -1.1238786617585625E+000 <-- E 1.1338356755021575E+001 0.0000000000000000E+000 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 1.1338356755021575E+001 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 6.9427411538139708E-016 1.1338356755021575E+001 <-- h H 1 9.4833861449528325E-008 -1.8886784811136898E-007 1.2687770000486739E-001 <-- R H 2 -9.4833861449528339E-008 1.8886784811136895E-007 1.7628484258320618E+000 <-- R H 1 -3.5821658412345467E-009 7.1341230429117867E-009 4.3459352502549203E-002 <-- F H 2 3.5821658412345467E-009 -7.1341230429117867E-009 -4.3459352502549203E-002 <-- F 5 T T T T <-- c -1.1282766172341445E+000 -1.1282766172341445E+000 <-- E 1.1338356755021575E+001 0.0000000000000000E+000 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 1.1338356755021575E+001 0.0000000000000000E+000 <-- h 6.9427411538139708E-016 6.9427411538139708E-016 1.1338356755021575E+001 <-- h H 1 -3.9595146097124387E-007 7.8856409239690845E-007 2.1772199021621047E-001 <-- R H 2 3.9595146097124376E-007 -7.8856409239690845E-007 1.6720041356207189E+000 <-- R H 1 -8.2747158669639466E-009 1.6479675454026804E-008 1.5340573808683700E-006 <-- F H 2 8.2747158669639466E-009 -1.6479675454026804E-008 -1.5340573808683700E-006 <-- F All quantities are reported in atomic units (this cannot be changed by any parameter) <-- c Reports the iteration number and whether the convergence criteria are satisfied. <-- E Energy (total energy, enthalpy) <-- h Unit cell vectors <-- S Stress on unit cell (only reported if the cell is allowed to change) <-- R Cartesian positions of atoms <-- F Force on atoms The '\u2190 c' line also reports the status of 4 convergence flags (either F=false or T=true). These are (in order): dE - has the energy change/atom been below geom_energy_tol for at geom_convergence_win steps? Fmax - is the largest component of any force below geom_force_tol? dRmax - is the largest change in position for any atom below geom_disp_tol? Smax- is the largest component of the stress tensor below geom_stress_tol?","title":".geom"},{"location":"documentation/Geometry_Optimisation/keywords/","text":"To perform a geometry optimisation set the task parameter task : geomopt The convergence criteria have the following default values, each of which can be set independently. geom_energy_tol : Tolerance on energy change between iterations (default: 2.0e-5 eV) geom_force_tol : Tolerance on maximum force on each atom (default: 0.05 eV/ANG) geom_stress_tol : Tolerance on maximum stress on cell (default: 0.1 GPa) geom_disp_tol : Tolerance on change in atom positions between iterations (default: 0.001: Ang) geom_max_iter : Maximum number of iterations (default: 30) It is possible to change the optimisation method, and to choose a preconditioner. geom_method : LBFGS (default), BFGS, DAMPEDMD,TPSD geom_preconditioner : EXP / FF / ID # EXPonential, Force Field, Identity (default) It is useful to set the following two parameters in a geometry optimisation. These will cause CASTEP to write a new cell/cif file with the final optimised coordinates write_cell_structure : T write_cif_structure : T","title":"Keywords"},{"location":"documentation/Geometry_Optimisation/overview/","text":"The essence of the calculation is for the ions and electrons in the supercell to be moved around stepwise until the forces on the atoms and the change in total energy between steps fall below some predefined convergence tolerance. The ionic positions are optimised using quasi-Newton methods. For each configuration of the ionic positions the electronic configuration is optimised using the method of conjugate gradients. The flow of the calculation is thus; Move ions into new positions using geometry optimisation algorithm Find electronic energy and forces for this ionic configuration Compare total energy with previous configurations and check if forces within tolerance limits If structure not optimised start at (1) and generate new set of ionic positions This cycle is performed until the forces fall within the tolerance limit and the energy should then be a local minimum. With periodic boundary conditions (as used by CASTEP) it is also possible to change the size and shape of the cell, in addition to (or instead of) moving the ions. In this case, the stress is calculated in addition to the forces, and this is used to change the cell, until the stress falls within a given tolerance. Finally, when considering the change in the cell, it is also possible to apply an external pressure. Hence it is the enthalpy, which is the appropriate free energy in this scenario, which is minimised instead of the energy. Finite-basis set corrections It should be noted, that with a plane-wave basis set (as used by CASTEP) there is an important side-effect of changing the size and/or shape of the cell - it changes the basis set used for the electronic states. Many DFT programs ignore this effect, which means that if the cell vectors change by more than a few %, the final structure is evaluated with a non-self-consistent basis, with a different cut-off energy to that intended. In CASTEP, there are two choices here: to either keep the cut-off energy constant (which results in the number and meaning of the plane-waves used in the basis changing from step-to-step) or to keep the number of plane-waves constant (which results in a change in the cut-off energy and in the meaning of the plane-waves used from step-to-step). The constant-cutoff/variable-number of plane-waves approach is the CASTEP default as it is the most physically reasonable. The constant number of plane-waves approach means that the quality of the calculation is changing from step-to-step. The effect of changing lattice vectors on the basis set can also be corrected to first-order using the 'finite basis set correction'. This can be calculated by the change in total energy for a small change in the cut-off energy at the start of a calculation, and then used as a correction to the energy and the stress. This is especially important in variable-cell calculations, for which it is activated by default. Advanced settings For geometry optimisation, there are a variety of different algorithms available which can be selected by the geom_method parameter in the param file. The choices are: LBFGS - the low-memory version of BFGS - the default option BFGS - widely-used quasi-Newton minimization TPSD - two-point steepest descent DELOCALIZED - a BFGS-based minimizer using delocalized internal coordinates DMD - optimally damped MD FIRE - fast inertial relaxation engine - a modified MD approach NB These are all 'local optimisations', i.e. the final structure depends upon the initial configuration and is not the global minimum. For those interested in finding the global minimum, then there are associated projects using Genetic Algorithms and AIRSS. The first 3 methods can do variable-cell or fixed-cell optimization, whereas the last 3 are only fixed-cell (for now). LBFGS/BFGS is generally the fastest method, and since v19, LBFGS has supported new preconditioners which should make it generally faster still. TPSD (unlike LBFGS/BFGS) has no built-in history, so should be much slower - however, the CASTEP implementation has a very efficient preconditioner which makes up for this, and the lack of history means that variable-cell optimisation with additional cell constraints is much more efficient than the equivalent calculation in LBFGS/BFGS. The DELOCALIZED minimizer is the only supported method to use delocalized internal coordinates, as opposed to absolute or fractional coordinates, and as such, should be best for optimizing large structures such as molecule-in-a-box with many low-energy soft modes. The two MD-based methods are generally less efficient, but can handle arbitrary constraints well, and have sometimes out-performed other methods for very anisotropic systems, such as molecule-on-a-surface etc.","title":"Overview"},{"location":"documentation/Geometry_Optimisation/overview/#finite-basis-set-corrections","text":"It should be noted, that with a plane-wave basis set (as used by CASTEP) there is an important side-effect of changing the size and/or shape of the cell - it changes the basis set used for the electronic states. Many DFT programs ignore this effect, which means that if the cell vectors change by more than a few %, the final structure is evaluated with a non-self-consistent basis, with a different cut-off energy to that intended. In CASTEP, there are two choices here: to either keep the cut-off energy constant (which results in the number and meaning of the plane-waves used in the basis changing from step-to-step) or to keep the number of plane-waves constant (which results in a change in the cut-off energy and in the meaning of the plane-waves used from step-to-step). The constant-cutoff/variable-number of plane-waves approach is the CASTEP default as it is the most physically reasonable. The constant number of plane-waves approach means that the quality of the calculation is changing from step-to-step. The effect of changing lattice vectors on the basis set can also be corrected to first-order using the 'finite basis set correction'. This can be calculated by the change in total energy for a small change in the cut-off energy at the start of a calculation, and then used as a correction to the energy and the stress. This is especially important in variable-cell calculations, for which it is activated by default.","title":"Finite-basis set corrections"},{"location":"documentation/Geometry_Optimisation/overview/#advanced-settings","text":"For geometry optimisation, there are a variety of different algorithms available which can be selected by the geom_method parameter in the param file. The choices are: LBFGS - the low-memory version of BFGS - the default option BFGS - widely-used quasi-Newton minimization TPSD - two-point steepest descent DELOCALIZED - a BFGS-based minimizer using delocalized internal coordinates DMD - optimally damped MD FIRE - fast inertial relaxation engine - a modified MD approach NB These are all 'local optimisations', i.e. the final structure depends upon the initial configuration and is not the global minimum. For those interested in finding the global minimum, then there are associated projects using Genetic Algorithms and AIRSS. The first 3 methods can do variable-cell or fixed-cell optimization, whereas the last 3 are only fixed-cell (for now). LBFGS/BFGS is generally the fastest method, and since v19, LBFGS has supported new preconditioners which should make it generally faster still. TPSD (unlike LBFGS/BFGS) has no built-in history, so should be much slower - however, the CASTEP implementation has a very efficient preconditioner which makes up for this, and the lack of history means that variable-cell optimisation with additional cell constraints is much more efficient than the equivalent calculation in LBFGS/BFGS. The DELOCALIZED minimizer is the only supported method to use delocalized internal coordinates, as opposed to absolute or fractional coordinates, and as such, should be best for optimizing large structures such as molecule-in-a-box with many low-energy soft modes. The two MD-based methods are generally less efficient, but can handle arbitrary constraints well, and have sometimes out-performed other methods for very anisotropic systems, such as molecule-on-a-surface etc.","title":"Advanced settings"},{"location":"documentation/Geometry_Optimisation/tools/","text":"JMol can read a .geom file and animate the movement of atoms during the optimisation.","title":"Tools"},{"location":"documentation/Getting_Started/basic_cell_file/","text":"This is a basic overview of the cell file. See the full cell file page for more details. The cell file is one of CASTEP's two main input files. It contains all of the information about the crystal lattice and the atomic positions, as well as additional information such as Brillouin zone sampling ('k-points'), pseudopotentials, and atomic properties. The file itself is a free-format keyword-driven text file, consisting of keywords and blocks of information. These may be given in any order, with blocks indicated by the special %block and %endblock markers. Most of the keywords and blocks are optional, but CASTEP requires two block entries: a block to specify the lattice, and another to specify the atomic elements and positions within the cell. Lattice There are two main ways to set the crystal lattice in the cell file. The lattice_abc block specifies the lattice constants in terms of the lengths of the lattice vectors ( \\mathbf{a} \\mathbf{a} , \\mathbf{b} \\mathbf{b} and \\mathbf{c} \\mathbf{c} ) and angles (alpha, beta and gamma): %block lattice_abc a b c alpha beta gamma %endblock lattice_abc This doesn't specify how the cell is to be oriented in the Cartesian coordinate system, so CASTEP uses the convention that \\mathbf{a} \\mathbf{a} is along the x-axis, and \\mathbf{b} \\mathbf{b} is in the x-y plane. Alternatively, you can specify the lattice vectors \\mathbf{a} \\mathbf{a} , \\mathbf{b} \\mathbf{b} and \\mathbf{c} \\mathbf{c} directly in terms of their Cartesian components, using the lattice_cart block. Note that these are specified as row vectors: %block lattice_cart [unit] a_x a_y a_z b_x b_y b_z c_x c_y c_z %endblock lattice_cart The first line is optional, and specifies a length unit; the default is ang , meaning Angstroms. Atomic positions The positions of the atoms within a cell may be specified in either fractional coordinates (i.e. the coordinates in the basis of the lattice vectors) or Cartesian coordinates: %block positions_frac symbol u v w %endblock positions_frac where symbol is the chemical symbol for the atomic element, and u , v and w are the fractional components of the lattice vectors \\mathbf{a} \\mathbf{a} , \\mathbf{b} \\mathbf{b} and \\mathbf{c} \\mathbf{c} , respectively, such that the Cartesian positions vector of the atom, \\mathbf{r} \\mathbf{r} , is \\mathbf{r} = u\\mathbf{a} + v\\mathbf{b} + w\\mathbf{c} \\mathbf{r} = u\\mathbf{a} + v\\mathbf{b} + w\\mathbf{c} To add a second atom, simply add a second line with the new information, and similarly for additional atoms. An alternative is to specify the atomic coordinates with reference to their absolute Cartesian coordinates: %block positions_abs [unit] symbol x y z %endblock positions_abs where [unit] is an optional length unit (default: ang , meaning Angstroms), symbol is the chemical symbol for the atomic element, and x , y and z are the Cartesian coordinates of the atom, such that the position vector, \\mathbf{r}=(x,y,z) \\mathbf{r}=(x,y,z) . Comments It can be convenient to add comments to a cell file, not only to explain why certain choices were made, but also as a way of disabling input lines without removing them from the file. Both ! and # are accepted as comment characters, and anything to the right of these will be ignored by CASTEP. For example, the cell section # Place a single atom at the origin %block positions_abs bohr C 0.00000000 0.00000000 0.00000000 !Si 0.00000000 0.00000000 0.00000000 %endblock positions_abs has a comment explaining the atomic coordinates, and a single carbon atom at the origin. The second atomic position is commented out, so CASTEP will ignore it.","title":"cell File"},{"location":"documentation/Getting_Started/basic_cell_file/#lattice","text":"There are two main ways to set the crystal lattice in the cell file. The lattice_abc block specifies the lattice constants in terms of the lengths of the lattice vectors ( \\mathbf{a} \\mathbf{a} , \\mathbf{b} \\mathbf{b} and \\mathbf{c} \\mathbf{c} ) and angles (alpha, beta and gamma): %block lattice_abc a b c alpha beta gamma %endblock lattice_abc This doesn't specify how the cell is to be oriented in the Cartesian coordinate system, so CASTEP uses the convention that \\mathbf{a} \\mathbf{a} is along the x-axis, and \\mathbf{b} \\mathbf{b} is in the x-y plane. Alternatively, you can specify the lattice vectors \\mathbf{a} \\mathbf{a} , \\mathbf{b} \\mathbf{b} and \\mathbf{c} \\mathbf{c} directly in terms of their Cartesian components, using the lattice_cart block. Note that these are specified as row vectors: %block lattice_cart [unit] a_x a_y a_z b_x b_y b_z c_x c_y c_z %endblock lattice_cart The first line is optional, and specifies a length unit; the default is ang , meaning Angstroms.","title":"Lattice"},{"location":"documentation/Getting_Started/basic_cell_file/#atomic-positions","text":"The positions of the atoms within a cell may be specified in either fractional coordinates (i.e. the coordinates in the basis of the lattice vectors) or Cartesian coordinates: %block positions_frac symbol u v w %endblock positions_frac where symbol is the chemical symbol for the atomic element, and u , v and w are the fractional components of the lattice vectors \\mathbf{a} \\mathbf{a} , \\mathbf{b} \\mathbf{b} and \\mathbf{c} \\mathbf{c} , respectively, such that the Cartesian positions vector of the atom, \\mathbf{r} \\mathbf{r} , is \\mathbf{r} = u\\mathbf{a} + v\\mathbf{b} + w\\mathbf{c} \\mathbf{r} = u\\mathbf{a} + v\\mathbf{b} + w\\mathbf{c} To add a second atom, simply add a second line with the new information, and similarly for additional atoms. An alternative is to specify the atomic coordinates with reference to their absolute Cartesian coordinates: %block positions_abs [unit] symbol x y z %endblock positions_abs where [unit] is an optional length unit (default: ang , meaning Angstroms), symbol is the chemical symbol for the atomic element, and x , y and z are the Cartesian coordinates of the atom, such that the position vector, \\mathbf{r}=(x,y,z) \\mathbf{r}=(x,y,z) .","title":"Atomic positions"},{"location":"documentation/Getting_Started/basic_cell_file/#comments","text":"It can be convenient to add comments to a cell file, not only to explain why certain choices were made, but also as a way of disabling input lines without removing them from the file. Both ! and # are accepted as comment characters, and anything to the right of these will be ignored by CASTEP. For example, the cell section # Place a single atom at the origin %block positions_abs bohr C 0.00000000 0.00000000 0.00000000 !Si 0.00000000 0.00000000 0.00000000 %endblock positions_abs has a comment explaining the atomic coordinates, and a single carbon atom at the origin. The second atomic position is commented out, so CASTEP will ignore it.","title":"Comments"},{"location":"documentation/Getting_Started/basic_param_file/","text":"This is a basic overview of the param file. See the full param file page for more details. The param file is one of CASTEP's two main input files. It contains all of the information about the kind of simulation your wish CASTEP to perform, as well as details of how CASTEP should perform them and additional simulations and analyses. The file itself is a free-format keyword-driven text file, consisting largely of single-line keywords, although there are a small number of blocks of information. These may be given in any order, with blocks indicated by the special %block and %endblock markers. All of the keywords and blocks are optional, but you will almost always want to change at least some. Task This keyword controls what CASTEP's simulation task is. The default is task : energy which tells CASTEP to compute the ground state electronic energy and density for the input set of atoms from the cell file . Cut-off energy The plane-wave cut-off energy controls how large CASTEP's basis set is for representing the wavefunction. Higher values mean more plane-waves and a better representation of the wavefunction, but this consumes more computer RAM and the calculation will take more time. CASTEP calculations are always a compromise between the accuracy you require, and the computational resources the simulations will use. The cut-off energy you need will also depend on the pseudopotentials you're using in the cell file . You can choose from some preset values using the basis_precision keyword: basis_precision : coarse|medium|fine|precise i.e. you can choose to set basis_precision to coarse , medium , fine or precise . The settings coarse and medium are usually only suitable for quick preliminary investigations, and for research simulations you will usually want to set it to fine or better. For more control over the cut-off energy, the cut_off_energy keyword may be used instead: cut_off_energy : 500 eV Typical cut-off energies are in the range 300 to 1500 eV. XC functional Density functional theory is exact in principle, except for the exchange-correlation (XC) functional which must be approximated. There are many different functional forms to approximate this, and in CASTEP you select it with the xc_functional keyword, for example: xc_functional : pbe which selects the PBE functional of Perdew, Burke and Ernzerhof.","title":"param File"},{"location":"documentation/Getting_Started/basic_param_file/#task","text":"This keyword controls what CASTEP's simulation task is. The default is task : energy which tells CASTEP to compute the ground state electronic energy and density for the input set of atoms from the cell file .","title":"Task"},{"location":"documentation/Getting_Started/basic_param_file/#cut-off-energy","text":"The plane-wave cut-off energy controls how large CASTEP's basis set is for representing the wavefunction. Higher values mean more plane-waves and a better representation of the wavefunction, but this consumes more computer RAM and the calculation will take more time. CASTEP calculations are always a compromise between the accuracy you require, and the computational resources the simulations will use. The cut-off energy you need will also depend on the pseudopotentials you're using in the cell file . You can choose from some preset values using the basis_precision keyword: basis_precision : coarse|medium|fine|precise i.e. you can choose to set basis_precision to coarse , medium , fine or precise . The settings coarse and medium are usually only suitable for quick preliminary investigations, and for research simulations you will usually want to set it to fine or better. For more control over the cut-off energy, the cut_off_energy keyword may be used instead: cut_off_energy : 500 eV Typical cut-off energies are in the range 300 to 1500 eV.","title":"Cut-off energy"},{"location":"documentation/Getting_Started/basic_param_file/#xc-functional","text":"Density functional theory is exact in principle, except for the exchange-correlation (XC) functional which must be approximated. There are many different functional forms to approximate this, and in CASTEP you select it with the xc_functional keyword, for example: xc_functional : pbe which selects the PBE functional of Perdew, Burke and Ernzerhof.","title":"XC functional"},{"location":"documentation/Getting_Started/built_in_help/","text":"CASTEP has an in-built help option to assist with using particular keywords. Information on using CASTEP can be seen by using: castep -h To get more information on a particular input file keyword (e.g. kpoint_mp_grid ) use: castep -h kpoint_mp_grid If you don't know the keyword you need to use, then you can search on a particular keyword. This returns a list of keywords that you might be interested in, e.g. to look at all keywords which contain a reference to symmetry. castep -s symmetry Finally, to list all keywords, use: castep -h all To find out which version of CASTEP you have, use: castep -v","title":"Command line help"},{"location":"documentation/Getting_Started/intro/","text":"CASTEP is a software package to calculate the properties of materials. It is based on quantum mechanics, in a form known as density functional theory, and can simulate a wide range of materials proprieties including energetics, structure at the atomic level, vibrational properties, and many experimental characterisation methods, such as infra-red and Raman spectra, NMR, and core-level spectra. This documentation This documentation focuses on using CASTEP at the command-line, as a stand-alone program. You can build two versions of CASTEP: a \"serial\" version called castep.serial , which is primarily designed to run on a single CPU core; or a parallel version called castep.mpi , which uses the message passing interface (MPI) to run on more than one core. Most of this documentation applies equally to both versions, but for simplicity we will focus on the serial version in most of the examples. We will refer to the CASTEP command itself as castep , which you will need to change to castep.serial or castep.mpi , as appropriate. In this documentation, anything in a fixed width font like this is text to type, either on the command-line or in a CASTEP input file. For CASTEP's input files, there is sometimes a choice between different settings, and this will be indicated using the | symbol, meaning \"or\". For example, setting : choice_1|choice_2|choice_3 If some of the entries are optional, they will have square brackets around them [like this] , for example: setting : choice_1|choice_2|choice_3 [unit of choice]","title":"Introduction"},{"location":"documentation/Getting_Started/intro/#this-documentation","text":"This documentation focuses on using CASTEP at the command-line, as a stand-alone program. You can build two versions of CASTEP: a \"serial\" version called castep.serial , which is primarily designed to run on a single CPU core; or a parallel version called castep.mpi , which uses the message passing interface (MPI) to run on more than one core. Most of this documentation applies equally to both versions, but for simplicity we will focus on the serial version in most of the examples. We will refer to the CASTEP command itself as castep , which you will need to change to castep.serial or castep.mpi , as appropriate. In this documentation, anything in a fixed width font like this is text to type, either on the command-line or in a CASTEP input file. For CASTEP's input files, there is sometimes a choice between different settings, and this will be indicated using the | symbol, meaning \"or\". For example, setting : choice_1|choice_2|choice_3 If some of the entries are optional, they will have square brackets around them [like this] , for example: setting : choice_1|choice_2|choice_3 [unit of choice]","title":"This documentation"},{"location":"documentation/Getting_Started/restarting/","text":"Checkpointing and Restarting CASTEP provides a mechanism for saving intermediate and final states of the calculation and for restarting or continuing from a saved state. At the end of every calculation which completes normally, CASTEP writes two files <seed>.check and <seed>.castep_bin which are binary-format files containing a complete state of the calculation including input parameters, cell variables, electron densities and any results or intermediate quantities whose calculation has completed. All inputs and results reported in the .castep file are saved to the checkpoint: indeed a lost .castep file from a completed calculation may be (mostly) regenerated using a minimal continuation run. .check vs .castep_bin The only difference between .check and .castep_bin is that the .check file contains the converged ground-state wavefunctions but .castep_bin does not, and therefore requires much less disk space to store. This makes it useful for purposes of archiving a calculation. When continuing from a .castep_bin CASTEP will regenerate the ground state wavefunctions non-selfconsistently using the ground-state density from the file. Checkpointing during a calculation An incomplete calculation can be completed in a new run by adding the parameters keyword continuation : default in the .param file and rerunning CASTEP as before with the same <seed> command-line argument. This is the usual way of continuing a run interrupted, for example, by the job time limit on a batch scheduling system. To benefit from continuation, a checkpoint file must have been written in the original run. There are three parameters keywords which may be used to do this: num_backup_iter <n> write a checkpoint every <n> (default 5) geometry MD or phonon steps backup_interval <s> write a checkpoint every <s> seconds run_time <s> write a checkpoint and exit at the first opportunity after <s> seconds have elapsed. These may be used to periodically checkpoint many lengthy post-SCF tasks including geometry optimization, MD, phonon calculations, but checkpointing of spectral and magres tasks is not supported via this mechanism. Neither is checkpointing possible within an extremely lengthy SCF calculation, but see the next section for an alternative. Checkpoint files are portable, and independent of data-distribution, so the continuation run may use a different number of parallel nodes, data distribution, OpenMP etc. They are also portable across computers, so a run may be started on one computer and finished on another, which may be helpful to balance use of computer resources. Advanced keywords One additional related parameters keyword which finds occasional use is a simple one-liner stop which can be added to the .param file while a run is in progress. CASTEP rereads the .param file at every checkpoint opportunity and if this is present will perform a graceful exit after writing the checkpoint files. Which periodic and end-of-run checkpoint files are written may be controlled by the parameters keyword write_checkpoint which takes values none : to suppress checkpoints completely minimal writes only .castep_bin all : writes both .check and .castep_bin Continuing from completed calculations The checkpoint/restart mechanism may also be used to \"chain\" runs or initialise a modified run with the results of a previous one. The .param file of the new run should contain continuation : <oldseed>.check Parameters values stored in and read from <oldseed>.check will be used, unless overridden by the new .param file, which therefore needs only a minimal number of entries. The .cell file is usually just copy of the original, but may also be modified if needed. Modifying task is a good way to \"chain\" calculations, for example performing a geometry optimisation followed by a spectral calculation. Info Not all parameter or cell keywords can be overridden upon continuation. castep --help <parameter-name> will report whether a variable is modifiable on continuation","title":"Checkpoint and Restart"},{"location":"documentation/Getting_Started/restarting/#checkpointing-and-restarting","text":"CASTEP provides a mechanism for saving intermediate and final states of the calculation and for restarting or continuing from a saved state. At the end of every calculation which completes normally, CASTEP writes two files <seed>.check and <seed>.castep_bin which are binary-format files containing a complete state of the calculation including input parameters, cell variables, electron densities and any results or intermediate quantities whose calculation has completed. All inputs and results reported in the .castep file are saved to the checkpoint: indeed a lost .castep file from a completed calculation may be (mostly) regenerated using a minimal continuation run. .check vs .castep_bin The only difference between .check and .castep_bin is that the .check file contains the converged ground-state wavefunctions but .castep_bin does not, and therefore requires much less disk space to store. This makes it useful for purposes of archiving a calculation. When continuing from a .castep_bin CASTEP will regenerate the ground state wavefunctions non-selfconsistently using the ground-state density from the file.","title":"Checkpointing and Restarting"},{"location":"documentation/Getting_Started/restarting/#checkpointing-during-a-calculation","text":"An incomplete calculation can be completed in a new run by adding the parameters keyword continuation : default in the .param file and rerunning CASTEP as before with the same <seed> command-line argument. This is the usual way of continuing a run interrupted, for example, by the job time limit on a batch scheduling system. To benefit from continuation, a checkpoint file must have been written in the original run. There are three parameters keywords which may be used to do this: num_backup_iter <n> write a checkpoint every <n> (default 5) geometry MD or phonon steps backup_interval <s> write a checkpoint every <s> seconds run_time <s> write a checkpoint and exit at the first opportunity after <s> seconds have elapsed. These may be used to periodically checkpoint many lengthy post-SCF tasks including geometry optimization, MD, phonon calculations, but checkpointing of spectral and magres tasks is not supported via this mechanism. Neither is checkpointing possible within an extremely lengthy SCF calculation, but see the next section for an alternative. Checkpoint files are portable, and independent of data-distribution, so the continuation run may use a different number of parallel nodes, data distribution, OpenMP etc. They are also portable across computers, so a run may be started on one computer and finished on another, which may be helpful to balance use of computer resources. Advanced keywords One additional related parameters keyword which finds occasional use is a simple one-liner stop which can be added to the .param file while a run is in progress. CASTEP rereads the .param file at every checkpoint opportunity and if this is present will perform a graceful exit after writing the checkpoint files. Which periodic and end-of-run checkpoint files are written may be controlled by the parameters keyword write_checkpoint which takes values none : to suppress checkpoints completely minimal writes only .castep_bin all : writes both .check and .castep_bin","title":"Checkpointing during a calculation"},{"location":"documentation/Getting_Started/restarting/#continuing-from-completed-calculations","text":"The checkpoint/restart mechanism may also be used to \"chain\" runs or initialise a modified run with the results of a previous one. The .param file of the new run should contain continuation : <oldseed>.check Parameters values stored in and read from <oldseed>.check will be used, unless overridden by the new .param file, which therefore needs only a minimal number of entries. The .cell file is usually just copy of the original, but may also be modified if needed. Modifying task is a good way to \"chain\" calculations, for example performing a geometry optimisation followed by a spectral calculation. Info Not all parameter or cell keywords can be overridden upon continuation. castep --help <parameter-name> will report whether a variable is modifiable on continuation","title":"Continuing from completed calculations"},{"location":"documentation/Getting_Started/running_castep/","text":"CASTEP has two main input files, called the cell file and the param file . The cell file defines the structure of the material (or molecule) you wish to study, and the param file defines the kind of simulation CASTEP should perform. The cell and param files should be named using the same prefix, which CASTEP calls the \"seedname\", with the extensions .cell and .param , respectively. For example, for a calculation called mytest , you need the input files mytest.cell mytest.param and the calculation is run with the command castep mytest The main CASTEP output file will be names using the same seedname and the .castep extension, i.e. in the above example it would be called mytest.castep . If this file already exists, CASTEP will append its output to it. When CASTEP completes successfully, it writes additional files such as the .bib file, which contains references to key papers for the theory and methods CASTEP used. If CASTEP encounters a serious problem, it will stop and write an error message to a .err file. If you are using the parallel version of CASTEP on many cores, you may see error files from each of these cores. They are named using the same seedname, but with the numeric process ID added, e.g. if CASTEP is run on 2 cores and a serious problem occurs, you might see the files mytest.0001.err mytest.0002.err These files contain useful information about what went wrong, so it is always worth looking at them. See the Troubleshooting Guide for details of how to find and fix common problems.","title":"Running CASTEP"},{"location":"documentation/Groundstate/dftd/","text":"Long-range dispersion corrections TODOS do the TSSURF and TSSCS schemes work/do anything? are the aperiodic versions of TSSCS and MBD still a thing? What elements are supported for D3? General recommendations for types of systems -- are these ok? Add others? Check note about small cells and the TS, XDM abd MBD methods. Is the solution just to use a bigger supercell? Rule of thumb? Background Why and when are long range-dispersion methods needed? van der Waals (vdW) interactions are ubiquitous in nature but aren't accounted for by standard local and semilocal density functional approximations (i.e. LDA or GGAs). In particular, the long-range attractive part of the vdW interaction between system components (London dispersion interaction) is not captured. Including such dispersion effects is essential for accurately describing certain systems, especially for systems that are not bound ionically or covalently, e.g. gas molecules. The use of a dispersion method is strongly recommended when intermolecular interactions are expected to play a key role such as in molecular crystals, stacked 2D materials, and generally any weakly-bound system. Types of correction schemes There are several families of dispersion methods. A good summary of these can be found in the 2016 review by Grimme et al. We will summarise these categories here and, for those implemented in CASTEP, link to the relevant keywords. Semiempirical/semiclassical treatments Here the dispersion energy is calculated atom-wise (typically pair-wise) and is added to the DFT energy of the underlying functional. Note that a specific damping parameter (and function) is usually used to combine a given underlying functional (e.g. PBE) with a dispersion correction (e.g. D3). This means, for example, that the D3 correction to the PBE functional may be different to the D3 correction to HSE. Methods include: The Tkatchenko\u2212Scheffler scheme ( TS ) The TS-based many-body dispersion scheme ( MBD ) Grimme's D2 and D3 methods The exchange-dipole moment model ( XDM ) Nonlocal density-based treatments (not implemented in CASTEP) Here non-local functionals of the electronic density are constructed. Methods include the van der Waals functionals (e.g. vdW-DF2 and vdW-DF-cx ) and Vydrov and Van Voorhis functionals (e.g. VV10 ). Effective one-electron potentials (not implemented in CASTEP) Finally, the many-body correlated motion of electrons can be, to some extent, captured empiricially by using effective one-electron potentials. Examples of these include: semi-local functionals such as the Minnesota functionals (e.g. M06 ) and external potentials such as the dispersion-corrected atom-centered potentials (see e.g. van Santen 2015 ). General recommendations TODO -- check these Every application will have its own set of important features and it is not possible to say with certainty which density functional approximation will be the most appropriate. With that said, here are some suggestions for different types of materials: Molecular crystals: D3/D3-BJ/XDM/MBD in combination with GGA or hybrid functionals ( Dolgonos et al. 2019 ). Metals: vdW-DFs developed with solid state materials in mind (see e.g. Klime\u0161 et al. 2011 ). TODO: what about methods available in CASTEP? Interactions between molecules and surfaces of metals: vdW-DFs or dispersion methods that include screening, e.g. TSSCS MOFs: dispersion corrected (e.g. TS, D3, etc.) GGAs Layered vdW materials: Beyond pairwise appraches, e.g. D3 ^* ^* or MBD. TODO: others? ^* ^* See note below for how to include the three-body terms in the CASTEP D3 correction. Again, please do your own testing and consult relevant reviews and benchmarking papers. For the TS, MBD and XDM methods you may get a warning if your unit cell is small (where the lattice constants are comparable to the vdW radii). In such cases, try to use larger unit cells until your dispersion correction converges. TODO: any other solutions? Not all XC_FUNCTIONAL values are supported for all schemes - if in doubt use PBE. Each scheme has default parameters defined for a subset of elements (see table below). For other elements you need to define custom parameters using the SEDC_CUSTOM_PARAMS keyword in the .cell file. Using dispersion corrections in CASTEP .param file keywords In the .param file, set: SEDC_APPLY : true turns on dispersion correction. SEDC_SCHEME : The semi-empirical dispersion/van der Waals correction scheme to use. Default is NONE , other possible values listed in the table below. SEDC_SCHEME Available from CASTEP version Compatible XC functionals Elements supported Stresses Phonons * TS Predates 2012 PBE, PBE0, PBE1PBE, BLYP, B3LYP, AM0, RPB, PBESOL, PW91 Up to Z=54 with first row Lanthanides Analytic DFPT & FD TSSURF Not sure if working TSSCS Not sure if working Up to Z=54 with first row Lanthanides Analytic MBD (Alias: MBD*) 2015? Rewritten (and fixed) for CASTEP 18 PBE, PBE0, PBE1PBE, HSE03, HSE06, RSCAN Up to Z=54 with first row Lanthanides Numeric FD G06 (= D2) Predates 2012 PBE, BLYP, BP86, B3LYP, TPSS Up to Z= 54 Analytic DFPT & FD D3 CASTEP 20 ( Compilation instructions ) PBE, PBE0, HF Analytic FD D3-BJ CASTEP 20 ( Compilation instructions ) PBE, PBE0, HF Analytic FD OBS Predates 2012 LDA, PW91 Up to Z=57 Analytic DFPT & FD JCHS Predates 2012 PBE, BLYP, B3LYP, TPSS H, C, N, O, F, Cl, Br Analytic DFPT & FD XDM CASTEP 20 PBE Up to Z=102 Analytic FD * DFPT: Density functional perturbation theory; FD: finite displacement. All of the above methods support analytic forces. .cell file keywords In the .cell file you can optionally set custom parameters for each species: C6 (eV \u00c5 ^6 ^6 ): Available for TS, MBD*, and Grimme schemes. R0 (\u00c5): Available for TS, MBD*, and Grimme schemes. alpha (\u00c5 ^3 ^3 ): Available for TS, MBD*, and OBS schemes. I (eV): Available for the OBS scheme. Rvdw (\u00c5): Available for the OBS scheme. You set them like this: %BLOCK SEDC_CUSTOM_PARAMS ! example values for test purposes only - don't use these... ! He C6:1.00 R0:2.00 Ne C6:10.00 R0:4.00 %ENDBLOCK SEDC_CUSTOM_PARAMS Method details and customisation Tkatchenko\u2212Scheffler schemes A density-dependent, atom pairwise dispersion-correction scheme. SEDC_SCHEME : TS Phys. Rev. Lett.,102, 073005 (2009) Restrictions: Can only be used with the following XC functionals: PBE, PBE0, PBE1PBE, BLYP, B3LYP, AM0, RPB, PBESOL, PW91 Elements up to Z=54 (Xe) together with first row Lanthanides are supported. SEDC_SCHEME : TSSCS # TS with self-consistent screening Phys. Rev. Lett., 108, 236402 (2012) SEDC_SCHEME : TSSURF Phys. Rev. Lett., 108, 146103 (2012) Customisation keywords for all TS schemes .param file SEDC_SR_TS Type: Real (float) Level: Expert Description: Customisable SR value for the damping function in the TS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_D_TS Type: Real (float) Level: Expert Description: Customisable d value for the damping function in the TS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . .cell file SEDC_CUSTOM_PARAMS Type: Block Level: Basic Description: Customized parameters for semi-empirical dispersion corrections. Used to calculate van der Waals forces. Default value for each species is determined by the chosen semiempirical correction scheme. For the TS methods, C6 (eV \u00c5 ^6 ^6 ), R0 (\u00c5) and alpha (\u00c5 ^3 ^3 ) can be customised. Many-body dispersion Beyond what can be included in simple pairwise dispersion approaches, MBD introduces: (1) many-body energy (Axilrod-Teller and higher-order) and (2) long-range Coulomb response (screening) that serves to modify the polarizabilities of interacting species. SEDC_SCHEME : MBD # (Alias: MBD*) Phys. Rev. Lett., 108, 236402 (2012) J. Chem. Phys. 140, 18A508 (2014) Note that the two aliases MBD and MBD* both refer to the revised version of MBD which employs range-separation (rs) of the self-consistent screening (SCS) of polarizabilities and the calculation of the long-range correlation energy, i.e. the MBD@rs-scs method. TODO : in older versions of CASTEP was this the case? From what version can be rely on that info? Restrictions: Can only be used with the following XC functionals: PBE, PBE0, PBE1PBE, HSE03, HSE06, RSCAN Elements up to Z=54 (Xe) together with first row Lanthanides are supported. Note that in the current implementation, only numeric stresses are available. Customisation keywords for MBD scheme .param file SEDC_SR_TS Type: Real (float) Level: Expert Description: Customisable SR value for the damping function in the TS and MBD correction schemes. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_D_TS Type: Real (float) Level: Expert Description: Customisable d value for the damping functionin the TS and MBD correction schemes. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . .cell file SEDC_CUSTOM_PARAMS Type: Block Level: Basic Description: Customized parameters for semi-empirical dispersion corrections. Used to calculate van der Waals forces. Default value for each species is determined by the chosen semiempirical correction scheme. For the MBD method, C6 (eV \u00c5 ^6 ^6 ), R0 (\u00c5) and alpha (\u00c5 ^3 ^3 ) can be customised. Grimme D corrections D2 Note that default D2 parameters are available only for the PBE, BLYP, BP86, B3LYP, TPSS functionals. You can also customise the correction parameters using the following keywords: SEDC_SCHEME : G06 # This is CASTEP's name for the Grimme D2 correction J. Comput. Chem. 27, 1787, (2006) Customisation keywords G06 .param file SEDC_S6_G06 Type: Real (float) Level: Expert Description: Customisable S6 value for the damping function in the G06 semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_D_G06 Type: Real (float) Level: Expert Description: Customisable d value for the damping function in the G06 semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . .cell file SEDC_CUSTOM_PARAMS Type: Block Level: Basic Description: Customized parameters for semi-empirical dispersion corrections. Used to calculate van der Waals forces. Default value for each species is determined by the chosen semiempirical correction scheme. For Grimme's D2 method, C6 (eV \u00c5 ^6 ^6 ) and R0 (\u00c5) can be customised. D3 Grimme's DFT-D3 method. The D3 scheme with Becke-Johnson damping (D3-BJ) is generally more accurate than the 'zero-damping' method (D3). Restrictions: Default D3 parameters are available for the PBE, PBE0 and HF functionals. TODO: what elements are supported? By default the three-body term is not included . To include it, set d3_threebody: True within a devel_code block in the .param file. Turn on IPRINT > 1 to get more information on what has been included in the D3 correction. In the current implementation, users cannot supply custom parameters for this correction scheme. SEDC_SCHEME : D3 J. Chem. Phys. 132, 154104 (2010) SEDC_SCHEME : D3-BJ J. Comput. Chem. 32, 1456 (2011) This is the Grimme D3 scheme with Becke-Johnson damping. Note When running a D3-BJ calculation with IPRINT > 1 , you might see Dispersion version: D4 in the .castep output file. Confusingly, this does not mean the Grimme D4 method has been used, it's just an interal CASTEP version label for this correction scheme. Compilation flags: for the D3 correction, CASTEP must be compiled with GRIMMED3 := compile Note that for the D3 correction to work, CASTEP must be compiled with the following flag: # Grimme D3 library support. Options are none or compile GRIMMED3 := compile in the Makefile For CASTEP 20, the D3 library is included in the distribution and the setting the flag above should be sufficient. Exchange-dipole moment (XDM) method SEDC_SCHEME : XDM A unified density-functional treatment of dynamical, nondynamical, and dispersion correlations. J. Chem. Phys. 127, 124108 (2007) To use this correction with the PBE functional, you need to set: SEDC_APPLY = TRUE SEDC_SCHEME = XDM SEDC_SC_XDM = 1.0 where the SEDC_SC_XDM parameter is a global scaling factor. For other functionals you need to specify the following additional parameters: Customisation keywords for XDM .param file SEDC_A1_XDM Type: Real (float) Level: Expert Description: Customisable A1 value for the damping function in the XDM semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_A2_XDM Type: Physical (float) Level: Expert Description: Customisable A2 value for the damping function in the XDM semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_SC_XDM Type: Real (float) Level: Expert Description: Customisable SC value for the damping function in the XDM semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_C9_XDM Type: Logical Level: Basic Description: Specifies whether three-body dispersion coefficients are to be computed in the XDM semi-empirical dispersion/ van der Waals correction scheme. Modifiable: restart and on the fly Allowed values: TRUE or FALSE Default is FALSE Note that the specific parameters found here: http://schooner.chem.dal.ca/wiki/XDM are might not be directly transferable to CASTEP and careful further testing is necessary. Other Schemes SEDC_SCHEME : OBS # (Ortmann, Bechstedt and Schmidt) Semiempirical van der Waals correction to the density functional description of solids and molecular structures Phys. Rev. B 73, 205101, (2006) Customisation keywords \" SEDC_LAMBDA_OBS \" Type: Real (float) Level: Expert Description: Customisable lambda value for damping function in the the OBS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . \" SEDC_N_OBS \" Type: Real (float) Level: Expert Description: Customisable n value for the damping function in the OBS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_SCHEME : JCHS # (Jure\u010dka, \u010cern\u00fd, Hobza and Salahub) J. Comput. Chem. 28, 555, (2007) Customisation keywords SEDC_SR_JCHS Type: Real (float) Level: Expert Description: Customisable SR value for the damping function in the JCHS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_S6_JCHS Type: Real (float) Level: Expert Description: Customisable S6 value for the damping function in the JCHS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_D_JCHS Type: Real (float) Level: Expert Description: Customisable d value for the damping function in the JCHS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL .","title":"Dispersion Corrections"},{"location":"documentation/Groundstate/dftd/#long-range-dispersion-corrections","text":"TODOS do the TSSURF and TSSCS schemes work/do anything? are the aperiodic versions of TSSCS and MBD still a thing? What elements are supported for D3? General recommendations for types of systems -- are these ok? Add others? Check note about small cells and the TS, XDM abd MBD methods. Is the solution just to use a bigger supercell? Rule of thumb?","title":"Long-range dispersion corrections"},{"location":"documentation/Groundstate/dftd/#background","text":"","title":"Background"},{"location":"documentation/Groundstate/dftd/#why-and-when-are-long-range-dispersion-methods-needed","text":"van der Waals (vdW) interactions are ubiquitous in nature but aren't accounted for by standard local and semilocal density functional approximations (i.e. LDA or GGAs). In particular, the long-range attractive part of the vdW interaction between system components (London dispersion interaction) is not captured. Including such dispersion effects is essential for accurately describing certain systems, especially for systems that are not bound ionically or covalently, e.g. gas molecules. The use of a dispersion method is strongly recommended when intermolecular interactions are expected to play a key role such as in molecular crystals, stacked 2D materials, and generally any weakly-bound system.","title":"Why and when are long range-dispersion methods needed?"},{"location":"documentation/Groundstate/dftd/#types-of-correction-schemes","text":"There are several families of dispersion methods. A good summary of these can be found in the 2016 review by Grimme et al. We will summarise these categories here and, for those implemented in CASTEP, link to the relevant keywords. Semiempirical/semiclassical treatments Here the dispersion energy is calculated atom-wise (typically pair-wise) and is added to the DFT energy of the underlying functional. Note that a specific damping parameter (and function) is usually used to combine a given underlying functional (e.g. PBE) with a dispersion correction (e.g. D3). This means, for example, that the D3 correction to the PBE functional may be different to the D3 correction to HSE. Methods include: The Tkatchenko\u2212Scheffler scheme ( TS ) The TS-based many-body dispersion scheme ( MBD ) Grimme's D2 and D3 methods The exchange-dipole moment model ( XDM ) Nonlocal density-based treatments (not implemented in CASTEP) Here non-local functionals of the electronic density are constructed. Methods include the van der Waals functionals (e.g. vdW-DF2 and vdW-DF-cx ) and Vydrov and Van Voorhis functionals (e.g. VV10 ). Effective one-electron potentials (not implemented in CASTEP) Finally, the many-body correlated motion of electrons can be, to some extent, captured empiricially by using effective one-electron potentials. Examples of these include: semi-local functionals such as the Minnesota functionals (e.g. M06 ) and external potentials such as the dispersion-corrected atom-centered potentials (see e.g. van Santen 2015 ).","title":"Types of correction schemes"},{"location":"documentation/Groundstate/dftd/#general-recommendations","text":"TODO -- check these Every application will have its own set of important features and it is not possible to say with certainty which density functional approximation will be the most appropriate. With that said, here are some suggestions for different types of materials: Molecular crystals: D3/D3-BJ/XDM/MBD in combination with GGA or hybrid functionals ( Dolgonos et al. 2019 ). Metals: vdW-DFs developed with solid state materials in mind (see e.g. Klime\u0161 et al. 2011 ). TODO: what about methods available in CASTEP? Interactions between molecules and surfaces of metals: vdW-DFs or dispersion methods that include screening, e.g. TSSCS MOFs: dispersion corrected (e.g. TS, D3, etc.) GGAs Layered vdW materials: Beyond pairwise appraches, e.g. D3 ^* ^* or MBD. TODO: others? ^* ^* See note below for how to include the three-body terms in the CASTEP D3 correction. Again, please do your own testing and consult relevant reviews and benchmarking papers. For the TS, MBD and XDM methods you may get a warning if your unit cell is small (where the lattice constants are comparable to the vdW radii). In such cases, try to use larger unit cells until your dispersion correction converges. TODO: any other solutions? Not all XC_FUNCTIONAL values are supported for all schemes - if in doubt use PBE. Each scheme has default parameters defined for a subset of elements (see table below). For other elements you need to define custom parameters using the SEDC_CUSTOM_PARAMS keyword in the .cell file.","title":"General recommendations"},{"location":"documentation/Groundstate/dftd/#using-dispersion-corrections-in-castep","text":"","title":"Using dispersion corrections in CASTEP"},{"location":"documentation/Groundstate/dftd/#param-file-keywords","text":"In the .param file, set: SEDC_APPLY : true turns on dispersion correction. SEDC_SCHEME : The semi-empirical dispersion/van der Waals correction scheme to use. Default is NONE , other possible values listed in the table below. SEDC_SCHEME Available from CASTEP version Compatible XC functionals Elements supported Stresses Phonons * TS Predates 2012 PBE, PBE0, PBE1PBE, BLYP, B3LYP, AM0, RPB, PBESOL, PW91 Up to Z=54 with first row Lanthanides Analytic DFPT & FD TSSURF Not sure if working TSSCS Not sure if working Up to Z=54 with first row Lanthanides Analytic MBD (Alias: MBD*) 2015? Rewritten (and fixed) for CASTEP 18 PBE, PBE0, PBE1PBE, HSE03, HSE06, RSCAN Up to Z=54 with first row Lanthanides Numeric FD G06 (= D2) Predates 2012 PBE, BLYP, BP86, B3LYP, TPSS Up to Z= 54 Analytic DFPT & FD D3 CASTEP 20 ( Compilation instructions ) PBE, PBE0, HF Analytic FD D3-BJ CASTEP 20 ( Compilation instructions ) PBE, PBE0, HF Analytic FD OBS Predates 2012 LDA, PW91 Up to Z=57 Analytic DFPT & FD JCHS Predates 2012 PBE, BLYP, B3LYP, TPSS H, C, N, O, F, Cl, Br Analytic DFPT & FD XDM CASTEP 20 PBE Up to Z=102 Analytic FD * DFPT: Density functional perturbation theory; FD: finite displacement. All of the above methods support analytic forces.","title":".param file keywords"},{"location":"documentation/Groundstate/dftd/#cell-file-keywords","text":"In the .cell file you can optionally set custom parameters for each species: C6 (eV \u00c5 ^6 ^6 ): Available for TS, MBD*, and Grimme schemes. R0 (\u00c5): Available for TS, MBD*, and Grimme schemes. alpha (\u00c5 ^3 ^3 ): Available for TS, MBD*, and OBS schemes. I (eV): Available for the OBS scheme. Rvdw (\u00c5): Available for the OBS scheme. You set them like this: %BLOCK SEDC_CUSTOM_PARAMS ! example values for test purposes only - don't use these... ! He C6:1.00 R0:2.00 Ne C6:10.00 R0:4.00 %ENDBLOCK SEDC_CUSTOM_PARAMS","title":".cell file keywords"},{"location":"documentation/Groundstate/dftd/#method-details-and-customisation","text":"","title":"Method details and customisation"},{"location":"documentation/Groundstate/dftd/#tkatchenkoscheffler-schemes","text":"A density-dependent, atom pairwise dispersion-correction scheme. SEDC_SCHEME : TS Phys. Rev. Lett.,102, 073005 (2009) Restrictions: Can only be used with the following XC functionals: PBE, PBE0, PBE1PBE, BLYP, B3LYP, AM0, RPB, PBESOL, PW91 Elements up to Z=54 (Xe) together with first row Lanthanides are supported. SEDC_SCHEME : TSSCS # TS with self-consistent screening Phys. Rev. Lett., 108, 236402 (2012) SEDC_SCHEME : TSSURF Phys. Rev. Lett., 108, 146103 (2012) Customisation keywords for all TS schemes .param file SEDC_SR_TS Type: Real (float) Level: Expert Description: Customisable SR value for the damping function in the TS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_D_TS Type: Real (float) Level: Expert Description: Customisable d value for the damping function in the TS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . .cell file SEDC_CUSTOM_PARAMS Type: Block Level: Basic Description: Customized parameters for semi-empirical dispersion corrections. Used to calculate van der Waals forces. Default value for each species is determined by the chosen semiempirical correction scheme. For the TS methods, C6 (eV \u00c5 ^6 ^6 ), R0 (\u00c5) and alpha (\u00c5 ^3 ^3 ) can be customised.","title":"Tkatchenko\u2212Scheffler schemes"},{"location":"documentation/Groundstate/dftd/#many-body-dispersion","text":"Beyond what can be included in simple pairwise dispersion approaches, MBD introduces: (1) many-body energy (Axilrod-Teller and higher-order) and (2) long-range Coulomb response (screening) that serves to modify the polarizabilities of interacting species. SEDC_SCHEME : MBD # (Alias: MBD*) Phys. Rev. Lett., 108, 236402 (2012) J. Chem. Phys. 140, 18A508 (2014) Note that the two aliases MBD and MBD* both refer to the revised version of MBD which employs range-separation (rs) of the self-consistent screening (SCS) of polarizabilities and the calculation of the long-range correlation energy, i.e. the MBD@rs-scs method. TODO : in older versions of CASTEP was this the case? From what version can be rely on that info? Restrictions: Can only be used with the following XC functionals: PBE, PBE0, PBE1PBE, HSE03, HSE06, RSCAN Elements up to Z=54 (Xe) together with first row Lanthanides are supported. Note that in the current implementation, only numeric stresses are available. Customisation keywords for MBD scheme .param file SEDC_SR_TS Type: Real (float) Level: Expert Description: Customisable SR value for the damping function in the TS and MBD correction schemes. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_D_TS Type: Real (float) Level: Expert Description: Customisable d value for the damping functionin the TS and MBD correction schemes. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . .cell file SEDC_CUSTOM_PARAMS Type: Block Level: Basic Description: Customized parameters for semi-empirical dispersion corrections. Used to calculate van der Waals forces. Default value for each species is determined by the chosen semiempirical correction scheme. For the MBD method, C6 (eV \u00c5 ^6 ^6 ), R0 (\u00c5) and alpha (\u00c5 ^3 ^3 ) can be customised.","title":"Many-body dispersion "},{"location":"documentation/Groundstate/dftd/#grimme-d-corrections","text":"D2 Note that default D2 parameters are available only for the PBE, BLYP, BP86, B3LYP, TPSS functionals. You can also customise the correction parameters using the following keywords: SEDC_SCHEME : G06 # This is CASTEP's name for the Grimme D2 correction J. Comput. Chem. 27, 1787, (2006) Customisation keywords G06 .param file SEDC_S6_G06 Type: Real (float) Level: Expert Description: Customisable S6 value for the damping function in the G06 semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_D_G06 Type: Real (float) Level: Expert Description: Customisable d value for the damping function in the G06 semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . .cell file SEDC_CUSTOM_PARAMS Type: Block Level: Basic Description: Customized parameters for semi-empirical dispersion corrections. Used to calculate van der Waals forces. Default value for each species is determined by the chosen semiempirical correction scheme. For Grimme's D2 method, C6 (eV \u00c5 ^6 ^6 ) and R0 (\u00c5) can be customised. D3 Grimme's DFT-D3 method. The D3 scheme with Becke-Johnson damping (D3-BJ) is generally more accurate than the 'zero-damping' method (D3). Restrictions: Default D3 parameters are available for the PBE, PBE0 and HF functionals. TODO: what elements are supported? By default the three-body term is not included . To include it, set d3_threebody: True within a devel_code block in the .param file. Turn on IPRINT > 1 to get more information on what has been included in the D3 correction. In the current implementation, users cannot supply custom parameters for this correction scheme. SEDC_SCHEME : D3 J. Chem. Phys. 132, 154104 (2010) SEDC_SCHEME : D3-BJ J. Comput. Chem. 32, 1456 (2011) This is the Grimme D3 scheme with Becke-Johnson damping. Note When running a D3-BJ calculation with IPRINT > 1 , you might see Dispersion version: D4 in the .castep output file. Confusingly, this does not mean the Grimme D4 method has been used, it's just an interal CASTEP version label for this correction scheme. Compilation flags: for the D3 correction, CASTEP must be compiled with GRIMMED3 := compile Note that for the D3 correction to work, CASTEP must be compiled with the following flag: # Grimme D3 library support. Options are none or compile GRIMMED3 := compile in the Makefile For CASTEP 20, the D3 library is included in the distribution and the setting the flag above should be sufficient.","title":"Grimme D corrections"},{"location":"documentation/Groundstate/dftd/#exchange-dipole-moment-xdm-method","text":"SEDC_SCHEME : XDM A unified density-functional treatment of dynamical, nondynamical, and dispersion correlations. J. Chem. Phys. 127, 124108 (2007) To use this correction with the PBE functional, you need to set: SEDC_APPLY = TRUE SEDC_SCHEME = XDM SEDC_SC_XDM = 1.0 where the SEDC_SC_XDM parameter is a global scaling factor. For other functionals you need to specify the following additional parameters: Customisation keywords for XDM .param file SEDC_A1_XDM Type: Real (float) Level: Expert Description: Customisable A1 value for the damping function in the XDM semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_A2_XDM Type: Physical (float) Level: Expert Description: Customisable A2 value for the damping function in the XDM semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_SC_XDM Type: Real (float) Level: Expert Description: Customisable SC value for the damping function in the XDM semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_C9_XDM Type: Logical Level: Basic Description: Specifies whether three-body dispersion coefficients are to be computed in the XDM semi-empirical dispersion/ van der Waals correction scheme. Modifiable: restart and on the fly Allowed values: TRUE or FALSE Default is FALSE Note that the specific parameters found here: http://schooner.chem.dal.ca/wiki/XDM are might not be directly transferable to CASTEP and careful further testing is necessary.","title":"Exchange-dipole moment (XDM) method "},{"location":"documentation/Groundstate/dftd/#other-schemes","text":"SEDC_SCHEME : OBS # (Ortmann, Bechstedt and Schmidt) Semiempirical van der Waals correction to the density functional description of solids and molecular structures Phys. Rev. B 73, 205101, (2006) Customisation keywords \" SEDC_LAMBDA_OBS \" Type: Real (float) Level: Expert Description: Customisable lambda value for damping function in the the OBS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . \" SEDC_N_OBS \" Type: Real (float) Level: Expert Description: Customisable n value for the damping function in the OBS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_SCHEME : JCHS # (Jure\u010dka, \u010cern\u00fd, Hobza and Salahub) J. Comput. Chem. 28, 555, (2007) Customisation keywords SEDC_SR_JCHS Type: Real (float) Level: Expert Description: Customisable SR value for the damping function in the JCHS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_S6_JCHS Type: Real (float) Level: Expert Description: Customisable S6 value for the damping function in the JCHS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL . SEDC_D_JCHS Type: Real (float) Level: Expert Description: Customisable d value for the damping function in the JCHS semi-empirical dispersion/van der Waals correction scheme. Modifiable: restart and on the fly Default is determined by XC_FUNCTIONAL .","title":"Other Schemes"},{"location":"documentation/Groundstate/intro/","text":"One of the most fundamental tasks for CASTEP is to take a crystal lattice and set of atomic positions, and compute the electronic density and total energy. Once the lattice and atomic positions have been specified, you can tell CASTEP to compute the energy by setting the task keyword in the param file : task : energy Your cell and param files should be named using the same prefix, which CASTEP calls the \"seedname\", and the extensions .cell and .param , respectively. For example, for a calculation called mytest , you need the input files mytest.cell mytest.param and the calculation is run with the command castep mytest CASTEP computes the energy by solving the Kohn-Sham equations iteratively, using the 'self-consistent field' (SCF) method.","title":"Overview"},{"location":"documentation/Groundstate/nlxc/","text":"","title":"Nlxc"},{"location":"documentation/Groundstate/soc/","text":"keywords For a calculation of a non-spin polarised system with spin orbit coupling (e.g. GaAs) the following keywords should be set in the param file spin_treatment : vector spin_orbit_coupling : true spin_polarised : false relativistic_treatment : dirac If the system has a spin density (e.g. a ferromagnet or antiferromagnet) then the following keywords should be set in the para file spin_treatment : vector spin_orbit_coupling : true spin_polarised : true relativistic_treatment : dirac As the spin-orbit coupling is transmitted via the pseudopotential is is necessary to use j-dependent pseudopotentials. These can be read from file (UPF or uspso) or generated on the fly. At the moment the SOC19 set of OTFG norm-conserving potentials are suitable. These can be specified with the following block in the cell file ``` %block species_pot SOC19 %endblock species_pot Limitations","title":"Spin Orbit Coupling"},{"location":"documentation/Groundstate/soc/#keywords","text":"For a calculation of a non-spin polarised system with spin orbit coupling (e.g. GaAs) the following keywords should be set in the param file spin_treatment : vector spin_orbit_coupling : true spin_polarised : false relativistic_treatment : dirac If the system has a spin density (e.g. a ferromagnet or antiferromagnet) then the following keywords should be set in the para file spin_treatment : vector spin_orbit_coupling : true spin_polarised : true relativistic_treatment : dirac As the spin-orbit coupling is transmitted via the pseudopotential is is necessary to use j-dependent pseudopotentials. These can be read from file (UPF or uspso) or generated on the fly. At the moment the SOC19 set of OTFG norm-conserving potentials are suitable. These can be specified with the following block in the cell file ``` %block species_pot SOC19 %endblock species_pot","title":"keywords"},{"location":"documentation/Groundstate/soc/#limitations","text":"","title":"Limitations"},{"location":"documentation/Groundstate/xc/","text":"","title":"Xc"},{"location":"documentation/Input_Files/cell_file/","text":"This is a detailed description of options for CASTEP's cell file. See the basic cell file page for an overview. This page has the most frequently-used cell file options, but for a full set use CASTEP's built-in help . There is also a concise table of cell keywords . The cell file is one of CASTEP's two main input files. It contains all of the information about the crystal lattice and the atomic positions, as well as additional information such as Brillouin zone sampling ('k-points'), pseudopotentials, cell symmetry, external pressure, constraints on motion of the atoms or cell, and atomic properties such as the mass of each species. The file itself is a free-format keyword-driven text file, consisting of keywords and blocks of information. These may be given in any order, with blocks indicated by the special %block and %endblock markers. Most of the keywords and blocks are optional, but CASTEP requires two block entries: a block to specify the lattice, and another to specify the atomic elements and positions within the cell. At the very least, the cell lattice vectors and ionic positions must be specified. Reasonable defaults are chosen for anything else not specified. For the purposes of the following definitions, all variables represented by R R are defined to be real numbers, those represented by I I are defined to be integers and those represented by C C are characters. Cell Lattice Vectors The cell lattice vectors may be specified in Cartesian coordinates or in terms of the lattice vector magnitudes and the angles between them ( a, b, c, \\alpha, \\beta, \\gamma a, b, c, \\alpha, \\beta, \\gamma ). Only one of LATTICE_CART and LATTICE_ABC may occur in a cell definition file. The definitions of these keywords are as follows: %BLOCK LATTICE_CART [units] a_x a_y a_z b_x b_y b_z c_x c_y c_z %ENDBLOCK LATTICE_CART Here a_x is the x-component of the first lattice vector, \\mathbf{a} \\mathbf{a} , b_y b_y is the y-component of the second lattice vector, \\mathbf{b} \\mathbf{b} , etc. [units] specifies the units in which the lattice vectors are defined. If not present, the default is \u00c5. %BLOCK LATTICE_ABC [units] a b c alpha beta gamma %ENDBLOCK LATTICE_ABC Here a is the value of the lattice constant \\vert\\mathbf{a}\\vert \\vert\\mathbf{a}\\vert , gamma is the value of the cell angle \\gamma \\gamma (in degrees) etc. If the lattice is specified in this manner, the absolute orientation is arbitrary. In this case the orientation is defined by applying the following constraints: \\mathbf{a} \\mathbf{a} lies along the x-axis \\mathbf{b} \\mathbf{b} lies in the xy plane \\mathbf{c} \\mathbf{c} forms a right-handed set with \\mathbf{a} \\mathbf{a} and \\mathbf{b} \\mathbf{b} [units] specifies the units in which the lattice vector magnitudes are defined. If not present, the default is \u00c5. Angles should be specified in degrees. Ionic Positions The ionic positions may be specified in fractional coordinates relative to the lattice vectors of the unit cell, or in absolute coordinates. Only one of POSITIONS_FRAC and POSITIONS_ABS may occur in a cell definition file. %BLOCK POSITIONS_FRAC CCC_1 R_{1i} R_{1j} R_{1k} [SPIN=s_1] CCC_2 R_{2i} R_{2j} R_{2k} [SPIN=s_2] ... %ENDBLOCK END POSITIONS_FRAC The first entry on a line is the symbol of the species (chemical element). Alternatively, the atomic number may be given instead, in which case CASTEP will be look up for chemical symbol. A symbol can have a maximum of three characters. The first alphabetical characters identify the element, from which default values for atomic mass etc. The next three entries on a line in POSITIONS_FRAC are real numbers representing the position of the ion in fractions of the unit cell lattice vectors. If the optional flag SPIN is present on a line, this sets the spin polarisation ( N^\\uparrow-N^\\downarrow N^\\uparrow-N^\\downarrow ) of the atom for initialisation of the spin density; for non-collinear spin calculations, the vector spin is specified as three numbers. If this flag is not present a non-spin polarised state will be assumed. %BLOCK POSITIONS_ABS [units] CCC_1 R_{1i} R_{1j} R_{1k} [SPIN=s_1] CCC_2 R_{2i} R_{2j} R_{2k} [SPIN=s_2] ... %ENDBLOCK POSITIONS_ABS The first entry on a line is the symbol or atomic number of the ionic species, as for POSITIONS_FRAC . The next three entries are real numbers representing the position of the ion in Cartesian coordinates. [units] specifies the units in which the positions are defined. If not present, the default is \u00c5. The optional flag SPIN is defined above under POSITIONS_FRAC . Brillouin Zone Sampling (k-points) (N.B. in the following section the keywords with the prefixes KPOINT_ and KPOINTS_ are synonymous. KPOINT_ is the preferred usage.) The k-points at which the Brillouin zone is to be sampled during a self consistent calculation to find the electronic ground state may be defined either by specifying a list of k-points or a Monkhorst-Pack grid in terms of the dimensions of the k-point mesh or a minimum k-point density. The origin of the Monkhorst-Pack grid may be offset by a vector from the origin of the Brillouin zone. If no k-points are specified, the default will be a Monkhorst-Pack grid with a maximum spacing of 0.1\u00c5 ^{-1} ^{-1} and no offset of the origin. The KPOINT_LIST , KPOINT_MP_GRID and KPOINT_MP_SPACING keywords are mutually exclusive. KPOINT_MP_OFFSET may be specified in combination with either KPOINT_MP_GRID or KPOINT_MP_SPACING . %BLOCK KPOINT_LIST \\begin{array}{cccc} R_{1i} R_{1j} R_{1k} R_{1w} R_{2i} R_{2j} R_{2k} R_{2w} ... %ENDBLOCK KPOINT_LIST The first three entries on a line are the fractional positions of the k-point relative to the reciprocal space lattice vectors. The final entry on a line is the weight of the k-point relative to the others specified. The sum of the weights must be equal to 1. KPOINT_MP_GRID I_i I_j I_k This specifies the dimensions of the Monkhorst-Pack grid requested in the directions of the reciprocal space lattice vectors. The generated grid will be I_i\\times I_j\\times I_k I_i\\times I_j\\times I_k ; any symmetries generated (or supplied) will be used to reduce this number, when computing the irreducible wedge. KPOINT_MP_SPACING R [units] The single entry is the maximum distance between k-points on the Monkhorst-Pack grid. The dimensions of the grid will be chosen such that the maximum separation of k-points is less than this. [units] specifies the units in which the k-point spacing is defined, although note that the actual units used are 2\\pi 2\\pi units . If not present, the default is ang-1 , such that the spacing is in 2\\pi \u00c5^{-1} 2\\pi \u00c5^{-1} . KPOINT_MP_OFFSET R_i R_j R_k This specifies the offset of the Monkhorst-Pack grid with respect to the origin of the Brillouin zone. The three entries are the offset in fractional coordinates relative to the reciprocal lattice vectors. The k-point set for performing spectral calculations can be specified in the same manner, using version of the keywords above with SPECTRAL_ prepended. The same restrictions regarding mutually exclusive keywords apply. For a non-self-consistent spectral calculation, the k-points may be defined along a path through reciprocal space or a list of k-points. %BLOCK SPECTRAL_KPOINT_PATH R_{1i} R_{1j} R_{1k} R_{2i} R_{2j} R_{2k} ... %ENDBLOCK SPECTRAL_KPOINT_PATH The three numbers on each line are the fractional positions of the k-point relative to the reciprocal space lattice vectors. The k-points define a continuous sequence of straight line segments, unless the keyword BREAK appears on a separate line within the sequence of k-points. In this case the continuous path will end at the k-point immediately preceding the BREAK keyword and resume at the k-point immediately following. The path will be open unless the first and last point in the list are identical . The maximum spacing of the points sampled along each line segment is defined by the keyword SPECTRAL_KPOINT_PATH_SPACING (default value 0.1 \\times 2\\pi 0.1 \\times 2\\pi \u00c5 ^{-1} ^{-1} ). If necessary, the actual spacing used may be smaller than this in order to ensure that the length of the line segment is an integer multiple of the spacing between points on that segment. Alternatively, the k-point set for performing a band structure calculation can be specified in the same manner as the main k-point set, using version of the keywords above with BS_ prepended. The same restrictions regarding mutually exclusive keywords apply. In this case, the k-point weight in SPECTRAL_KPOINT_LIST is optional. If omitted, the weights for each k-point are assumed to be equal. For a phonon spectrum calculation, the k-points may be defined along a path through reciprocal space or a list of k-points, in the same manner as for a spectral calculation. The corresponding keywords are identical to those for the band structure specification with the initial SPECTRAL_ replaced by PHONON_ , e.g. PHONON_KPOINT_PATH , PHONON_KPOINT_PATH_SPACING and PHONON_KPOINT_LIST . The same restrictions regarding mutually exclusive keywords apply. The block keyword PHONON_GAMMA_DIRECTIONS specifies the directions in which the gamma point will be approached when calculating the non-analytic terms of the LO/TO splitting. Each line in this block will consist of a 3-vector specifying a direction in the basis of reciprocal lattice vectors. If this keyword is not present, the default will be a single vector determined as follows: If the gamma point is q_i = 0 q_i = 0 and there is a successor kpoint q_{i+1} q_{i+1} in the list, then it is q_{i+1} q_{i+1} . Otherwise if the gamma point is q_i =0 q_i =0 and there is a predecessor kpoint q_{i-1} q_{i-1} in the list then it is q_{i-1} q_{i-1} . Otherwise (i.e. a Gamma point only calculation) the a-axis of the reciprocal cell. For backwards compatibility the keywords beginning BS_ and OPTICS_ are synonyms for SPECTRAL_KPOINT_ and similarly those beginning. Cell Symmetry If no symmetry is specified in the cell definition file, the default is for no symmetry to be applied. SYMMETRY_GENERATE If this keyword is present in the cell, the highest symmetry group that applies to the structure of the cell will be found and the corresponding symmetry operations generated. SYMMETRY_TOL R [units] This parameter is the tolerance within which symmetry will be considered to be satisfied. If an ion is found within this distance of its symmetric position, the symmetry will be considered to be satisfied. [units] specifies the units in which the tolerance is defined. If not present, the default is \u00c5. Alternatively, the symmetry operations may be provided directly in a SYMMETRY_OPS block. The symmetry of the cell is represented as a series of symmetry operations under which the unit cell is invariant. Each operation is represented as a 3\\times 3 3\\times 3 array. %BLOCK SYMMETRY_OPS R_{11} R_{21} R_{31} R_{12} R_{22} R_{32} R_{13} R_{23} R_{33} T_1 T_2 T_3 R_{11} R_{21} R_{31} R_{12} R_{22} R_{32} R_{13} R_{23} R_{33} T_1 T_2 T_3 ... %ENDBLOCK SYMMETRY_OPS Each of the first three lines contains 3 entries representing a row of a 3\\times3 3\\times3 array. These represent one symmetry rotation. The three entries on the following line contain the translation associated with this rotation. Constraints The movement of ions or the unit cell during a relaxation or molecular dynamics run may be constrained. The constraints on the ionic motion may by specified as a set of linear constraints. Each constraint is specified as a series of coefficients a_{ijk} a_{ijk} such that: $$ \\sum_{k=1}^{\\tt N_\\mathrm{species}} \\quad \\sum_{j=1}^{\\mathrm{N_\\mathrm{ions}}(k)} \\quad \\sum_{i=1}^{3} a_{ijk} \\verb#ionic_positions(i,j,k)# = constant $$ where \\mathrm{N_\\mathrm{ions}}(k) \\mathrm{N_\\mathrm{ions}}(k) is the number of ions in species k k . The change in the shape of the unit cell may also be constrained using the keyword CELL_CONSTRAINTS . The special case of constraining the centre of mass of the ions to remain fixed is supported by a logical keyword FIX_COM . Also all ionic positions or cell parameters may be fixed by specifying the keywords FIX_ALL_IONS or FIX_ALL_CELL to be TRUE respectively. If no ionic or cell constraints are specified in the cell definition file, the default is to fix the centre of mass. %BLOCK IONIC_CONSTRAINTS I_1 CCC_{1s} I_{1s} I_{n1} R_{1i} R_{1j} R_{1k} I_2 CCC_{2s} I_{2s} I_{n2} R_{2i} R_{2j} R_{2k} ... %ENDBLOCK IONIC_CONSTRAINTS The first element on each line is an integer specifying the number of the constraint being specified. The second entry is either the symbol or atomic number of the species of the ion to which this constraint applies. The third element is the number of the ion within the species. The ordering of the ions in a species is the order in which they appear in the POSITIONS_FRAC or POSITIONS_ABS block in the cell definition file. The final three numbers are real numbers representing the coefficients of the Cartesian coordinates of the ionic position in the constraint sum. All coefficients in the sum not explicitly specified will be zero. On reading this data, the matrix of ionic constraints will be orthogonalised. %BLOCK CELL_CONSTRAINTS I_a I_b I_c I_alpha I_beta I_gamma %ENDBLOCK CELL_CONSTRAINTS The first three entries relate to the magnitude of the three lattice vectors a,b,c a,b,c and the second set of three entries to the angles \\alpha, \\beta, \\gamma \\alpha, \\beta, \\gamma . If the value of the entry corresponding to a magnitude or angle is zero, this quantity will remain fixed. If two or three entries contain the same integer, the corresponding quantities will be constrained to have the same value. If a positive integer greater than 0 occurs in entries 1 through 3 the same integer cannot occur in entries 4 through 6 as this would imply that a vector length and angle must have the same value. Species Characteristics The mass of a species, the pseudopotential which represents the ion and the size of the LCAO basis set used for population anslsyis may be specified in the cell definition file. %BLOCK SPECIES_MASS [units] CCC_1 I_1 R_1 CCC_2 I_2 R_2 ... %ENDBLOCK SPECIES_MASS [units] specifies the units in which the masses are defined. If not present, the default is atomic mass units. The first entry on a line is the symbol or atomic number of the species. This must correspond with the species symbol or atomic number of the species in the POSITIONS_FRAC or POSITIONS_ABS block. The second entry on each line is the mass of that species. Not all species need appear in the SPECIES_MASS block, any not present will assume the default mass for that species. If the initial alphabetical symbol specified for a species is not a standard element symbol in the periodic table, the mass of the species must be specified. %BLOCK SPECIES_POT CCC_1 I_1 <filename> CCC_2 I_2 <filename> ... %ENDBLOCK SPECIES_POT The first entry on a line is the symbol or atomic number of the species. This must correspond with the species symbol or atomic number of the species in the POSITIONS_FRAC or POSITIONS_ABS block. The second entry on each line is the filename of the file containing the definition of the pseudopotential representing the ionic species. The file to which this refers may be a definition of the parameters of the pseudopotential which is to be generated at runtime, or an old-style pseudopotential definition containing the data for the pseudopotential. Not all species need appear in the SPECIES_POT block. If a pseudopotential is not specified, the default pseudopotential parameters will be used to generate a pseudopotential for the element specified. If the initial alphabetical characters of a species label is not a standard element symbol in the periodic table, the potential for the species must be specified. The charge on the ion for each species will be derived from the pseudopotential corresponding to that ion. %BLOCK SPECIES_LCAO_STATES CCC_1 I_1 I_{B1} CCC_2 I_2 I_{B2} ... %ENDBLOCK SPECIES_LCAO_STATES The first entry on a line is the symbol or atomic number of the species. This must correspond with the species symbol or atomic number of the species in the POSITIONS_FRAC or POSITIONS_ABS block. The second number is the number of angular momentum channels to use in the LCAO basis set for the species when performing population analysis. For example, to use the 2s and 2p states for C (The 1s state is a core state) this should be 2. By default, the number of states will be the appropriate number to complete the valence shell to the next noble gas. If shallow core states are excluded from a pseudopotential, the value of SPECIES_LCAO_STATES for that species should be included in the cell file to ensure a meaningful basis set is used. External Pressure An external pressure may be applied to the unit cell by specifying a pressure tensor. %BLOCK EXTERNAL_PRESSURE [units] R_{xx} R_{xy} R_{xz} R_{yy} R_{yz} R_{zz} %ENDBLOCK EXTERNAL_PRESSURE [units] specifies the units in which the pressure is defined. If not present, the default is GPa. Entry R_{xx} R_{xx} is the xx xx -component of the pressure, R_{xy} R_{xy} the xy xy -component etc. The default is to apply no external pressure. Ionic Velocities The initial ionic velocities may be specified in Cartesian coordinates in a cell definition file. %BLOCK IONIC_VELOCITIES [units] CCC_1 V_{1x} V_{1y} V_{1z} CCC_2 V_{2x} V_{2y} V_{2z} ... %ENDBLOCK IONIC_VELOCITIES The first entry on a line is the chemical symbol (or atomic number) of the ionic species. The correct symbol will be looked up for the atomic species if the atomic number is specified. A symbol can have a maximum of three characters. The next three entries are real numbers representing the velocity of the ion in Cartesian coordinates. [units] specifies the units in which the positions are defined. If not present, the default is \u00c5/ps. If this keyword is not present and a molecular dynamics calculation is performed, the ionic velocities will be randomly initialised with the appropriate temperature.","title":"cell file"},{"location":"documentation/Input_Files/cell_file/#cell-lattice-vectors","text":"The cell lattice vectors may be specified in Cartesian coordinates or in terms of the lattice vector magnitudes and the angles between them ( a, b, c, \\alpha, \\beta, \\gamma a, b, c, \\alpha, \\beta, \\gamma ). Only one of LATTICE_CART and LATTICE_ABC may occur in a cell definition file. The definitions of these keywords are as follows: %BLOCK LATTICE_CART [units] a_x a_y a_z b_x b_y b_z c_x c_y c_z %ENDBLOCK LATTICE_CART Here a_x is the x-component of the first lattice vector, \\mathbf{a} \\mathbf{a} , b_y b_y is the y-component of the second lattice vector, \\mathbf{b} \\mathbf{b} , etc. [units] specifies the units in which the lattice vectors are defined. If not present, the default is \u00c5. %BLOCK LATTICE_ABC [units] a b c alpha beta gamma %ENDBLOCK LATTICE_ABC Here a is the value of the lattice constant \\vert\\mathbf{a}\\vert \\vert\\mathbf{a}\\vert , gamma is the value of the cell angle \\gamma \\gamma (in degrees) etc. If the lattice is specified in this manner, the absolute orientation is arbitrary. In this case the orientation is defined by applying the following constraints: \\mathbf{a} \\mathbf{a} lies along the x-axis \\mathbf{b} \\mathbf{b} lies in the xy plane \\mathbf{c} \\mathbf{c} forms a right-handed set with \\mathbf{a} \\mathbf{a} and \\mathbf{b} \\mathbf{b} [units] specifies the units in which the lattice vector magnitudes are defined. If not present, the default is \u00c5. Angles should be specified in degrees.","title":"Cell Lattice Vectors"},{"location":"documentation/Input_Files/cell_file/#ionic-positions","text":"The ionic positions may be specified in fractional coordinates relative to the lattice vectors of the unit cell, or in absolute coordinates. Only one of POSITIONS_FRAC and POSITIONS_ABS may occur in a cell definition file. %BLOCK POSITIONS_FRAC CCC_1 R_{1i} R_{1j} R_{1k} [SPIN=s_1] CCC_2 R_{2i} R_{2j} R_{2k} [SPIN=s_2] ... %ENDBLOCK END POSITIONS_FRAC The first entry on a line is the symbol of the species (chemical element). Alternatively, the atomic number may be given instead, in which case CASTEP will be look up for chemical symbol. A symbol can have a maximum of three characters. The first alphabetical characters identify the element, from which default values for atomic mass etc. The next three entries on a line in POSITIONS_FRAC are real numbers representing the position of the ion in fractions of the unit cell lattice vectors. If the optional flag SPIN is present on a line, this sets the spin polarisation ( N^\\uparrow-N^\\downarrow N^\\uparrow-N^\\downarrow ) of the atom for initialisation of the spin density; for non-collinear spin calculations, the vector spin is specified as three numbers. If this flag is not present a non-spin polarised state will be assumed. %BLOCK POSITIONS_ABS [units] CCC_1 R_{1i} R_{1j} R_{1k} [SPIN=s_1] CCC_2 R_{2i} R_{2j} R_{2k} [SPIN=s_2] ... %ENDBLOCK POSITIONS_ABS The first entry on a line is the symbol or atomic number of the ionic species, as for POSITIONS_FRAC . The next three entries are real numbers representing the position of the ion in Cartesian coordinates. [units] specifies the units in which the positions are defined. If not present, the default is \u00c5. The optional flag SPIN is defined above under POSITIONS_FRAC .","title":"Ionic Positions"},{"location":"documentation/Input_Files/cell_file/#brillouin-zone-sampling-k-points","text":"(N.B. in the following section the keywords with the prefixes KPOINT_ and KPOINTS_ are synonymous. KPOINT_ is the preferred usage.) The k-points at which the Brillouin zone is to be sampled during a self consistent calculation to find the electronic ground state may be defined either by specifying a list of k-points or a Monkhorst-Pack grid in terms of the dimensions of the k-point mesh or a minimum k-point density. The origin of the Monkhorst-Pack grid may be offset by a vector from the origin of the Brillouin zone. If no k-points are specified, the default will be a Monkhorst-Pack grid with a maximum spacing of 0.1\u00c5 ^{-1} ^{-1} and no offset of the origin. The KPOINT_LIST , KPOINT_MP_GRID and KPOINT_MP_SPACING keywords are mutually exclusive. KPOINT_MP_OFFSET may be specified in combination with either KPOINT_MP_GRID or KPOINT_MP_SPACING . %BLOCK KPOINT_LIST \\begin{array}{cccc} R_{1i} R_{1j} R_{1k} R_{1w} R_{2i} R_{2j} R_{2k} R_{2w} ... %ENDBLOCK KPOINT_LIST The first three entries on a line are the fractional positions of the k-point relative to the reciprocal space lattice vectors. The final entry on a line is the weight of the k-point relative to the others specified. The sum of the weights must be equal to 1. KPOINT_MP_GRID I_i I_j I_k This specifies the dimensions of the Monkhorst-Pack grid requested in the directions of the reciprocal space lattice vectors. The generated grid will be I_i\\times I_j\\times I_k I_i\\times I_j\\times I_k ; any symmetries generated (or supplied) will be used to reduce this number, when computing the irreducible wedge. KPOINT_MP_SPACING R [units] The single entry is the maximum distance between k-points on the Monkhorst-Pack grid. The dimensions of the grid will be chosen such that the maximum separation of k-points is less than this. [units] specifies the units in which the k-point spacing is defined, although note that the actual units used are 2\\pi 2\\pi units . If not present, the default is ang-1 , such that the spacing is in 2\\pi \u00c5^{-1} 2\\pi \u00c5^{-1} . KPOINT_MP_OFFSET R_i R_j R_k This specifies the offset of the Monkhorst-Pack grid with respect to the origin of the Brillouin zone. The three entries are the offset in fractional coordinates relative to the reciprocal lattice vectors. The k-point set for performing spectral calculations can be specified in the same manner, using version of the keywords above with SPECTRAL_ prepended. The same restrictions regarding mutually exclusive keywords apply. For a non-self-consistent spectral calculation, the k-points may be defined along a path through reciprocal space or a list of k-points. %BLOCK SPECTRAL_KPOINT_PATH R_{1i} R_{1j} R_{1k} R_{2i} R_{2j} R_{2k} ... %ENDBLOCK SPECTRAL_KPOINT_PATH The three numbers on each line are the fractional positions of the k-point relative to the reciprocal space lattice vectors. The k-points define a continuous sequence of straight line segments, unless the keyword BREAK appears on a separate line within the sequence of k-points. In this case the continuous path will end at the k-point immediately preceding the BREAK keyword and resume at the k-point immediately following. The path will be open unless the first and last point in the list are identical . The maximum spacing of the points sampled along each line segment is defined by the keyword SPECTRAL_KPOINT_PATH_SPACING (default value 0.1 \\times 2\\pi 0.1 \\times 2\\pi \u00c5 ^{-1} ^{-1} ). If necessary, the actual spacing used may be smaller than this in order to ensure that the length of the line segment is an integer multiple of the spacing between points on that segment. Alternatively, the k-point set for performing a band structure calculation can be specified in the same manner as the main k-point set, using version of the keywords above with BS_ prepended. The same restrictions regarding mutually exclusive keywords apply. In this case, the k-point weight in SPECTRAL_KPOINT_LIST is optional. If omitted, the weights for each k-point are assumed to be equal. For a phonon spectrum calculation, the k-points may be defined along a path through reciprocal space or a list of k-points, in the same manner as for a spectral calculation. The corresponding keywords are identical to those for the band structure specification with the initial SPECTRAL_ replaced by PHONON_ , e.g. PHONON_KPOINT_PATH , PHONON_KPOINT_PATH_SPACING and PHONON_KPOINT_LIST . The same restrictions regarding mutually exclusive keywords apply. The block keyword PHONON_GAMMA_DIRECTIONS specifies the directions in which the gamma point will be approached when calculating the non-analytic terms of the LO/TO splitting. Each line in this block will consist of a 3-vector specifying a direction in the basis of reciprocal lattice vectors. If this keyword is not present, the default will be a single vector determined as follows: If the gamma point is q_i = 0 q_i = 0 and there is a successor kpoint q_{i+1} q_{i+1} in the list, then it is q_{i+1} q_{i+1} . Otherwise if the gamma point is q_i =0 q_i =0 and there is a predecessor kpoint q_{i-1} q_{i-1} in the list then it is q_{i-1} q_{i-1} . Otherwise (i.e. a Gamma point only calculation) the a-axis of the reciprocal cell. For backwards compatibility the keywords beginning BS_ and OPTICS_ are synonyms for SPECTRAL_KPOINT_ and similarly those beginning.","title":"Brillouin Zone Sampling (k-points)"},{"location":"documentation/Input_Files/cell_file/#cell-symmetry","text":"If no symmetry is specified in the cell definition file, the default is for no symmetry to be applied. SYMMETRY_GENERATE If this keyword is present in the cell, the highest symmetry group that applies to the structure of the cell will be found and the corresponding symmetry operations generated. SYMMETRY_TOL R [units] This parameter is the tolerance within which symmetry will be considered to be satisfied. If an ion is found within this distance of its symmetric position, the symmetry will be considered to be satisfied. [units] specifies the units in which the tolerance is defined. If not present, the default is \u00c5. Alternatively, the symmetry operations may be provided directly in a SYMMETRY_OPS block. The symmetry of the cell is represented as a series of symmetry operations under which the unit cell is invariant. Each operation is represented as a 3\\times 3 3\\times 3 array. %BLOCK SYMMETRY_OPS R_{11} R_{21} R_{31} R_{12} R_{22} R_{32} R_{13} R_{23} R_{33} T_1 T_2 T_3 R_{11} R_{21} R_{31} R_{12} R_{22} R_{32} R_{13} R_{23} R_{33} T_1 T_2 T_3 ... %ENDBLOCK SYMMETRY_OPS Each of the first three lines contains 3 entries representing a row of a 3\\times3 3\\times3 array. These represent one symmetry rotation. The three entries on the following line contain the translation associated with this rotation.","title":"Cell Symmetry"},{"location":"documentation/Input_Files/cell_file/#constraints","text":"The movement of ions or the unit cell during a relaxation or molecular dynamics run may be constrained. The constraints on the ionic motion may by specified as a set of linear constraints. Each constraint is specified as a series of coefficients a_{ijk} a_{ijk} such that: $$ \\sum_{k=1}^{\\tt N_\\mathrm{species}} \\quad \\sum_{j=1}^{\\mathrm{N_\\mathrm{ions}}(k)} \\quad \\sum_{i=1}^{3} a_{ijk} \\verb#ionic_positions(i,j,k)# = constant $$ where \\mathrm{N_\\mathrm{ions}}(k) \\mathrm{N_\\mathrm{ions}}(k) is the number of ions in species k k . The change in the shape of the unit cell may also be constrained using the keyword CELL_CONSTRAINTS . The special case of constraining the centre of mass of the ions to remain fixed is supported by a logical keyword FIX_COM . Also all ionic positions or cell parameters may be fixed by specifying the keywords FIX_ALL_IONS or FIX_ALL_CELL to be TRUE respectively. If no ionic or cell constraints are specified in the cell definition file, the default is to fix the centre of mass. %BLOCK IONIC_CONSTRAINTS I_1 CCC_{1s} I_{1s} I_{n1} R_{1i} R_{1j} R_{1k} I_2 CCC_{2s} I_{2s} I_{n2} R_{2i} R_{2j} R_{2k} ... %ENDBLOCK IONIC_CONSTRAINTS The first element on each line is an integer specifying the number of the constraint being specified. The second entry is either the symbol or atomic number of the species of the ion to which this constraint applies. The third element is the number of the ion within the species. The ordering of the ions in a species is the order in which they appear in the POSITIONS_FRAC or POSITIONS_ABS block in the cell definition file. The final three numbers are real numbers representing the coefficients of the Cartesian coordinates of the ionic position in the constraint sum. All coefficients in the sum not explicitly specified will be zero. On reading this data, the matrix of ionic constraints will be orthogonalised. %BLOCK CELL_CONSTRAINTS I_a I_b I_c I_alpha I_beta I_gamma %ENDBLOCK CELL_CONSTRAINTS The first three entries relate to the magnitude of the three lattice vectors a,b,c a,b,c and the second set of three entries to the angles \\alpha, \\beta, \\gamma \\alpha, \\beta, \\gamma . If the value of the entry corresponding to a magnitude or angle is zero, this quantity will remain fixed. If two or three entries contain the same integer, the corresponding quantities will be constrained to have the same value. If a positive integer greater than 0 occurs in entries 1 through 3 the same integer cannot occur in entries 4 through 6 as this would imply that a vector length and angle must have the same value.","title":"Constraints"},{"location":"documentation/Input_Files/cell_file/#species-characteristics","text":"The mass of a species, the pseudopotential which represents the ion and the size of the LCAO basis set used for population anslsyis may be specified in the cell definition file. %BLOCK SPECIES_MASS [units] CCC_1 I_1 R_1 CCC_2 I_2 R_2 ... %ENDBLOCK SPECIES_MASS [units] specifies the units in which the masses are defined. If not present, the default is atomic mass units. The first entry on a line is the symbol or atomic number of the species. This must correspond with the species symbol or atomic number of the species in the POSITIONS_FRAC or POSITIONS_ABS block. The second entry on each line is the mass of that species. Not all species need appear in the SPECIES_MASS block, any not present will assume the default mass for that species. If the initial alphabetical symbol specified for a species is not a standard element symbol in the periodic table, the mass of the species must be specified. %BLOCK SPECIES_POT CCC_1 I_1 <filename> CCC_2 I_2 <filename> ... %ENDBLOCK SPECIES_POT The first entry on a line is the symbol or atomic number of the species. This must correspond with the species symbol or atomic number of the species in the POSITIONS_FRAC or POSITIONS_ABS block. The second entry on each line is the filename of the file containing the definition of the pseudopotential representing the ionic species. The file to which this refers may be a definition of the parameters of the pseudopotential which is to be generated at runtime, or an old-style pseudopotential definition containing the data for the pseudopotential. Not all species need appear in the SPECIES_POT block. If a pseudopotential is not specified, the default pseudopotential parameters will be used to generate a pseudopotential for the element specified. If the initial alphabetical characters of a species label is not a standard element symbol in the periodic table, the potential for the species must be specified. The charge on the ion for each species will be derived from the pseudopotential corresponding to that ion. %BLOCK SPECIES_LCAO_STATES CCC_1 I_1 I_{B1} CCC_2 I_2 I_{B2} ... %ENDBLOCK SPECIES_LCAO_STATES The first entry on a line is the symbol or atomic number of the species. This must correspond with the species symbol or atomic number of the species in the POSITIONS_FRAC or POSITIONS_ABS block. The second number is the number of angular momentum channels to use in the LCAO basis set for the species when performing population analysis. For example, to use the 2s and 2p states for C (The 1s state is a core state) this should be 2. By default, the number of states will be the appropriate number to complete the valence shell to the next noble gas. If shallow core states are excluded from a pseudopotential, the value of SPECIES_LCAO_STATES for that species should be included in the cell file to ensure a meaningful basis set is used.","title":"Species Characteristics"},{"location":"documentation/Input_Files/cell_file/#external-pressure","text":"An external pressure may be applied to the unit cell by specifying a pressure tensor. %BLOCK EXTERNAL_PRESSURE [units] R_{xx} R_{xy} R_{xz} R_{yy} R_{yz} R_{zz} %ENDBLOCK EXTERNAL_PRESSURE [units] specifies the units in which the pressure is defined. If not present, the default is GPa. Entry R_{xx} R_{xx} is the xx xx -component of the pressure, R_{xy} R_{xy} the xy xy -component etc. The default is to apply no external pressure.","title":"External Pressure"},{"location":"documentation/Input_Files/cell_file/#ionic-velocities","text":"The initial ionic velocities may be specified in Cartesian coordinates in a cell definition file. %BLOCK IONIC_VELOCITIES [units] CCC_1 V_{1x} V_{1y} V_{1z} CCC_2 V_{2x} V_{2y} V_{2z} ... %ENDBLOCK IONIC_VELOCITIES The first entry on a line is the chemical symbol (or atomic number) of the ionic species. The correct symbol will be looked up for the atomic species if the atomic number is specified. A symbol can have a maximum of three characters. The next three entries are real numbers representing the velocity of the ion in Cartesian coordinates. [units] specifies the units in which the positions are defined. If not present, the default is \u00c5/ps. If this keyword is not present and a molecular dynamics calculation is performed, the ionic velocities will be randomly initialised with the appropriate temperature.","title":"Ionic Velocities"},{"location":"documentation/Input_Files/cell_keywords/","text":"This is a concise list of the common keywords for CASTEP's cell input file. The definitions of the keywords are given in more detail in the section on the cell file . Keyword in the cell file Type Default Description LATTICE_CART ^1 ^1 B -- The cell lattice vectors in Cartesian coordinates. LATTICE_ABC ^1 ^1 B -- The cell lattice vectors specified in $ a, b, c, \\alpha, \\beta, \\gamma $ format. POSITIONS_FRAC ^2 ^2 B -- The positions of the ions in fraction coordinates with respect to the lattice vectors. POSITIONS_ABS ^2 ^2 B -- The positions of the ions in absolute coordinates. KPOINT_LIST ^3 ^3 B -- A list of k-points in the Brillouin zone with associated weights. KPOINT_MP_GRID ^3 ^3 W -- The k-points defined as a Monkhorst-Pack grid by specifying the grid dimensions in each direction. KPOINT_MP_SPACING ^3 ^3 P 0.1 \u00c5^{-1} \u00c5^{-1} The k-points as a Monkhorst-Pack grid by specifying the maximum distance between k-points. KPOINT_MP_OFFSET V 0,0,0 The offset of the origin of the Monkhorst-Pack grid in fractional coordinates relative to the reciprocal lattice vectors. SPECTRAL_KPOINT_PATH ^4 ^4 B -- A list of k-points in the Brillouin zone which defines the path along which a band-structure calculation will be performed. SPECTRAL_KPOINT_PATH_SPACING P 0.1 \u00c5^{-1} \u00c5^{-1} Specifies the maximum spacing between k-points along the path for which a band structure calculation will be performed. SPECTRAL_KPOINT_LIST ^4 ^4 B SCF k-points A list of k-points at which a band-structure calculation will be performed. SPECTRAL_KPOINT_MP_GRID ^4 ^4 W -- The k-points for optical matrix element calculations defined as a Monkhorst-Pack grid by specifying the grid dimensions in each direction. SPECTRAL_KPOINT_MP_SPACING ^4 ^4 P 0.1 \u00c5 ^{-1} ^{-1} The k-points for optical matrix element calculations as a Monkhorst-Pack grid by specifying the maximum distance between k-points. SPECTRAL_KPOINT_MP_OFFSET V 0,0,0 The offset of the origin of the Monkhorst-Pack grid for optical matrix element calculations in fractional coordinates relative to the reciprocal lattice vectors. PHONON_KPOINT_PATH ^5 ^5 B -- A list of k-points in the Brillouin zone which defines the path along which a phonon calculation will be performed. PHONON_KPOINT_PATH_SPACING P 0.1 \u00c5 ^{-1} ^{-1} Specifies the maximum spacing between k-points along the path for which a phonon calculation will be performed. PHONON_KPOINT_LIST ^5 ^5 B SCF k-points A list of k-points at which a phonon calculation will be performed. PHONON_GAMMA_DIRECTIONS B See text The directions in which the gamma point will be approached for calculation of the LO/TO splitting. SYMMETRY_GENERATE ^6 ^6 D no symmetry If this is present, the highest symmtery group of the cell will found and the corresponding symmetry operations generated. SYMMETRY_OPS ^6 ^6 B no symmetry The symmetry operations that apply to the cell. SYMMETRY_TOL P 0.01 \u00c5 The tolerance within which symmetry will be enforced. IONIC_CONSTRAINTS B no constraints The constraints on the motion of ions during relaxation or MD. FIX_ALL_IONS L FALSE Constrain all ionic positions to remain fixed. FIX_ALL_CELL L FALSE Constrain all cell parameters to remain fixed. FIX_COM L TRUE Constrain the centre of mass of the ions to remain fixed. CELL_CONSTRAINTS B no constraints The constraints on changes in the cell shape during relaxation or MD. SPECIES_MASS B atomic mass The masses of the ionic species. SPECIES_POT B see text The names of the pseudopotentials associated with each species. SPECIES_LCAO_STATES B see text The number of angular momentum states to use in the LCAO basis set for this species when performing population analysis. EXTERNAL_PRESSURE B no pressure The external pressure tensor. IONIC_VELOCITIES B random The velocities of the ions in Cartesian coordinates. For the argument types, B indicates block data, P means a physical value, L is a logical value, D is a keyword that may simply be defined (present) or not, V is a real vector and W is an integer vector. ^1 ^1 Only one of LATTICE_CART and LATTICE_ABC maybe present in a cell file. ^2 ^2 Only one of POSITIONS_FRAC and POSITIONS_ABS may be present in a cell file. ^3 ^3 Only one of KPOINTS_LIST , KPOINTS_MP_GRID and KPOINTS_MP_SPACING may be present in a cell file. ^4 ^4 Only one of SPECTRAL_KPOINT_PATH , SPECTRAL_KPOINTS_MP_GRID , SPECTRAL_KPOINTS_MP_SPACING and SPECTRAL_KPOINT_LIST may be present in a cell file. ^5 ^5 Only one of PHONON_KPOINT_PATH and PHONON_KPOINT_LIST may be present in a cell file. ^6 ^6 Only one of SYMMETRY_GENERATE and SYMMETRY_OPS may be present in a cell file.","title":"cell keywords"},{"location":"documentation/Input_Files/param_file/","text":"This is a detailed description of options for CASTEP's param file. See the basic param file page for an overview. This page has the most frequently-used param file options, but for a full set use CASTEP's built-in help . The param file is one of CASTEP's two main input files. It contains all of the information about the kind of simulation your wish CASTEP to perform, as well as details of how CASTEP should perform them and additional simulations and analyses. The file itself is a free-format keyword-driven text file, consisting largely of single-line keywords, although there are a small number of blocks of information. These may be given in any order, with blocks indicated by the special %block and %endblock markers. All of the keywords and blocks are optional, but you will almost always want to change at least some. Task This keyword controls what CASTEP's simulation task is. The default is task : energy which tells CASTEP to compute the ground state electronic energy and density for the input set of atoms from the cell file . Cut-off energy The plane-wave cut-off energy controls how large CASTEP's basis set is for representing the wavefunction. Higher values mean more plane-waves and a better representation of the wavefunction, but this consumes more computer RAM and the calculation will take more time. CASTEP calculations are always a compromise between the accuracy you require, and the computational resources the simulations will use. The cut-off energy you need will also depend on the pseudopotentials you're using in the cell file . You can choose from some preset values using the basis_precision keyword: basis_precision : coarse|medium|fine|precise i.e. you can choose to set basis_precision to coarse , medium , fine or precise . The settings coarse and medium are usually only suitable for quick preliminary investigations, and for research simulations you will usually want to set it to fine or better. For more control over the cut-off energy, the cut_off_energy keyword may be used instead: cut_off_energy : 500 eV Typical cut-off energies are in the range 300 to 1500 eV. XC functional Density functional theory is exact in principle, except for the exchange-correlation (XC) functional which must be approximated. There are many different functional forms to approximate this, and in CASTEP you select it with the xc_functional keyword, for example: xc_functional : pbe which selects the PBE functional of Perdew, Burke and Ernzerhof.","title":"param file"},{"location":"documentation/Input_Files/param_file/#task","text":"This keyword controls what CASTEP's simulation task is. The default is task : energy which tells CASTEP to compute the ground state electronic energy and density for the input set of atoms from the cell file .","title":"Task"},{"location":"documentation/Input_Files/param_file/#cut-off-energy","text":"The plane-wave cut-off energy controls how large CASTEP's basis set is for representing the wavefunction. Higher values mean more plane-waves and a better representation of the wavefunction, but this consumes more computer RAM and the calculation will take more time. CASTEP calculations are always a compromise between the accuracy you require, and the computational resources the simulations will use. The cut-off energy you need will also depend on the pseudopotentials you're using in the cell file . You can choose from some preset values using the basis_precision keyword: basis_precision : coarse|medium|fine|precise i.e. you can choose to set basis_precision to coarse , medium , fine or precise . The settings coarse and medium are usually only suitable for quick preliminary investigations, and for research simulations you will usually want to set it to fine or better. For more control over the cut-off energy, the cut_off_energy keyword may be used instead: cut_off_energy : 500 eV Typical cut-off energies are in the range 300 to 1500 eV.","title":"Cut-off energy"},{"location":"documentation/Input_Files/param_file/#xc-functional","text":"Density functional theory is exact in principle, except for the exchange-correlation (XC) functional which must be approximated. There are many different functional forms to approximate this, and in CASTEP you select it with the xc_functional keyword, for example: xc_functional : pbe which selects the PBE functional of Perdew, Burke and Ernzerhof.","title":"XC functional"},{"location":"documentation/Molecular_Dynamics/overview/","text":"Instead of using the forces to optimise the structure of the system, CASTEP can instead use the forces to accelerate the atoms (and cell-shape) in order to simulate dynamical properties - a method known as \"Molecular Dynamics\" or simply \"MD\". To perform this kind of calculation, set task : MD in your param file. CASTEP has a wide range of Molecular Dynamics (MD) capabilities, and can do equilibrium MD using a variety of ensembles: * NVE - the microcanonical ensemble - with fixed number of atoms, volume of cell, and total energy conserved * NVT - the canonical ensemble - with constant temperature not constant energy - due to the application of a thermostat * NPH - constant external pressure and enthalpy - due to the application of a barostat * NPT - constant external pressure and temperature - due to the application of a barostat and a thermostat Of thse, NPT is the closest to most real-life experiments. Of the different thermostats, CASTEP supports Nose-Hoover, Nose-Hoover chains, Langevin and Hoover-Langevin. Of the different barostats, CASTEP supports the isotropic Andersen-Hoover barostat, and the anisotropic Parrinello-Rahman barostat. CASTEP also supports the Berendsen thermostat and barostat, as a route to faster equilibration before switching to one of the above thermostats/barostats for production data. CASTEP can also go beyond the Born-Oppenheimer approximation to do quantum dynamics, using Path Integral Molecular Dynamics (PIMD), in either NVT or NPT ensembles. In all MD schemes, CASTEP can support both linear and non-linear constraints on the ionic positions and/or on the cell vectors. The detailed trajectory information is written to either <seed>.geom or <seed>.md files, which are structured text files, for ease of manipulation and post-calculation analysis.","title":"Overview"},{"location":"documentation/NMR/NMR_overview/","text":"Diamagnetic Insulators By a diamagnetic insulator we mean a system with an electronic gap between its highest occupied state and lowest unoccupied state, and all of the electronic spins are paired, simple examples are diamond, quartz, glycine\u2026 This class of materials is the most suitable for calculations as the main NMR interactions, magnetic sielding, J-coupling and electric field gradients can all be computed. Magnetic Shielding In a diamagnetic insulator this arises from orbital currents induced by an external magnetic field. This current {\\bf j}({\\bf r}) {\\bf j}({\\bf r}) , produces a non-uniform induced magnetic field in the material, which is given by the Biot-Savart law as {\\bf B}_{\\rm in}({\\bf r}) =\\frac{1}{c}\\int d^3r' {\\bf j}({\\bf r}')\\times \\frac{{\\bf r}-{\\bf r}'}{|{\\bf r}-{\\bf r}'|^3}. {\\bf B}_{\\rm in}({\\bf r}) =\\frac{1}{c}\\int d^3r' {\\bf j}({\\bf r}')\\times \\frac{{\\bf r}-{\\bf r}'}{|{\\bf r}-{\\bf r}'|^3}. The shielding tensor is defined as the ratio between this induced field, and the external applied field {\\bf B}_{\\rm in}({\\bf r})=-{\\vec{\\sigma}}({\\bf r}){\\bf B}_{\\rm ext}. {\\bf B}_{\\rm in}({\\bf r})=-{\\vec{\\sigma}}({\\bf r}){\\bf B}_{\\rm ext}. It can thus be seen that the question of computing the shielding tensor is that of computing the induced electronic current. J-coupling The J-coupling is a small perturbation to the electronic ground-state of the system and we can identify it as a derivative of the total energy E, of the system {\\bf J}_{\\rm KL}= \\frac{\\hbar\\gamma_{\\rm K}\\gamma_{\\rm L}}{2\\pi}\\frac{\\partial^2 E}{\\partial {\\bf m}_{\\rm K} \\partial {\\bf m}_{\\rm L}} {\\bf J}_{\\rm KL}= \\frac{\\hbar\\gamma_{\\rm K}\\gamma_{\\rm L}}{2\\pi}\\frac{\\partial^2 E}{\\partial {\\bf m}_{\\rm K} \\partial {\\bf m}_{\\rm L}} An equivalent expression arises from considering one nuclear spin (L) as perturbation which creates a magnetic field at a second (receiving) nucleus (K) {\\bf B}^{(1)}_{\\rm in}({\\bf R}_{{\\rm K}}) = \\frac{2\\pi}{\\hbar\\gamma_{{\\rm K}}\\gamma_{{\\rm L}}}{\\bf J}_{{\\rm KL}} \\cdot {\\bf m}_{{\\rm L}}. {\\bf B}^{(1)}_{\\rm in}({\\bf R}_{{\\rm K}}) = \\frac{2\\pi}{\\hbar\\gamma_{{\\rm K}}\\gamma_{{\\rm L}}}{\\bf J}_{{\\rm KL}} \\cdot {\\bf m}_{{\\rm L}}. Eqn.~\\ref{eq:J} tells us that the question of computing J is essentially that of computing the magnetic field induced indirectly by a nuclear magnetic moment. When spin-orbit coupling is neglected we can consider the field as arising from two, essentially independent, mechanisms. Firstly, the magnetic moment can interact with electronic charge inducing an orbital current {\\bf j}({\\bf r}) {\\bf j}({\\bf r}) , which in turn creates a magnetic field at the other nuclei in the system. This mechanism is similar to the case of magnetic shielding in insulators. The second mechanism arises from the interaction of the magnetic moment with the electronic spin, causing an electronic spin polarisation. By working to first order in these quantities we can write the magnetic field at atom {\\rm K} {\\rm K} induced by the magnetic moment of atom {\\rm L} {\\rm L} as {\\bf B}^{(1)}_{\\rm in}({\\bf R}_{{\\rm K}}) = \\frac{\\mu_{0}}{4\\pi}\\int {\\bf m}^{(1)}({\\bf r})\\cdot \\left[\\frac{3{\\bf r}_{{\\rm K}}{\\bf r}_{{\\rm K}} - |{\\bf r}_{{\\rm K}}|^{2}}{|{\\bf r}_{{\\rm K}}|^{5}}\\right]\\,{\\rm d}^{3}{\\bf r} {\\bf B}^{(1)}_{\\rm in}({\\bf R}_{{\\rm K}}) = \\frac{\\mu_{0}}{4\\pi}\\int {\\bf m}^{(1)}({\\bf r})\\cdot \\left[\\frac{3{\\bf r}_{{\\rm K}}{\\bf r}_{{\\rm K}} - |{\\bf r}_{{\\rm K}}|^{2}}{|{\\bf r}_{{\\rm K}}|^{5}}\\right]\\,{\\rm d}^{3}{\\bf r} + \\frac{\\mu_{0}}{4\\pi}\\frac{8\\pi}{3}\\int {\\bf m}^{(1)}({\\bf r}) \\delta({\\bf r}_{{\\rm K}})\\,{\\rm d}^{3}{\\bf r} + \\frac{\\mu_{0}}{4\\pi}\\frac{8\\pi}{3}\\int {\\bf m}^{(1)}({\\bf r}) \\delta({\\bf r}_{{\\rm K}})\\,{\\rm d}^{3}{\\bf r} + \\frac{\\mu_{0}}{4\\pi}\\int {\\bf j}^{(1)}({\\bf r})\\times \\frac{{\\bf r}_{{\\rm K}}}{|{\\bf r}_{{\\rm K}}|^{3}}\\,{\\rm d}^{3}{\\bf r}. + \\frac{\\mu_{0}}{4\\pi}\\int {\\bf j}^{(1)}({\\bf r})\\times \\frac{{\\bf r}_{{\\rm K}}}{|{\\bf r}_{{\\rm K}}|^{3}}\\,{\\rm d}^{3}{\\bf r}. Several quantum chemistry packages provide the ability to compute J coupling tensors in molecular systems (see Ref 1 } for a review of methods). An approach to compute J tensors within the planewave-pseudopotential approach has recently been developed. 2 EFG For a nucleus with spin > > \u00bd the NMR response will include an interaction between the quadrupole moment of the nucleus, Q, and the electric field gradient (EFG) generated by the surrounding electronic structure. The EFG is a second rank, symmetric, traceless tensor G({\\bf r}) G({\\bf r}) given by G_{\\alpha\\beta}({\\bf r}) = \\frac{\\partial E_{\\alpha}({\\bf r})}{\\partial r_{\\beta}} - \\frac{1}{3}\\delta_{\\alpha\\beta}\\sum_{\\gamma}\\frac{\\partial E_{\\gamma}({\\bf r})}{\\partial r_{\\gamma}} G_{\\alpha\\beta}({\\bf r}) = \\frac{\\partial E_{\\alpha}({\\bf r})}{\\partial r_{\\beta}} - \\frac{1}{3}\\delta_{\\alpha\\beta}\\sum_{\\gamma}\\frac{\\partial E_{\\gamma}({\\bf r})}{\\partial r_{\\gamma}} where \\alpha,\\beta,\\gamma \\alpha,\\beta,\\gamma denote the Cartesian coordinates x,y,z and E_{\\alpha}({\\bf r}) E_{\\alpha}({\\bf r}) is the local electric field at the position {\\bf r} {\\bf r} , which can be calculated from the charge density n({\\bf r}) n({\\bf r}) : \\begin{equation} E_{\\alpha}({\\bf r})=\\int d^3r \\frac{n({\\bf r})}{|{\\bf r}-{\\bf r}'|^3} (r_{\\alpha}-r_{\\alpha}'). \\end{equation} The EFG tensor is then equal to \\begin{equation}\\label{eq:efg_rs} G_{\\alpha\\beta}({\\bf r}) = \\int d^3r \\frac{n({\\bf r})}{|{\\bf r}-{\\bf r}'|^3}\\left[ \\delta_{\\alpha\\beta} -3 \\frac{(r_{\\alpha}-r_{\\alpha}')(r_{\\beta}-r_{\\beta}')}{|{\\bf r}-{\\bf r}'|^2}\\right]. \\end{equation} The computation of electric field gradient tensors is less demanding than either shielding or J-coupling tensors as it requires only knowledge of the electronic ground state. The LAPW approach in its implementation within the Wien series of codes\\cite{blaha90} has been widely used and shown to reliably predict Electric Field Gradient (EFG) tensors 3 . The equivalent formalism for the planewave/PAW approach is reported in Ref.~\\cite{profeta03}. The quadrupolar coupling constant, C _Q _Q and the asymmetry parameter, \\eta_Q \\eta_Q can be obtained from the the diagonalized electric field gradient tensor whose eigenvalues are labelled V _{xx} _{xx} , V _{yy} _{yy} , V _{zz} _{zz} , such that |V_{zz}|>|V_{yy}|>|V_{xx}| |V_{zz}|>|V_{yy}|>|V_{xx}| : \\begin{equation} C_{Q}=\\frac{eV_{zz}Q}{h}, \\end{equation} where h is Planck's constant and \\begin{equation} \\eta_Q=\\frac{V_{xx}-V_{yy}}{V_{zz}}. \\end{equation} Helgaker, T.; Jaszunski, M.; Pecul, M.Progress in Nuclear Magnetic Resonance Spectroscopy2008,53, 249 \u2013 268 \u21a9 Joyce, S. A.; Yates, J. R.; Pickard, C. J.; Mauri, F.J. Chem. Phys.2007,127, 204107 \u21a9 Blaha, P.; Sorantin, P.; Ambrosch, C.; Schwarz, K.Hyperfine Interact.1989,51, 917 \u21a9","title":"NMR Overview"},{"location":"documentation/NMR/NMR_overview/#diamagnetic-insulators","text":"By a diamagnetic insulator we mean a system with an electronic gap between its highest occupied state and lowest unoccupied state, and all of the electronic spins are paired, simple examples are diamond, quartz, glycine\u2026 This class of materials is the most suitable for calculations as the main NMR interactions, magnetic sielding, J-coupling and electric field gradients can all be computed.","title":"Diamagnetic Insulators"},{"location":"documentation/NMR/NMR_overview/#magnetic-shielding","text":"In a diamagnetic insulator this arises from orbital currents induced by an external magnetic field. This current {\\bf j}({\\bf r}) {\\bf j}({\\bf r}) , produces a non-uniform induced magnetic field in the material, which is given by the Biot-Savart law as {\\bf B}_{\\rm in}({\\bf r}) =\\frac{1}{c}\\int d^3r' {\\bf j}({\\bf r}')\\times \\frac{{\\bf r}-{\\bf r}'}{|{\\bf r}-{\\bf r}'|^3}. {\\bf B}_{\\rm in}({\\bf r}) =\\frac{1}{c}\\int d^3r' {\\bf j}({\\bf r}')\\times \\frac{{\\bf r}-{\\bf r}'}{|{\\bf r}-{\\bf r}'|^3}. The shielding tensor is defined as the ratio between this induced field, and the external applied field {\\bf B}_{\\rm in}({\\bf r})=-{\\vec{\\sigma}}({\\bf r}){\\bf B}_{\\rm ext}. {\\bf B}_{\\rm in}({\\bf r})=-{\\vec{\\sigma}}({\\bf r}){\\bf B}_{\\rm ext}. It can thus be seen that the question of computing the shielding tensor is that of computing the induced electronic current.","title":"Magnetic Shielding"},{"location":"documentation/NMR/NMR_overview/#j-coupling","text":"The J-coupling is a small perturbation to the electronic ground-state of the system and we can identify it as a derivative of the total energy E, of the system {\\bf J}_{\\rm KL}= \\frac{\\hbar\\gamma_{\\rm K}\\gamma_{\\rm L}}{2\\pi}\\frac{\\partial^2 E}{\\partial {\\bf m}_{\\rm K} \\partial {\\bf m}_{\\rm L}} {\\bf J}_{\\rm KL}= \\frac{\\hbar\\gamma_{\\rm K}\\gamma_{\\rm L}}{2\\pi}\\frac{\\partial^2 E}{\\partial {\\bf m}_{\\rm K} \\partial {\\bf m}_{\\rm L}} An equivalent expression arises from considering one nuclear spin (L) as perturbation which creates a magnetic field at a second (receiving) nucleus (K) {\\bf B}^{(1)}_{\\rm in}({\\bf R}_{{\\rm K}}) = \\frac{2\\pi}{\\hbar\\gamma_{{\\rm K}}\\gamma_{{\\rm L}}}{\\bf J}_{{\\rm KL}} \\cdot {\\bf m}_{{\\rm L}}. {\\bf B}^{(1)}_{\\rm in}({\\bf R}_{{\\rm K}}) = \\frac{2\\pi}{\\hbar\\gamma_{{\\rm K}}\\gamma_{{\\rm L}}}{\\bf J}_{{\\rm KL}} \\cdot {\\bf m}_{{\\rm L}}. Eqn.~\\ref{eq:J} tells us that the question of computing J is essentially that of computing the magnetic field induced indirectly by a nuclear magnetic moment. When spin-orbit coupling is neglected we can consider the field as arising from two, essentially independent, mechanisms. Firstly, the magnetic moment can interact with electronic charge inducing an orbital current {\\bf j}({\\bf r}) {\\bf j}({\\bf r}) , which in turn creates a magnetic field at the other nuclei in the system. This mechanism is similar to the case of magnetic shielding in insulators. The second mechanism arises from the interaction of the magnetic moment with the electronic spin, causing an electronic spin polarisation. By working to first order in these quantities we can write the magnetic field at atom {\\rm K} {\\rm K} induced by the magnetic moment of atom {\\rm L} {\\rm L} as {\\bf B}^{(1)}_{\\rm in}({\\bf R}_{{\\rm K}}) = \\frac{\\mu_{0}}{4\\pi}\\int {\\bf m}^{(1)}({\\bf r})\\cdot \\left[\\frac{3{\\bf r}_{{\\rm K}}{\\bf r}_{{\\rm K}} - |{\\bf r}_{{\\rm K}}|^{2}}{|{\\bf r}_{{\\rm K}}|^{5}}\\right]\\,{\\rm d}^{3}{\\bf r} {\\bf B}^{(1)}_{\\rm in}({\\bf R}_{{\\rm K}}) = \\frac{\\mu_{0}}{4\\pi}\\int {\\bf m}^{(1)}({\\bf r})\\cdot \\left[\\frac{3{\\bf r}_{{\\rm K}}{\\bf r}_{{\\rm K}} - |{\\bf r}_{{\\rm K}}|^{2}}{|{\\bf r}_{{\\rm K}}|^{5}}\\right]\\,{\\rm d}^{3}{\\bf r} + \\frac{\\mu_{0}}{4\\pi}\\frac{8\\pi}{3}\\int {\\bf m}^{(1)}({\\bf r}) \\delta({\\bf r}_{{\\rm K}})\\,{\\rm d}^{3}{\\bf r} + \\frac{\\mu_{0}}{4\\pi}\\frac{8\\pi}{3}\\int {\\bf m}^{(1)}({\\bf r}) \\delta({\\bf r}_{{\\rm K}})\\,{\\rm d}^{3}{\\bf r} + \\frac{\\mu_{0}}{4\\pi}\\int {\\bf j}^{(1)}({\\bf r})\\times \\frac{{\\bf r}_{{\\rm K}}}{|{\\bf r}_{{\\rm K}}|^{3}}\\,{\\rm d}^{3}{\\bf r}. + \\frac{\\mu_{0}}{4\\pi}\\int {\\bf j}^{(1)}({\\bf r})\\times \\frac{{\\bf r}_{{\\rm K}}}{|{\\bf r}_{{\\rm K}}|^{3}}\\,{\\rm d}^{3}{\\bf r}. Several quantum chemistry packages provide the ability to compute J coupling tensors in molecular systems (see Ref 1 } for a review of methods). An approach to compute J tensors within the planewave-pseudopotential approach has recently been developed. 2","title":"J-coupling"},{"location":"documentation/NMR/NMR_overview/#efg","text":"For a nucleus with spin > > \u00bd the NMR response will include an interaction between the quadrupole moment of the nucleus, Q, and the electric field gradient (EFG) generated by the surrounding electronic structure. The EFG is a second rank, symmetric, traceless tensor G({\\bf r}) G({\\bf r}) given by G_{\\alpha\\beta}({\\bf r}) = \\frac{\\partial E_{\\alpha}({\\bf r})}{\\partial r_{\\beta}} - \\frac{1}{3}\\delta_{\\alpha\\beta}\\sum_{\\gamma}\\frac{\\partial E_{\\gamma}({\\bf r})}{\\partial r_{\\gamma}} G_{\\alpha\\beta}({\\bf r}) = \\frac{\\partial E_{\\alpha}({\\bf r})}{\\partial r_{\\beta}} - \\frac{1}{3}\\delta_{\\alpha\\beta}\\sum_{\\gamma}\\frac{\\partial E_{\\gamma}({\\bf r})}{\\partial r_{\\gamma}} where \\alpha,\\beta,\\gamma \\alpha,\\beta,\\gamma denote the Cartesian coordinates x,y,z and E_{\\alpha}({\\bf r}) E_{\\alpha}({\\bf r}) is the local electric field at the position {\\bf r} {\\bf r} , which can be calculated from the charge density n({\\bf r}) n({\\bf r}) : \\begin{equation} E_{\\alpha}({\\bf r})=\\int d^3r \\frac{n({\\bf r})}{|{\\bf r}-{\\bf r}'|^3} (r_{\\alpha}-r_{\\alpha}'). \\end{equation} The EFG tensor is then equal to \\begin{equation}\\label{eq:efg_rs} G_{\\alpha\\beta}({\\bf r}) = \\int d^3r \\frac{n({\\bf r})}{|{\\bf r}-{\\bf r}'|^3}\\left[ \\delta_{\\alpha\\beta} -3 \\frac{(r_{\\alpha}-r_{\\alpha}')(r_{\\beta}-r_{\\beta}')}{|{\\bf r}-{\\bf r}'|^2}\\right]. \\end{equation} The computation of electric field gradient tensors is less demanding than either shielding or J-coupling tensors as it requires only knowledge of the electronic ground state. The LAPW approach in its implementation within the Wien series of codes\\cite{blaha90} has been widely used and shown to reliably predict Electric Field Gradient (EFG) tensors 3 . The equivalent formalism for the planewave/PAW approach is reported in Ref.~\\cite{profeta03}. The quadrupolar coupling constant, C _Q _Q and the asymmetry parameter, \\eta_Q \\eta_Q can be obtained from the the diagonalized electric field gradient tensor whose eigenvalues are labelled V _{xx} _{xx} , V _{yy} _{yy} , V _{zz} _{zz} , such that |V_{zz}|>|V_{yy}|>|V_{xx}| |V_{zz}|>|V_{yy}|>|V_{xx}| : \\begin{equation} C_{Q}=\\frac{eV_{zz}Q}{h}, \\end{equation} where h is Planck's constant and \\begin{equation} \\eta_Q=\\frac{V_{xx}-V_{yy}}{V_{zz}}. \\end{equation} Helgaker, T.; Jaszunski, M.; Pecul, M.Progress in Nuclear Magnetic Resonance Spectroscopy2008,53, 249 \u2013 268 \u21a9 Joyce, S. A.; Yates, J. R.; Pickard, C. J.; Mauri, F.J. Chem. Phys.2007,127, 204107 \u21a9 Blaha, P.; Sorantin, P.; Ambrosch, C.; Schwarz, K.Hyperfine Interact.1989,51, 917 \u21a9","title":"EFG"},{"location":"documentation/Pseudopotentials/otfg_string/","text":"In addition to Chris' OTFG document, some more description of the OTF string 2|3.1|4.0|2.2|2|3|5|50U3.4:60U3.1:51:52U3.1{6s1.45,5d0.05}(qc=3)[] Quantities in <> are descriptions not literals. All chars outside <> are literal <Local cpt>|<r_c(loc)>|<r_c(nonloc)>|<rinner/rcore>|<COARSE>|<MEDIUM>|<FINE>| <proj1>:<proj2>...<projn>{<config>}(flags)[<test config>] Local cpt : 0,1,2 for s,p,d r_c(loc) : pseudisation radius for local component (atomic units) r_c(nl) : pseudisation radius for nonlocal components (atomic units) (can be overridden as part of projector description) rinner/rcore : Pseudisation radius for augmentation functions and pseudo-core charge COARSE/MEDIUM/FINE : Recommended cutoff energies in atomic units (Hartree) projn : Descriptions of projectors to include, separated by semicolons. Syntax of a projector is in its briefest form <n><l> where digits <n> and <l> denote the atomic quantum numbers eg 30 for 3s In fact this is equivalent to the expanded form \"<n><l>UU\" where the projector flags \"UU\" mean include two ultrasoft beta projectors for this channel. The full form is <n><l>[<type>[<r_c>]][+/-<dE_use>][@<shift>] where anything in brackets [] is optional (here only). <type> can be U - a single ultrasoft projector UU - Two ultrasoft projectors N - a single norm-conserving projector L - use this projector as the local component G - an ultrasoft GIPAW Gamma projector H - an norm-conserving GIPAW Gamma projector P - Dummy: do not make a projector. LG - Make Gammas for local channel (not done by default) <r_c> - the projector specific pseudisation radius. <dE_use> - the reference energy for the projector. A floating-point value beginning with an explicit '=', '+' or '-' in Hartree. '=E' means absolute energy, '+/-E' is relative to AE eigenvalue. <shift> - Add this value to the projector, it shift it in energy. config : Reference configuration used to generate pseudopotential specified in obvious way, eg {3s1,3d0.5}. It is not necessary to explicitly mention all core states - CASTEP figures this out. flags : Options controlling the type of pseudisation applied and parameters. Syntax (flag1,flag2, ) allows multiple, comma separated flags qc=<val> The optmisation parameter - KE for q < qc is minimised in optimised projector scheme. Can also write (qc=3,qc1=3.5) to specify angular momentum channel-specific value of qc. tm Troullier-Martins pseudosation scheme pn polynomial fit pb bessel fit es \"extra soft\" scheme esr=val extra-soft with explicit specification of r_c nonlcc Do not generate of unscreen with a pseudo-core charge. schro Use non-relativistic schroedinger equation for AE calculation (default is scalar relativistic eqn) aug Explicitly turn on augmentation charges scpsp Generate a self-consistent pseudopotential test config : Specify a non-default test configuration eg, [4s1.5,3d0.5].","title":"OTFG string"},{"location":"documentation/Pseudopotentials/overview/","text":"CASTEP has a built-in library of pseudopotentials which is usually updated each release. We refer to CASTEP's build-in pseudopotentials as on-the-fly generated (or OTFG). The default OTFG pseudopotentials are accurate ultrasoft pseudopotentials. These are used if species_pot block is not defined in the cell file - or an empty block is given %block species_pot %endblock species_pot For preliminary investigations and high-throughput calculations you might want to choose the QC5 set of ultrasoftpotentials which are faster, but slightly less accurate than the default set. These are designed to give converged results at 500eV for all elements: %block species_pot QC5 %endblock species_pot For properties that require norm-conserving pseudopotentials, you can select CASTEP's latest OTFG norm-conserving set with the following in the in your .cell file. %block species_pot NCP %endblock species_pot For backwards compatibility you can also select pseudopotentials from earlier versions on the on-the-fly database, e.g. use %block species_pot C17 %endblock species_pot to select the ultrasoft pseudopotentials from CASTEP version 17. You can also specify the pseudopotential on a per-element basis, e.g. %block species_pot Fe C17 O NCP Ba QC5 %endblock species_pot A complete list of the availible OTFG definitions follows: String Description NCP Alias for the most recent set of norm conserving potentials QC5 High through put set (delta=1.7meV, 0.8meV excluding N,O,Cr,Mn) HARD \"Ultimate\" set of HARD pseudopotentials C7 USP definitions as of CASTEP 7.0 (C7) C8 USP definitions as of CASTEP 8.0 (C8) C9 USP definitions as of CASTEP 9.0/16.0 delta=0.5meV NCP9 Set of Norm Conserving pseudopotentials CASTEP 9.0/16.0 (NCP9)(delta=1.1meV) C17 USP definitions, CASTEP 17.0 (C17) NCP19 Set of Norm Conserving pseudopotentials CASTEP 17.0 (NCP17) C18 USP definitions, CASTEP 18.0 (C18) NCP18 Norm Conserving pseudopotentials CASTEP 18.0 (NCP18) C19 USP definitions, CASTEP 19.0 (C19) delta=0.442 meV NCP19 Norm Conserving pseudopotentials CASTEP 19.0 (NCP19) delta=1.098 meV Pseudopotential files CASTEP can also read in pseudopotentials from files Format Origin .usp as generated by CASTEP (note both USP and NCP use this format) .uspso as generated by CASTEP, with spin-orbit coupling .recpot as generated by OPIUM (also legacy CASTEP files) .UPF as generated by Quantum Espresso Note that properties using PAW augmentation will not be available when using file based pseudopotentials (OTFG is required) - this includes all NMR/EPR properties and EELS spectra.","title":"Overview"},{"location":"documentation/Pseudopotentials/overview/#pseudopotential-files","text":"CASTEP can also read in pseudopotentials from files Format Origin .usp as generated by CASTEP (note both USP and NCP use this format) .uspso as generated by CASTEP, with spin-orbit coupling .recpot as generated by OPIUM (also legacy CASTEP files) .UPF as generated by Quantum Espresso Note that properties using PAW augmentation will not be available when using file based pseudopotentials (OTFG is required) - this includes all NMR/EPR properties and EELS spectra.","title":"Pseudopotential files"},{"location":"documentation/Pseudopotentials/reading_headers/","text":"At the start of a calculation CASTEP will generate the require pseudopotentials. A report is written into the start of the .castep file. This page explains what information is contained within this header. Carbon - Ultrasoft ============================================================ | Pseudopotential Report - Date of generation 8-07-2020 | ------------------------------------------------------------ | Element: C Ionic charge: 4.00 Level of theory: PBE | | Atomic Solver: Koelling-Harmon | | | | Reference Electronic Structure | | Orbital Occupation Energy | | 2s 2.000 -0.505 | | 2p 2.000 -0.194 | | | | Pseudopotential Definition | | Beta l e Rc scheme norm | | 1 0 -0.505 1.395 qc 0 | | 2 0 0.250 1.395 qc 0 | | 3 1 -0.194 1.395 qc 0 | | 4 1 0.250 1.395 qc 0 | | loc 2 0.000 1.395 pn 0 | | | | Augmentation charge Rinner = 0.983 | | Partial core correction Rc = 0.983 | ------------------------------------------------------------ | \"2|1.4|10|12|13|20:21(qc=7)\" | ------------------------------------------------------------ | Author: Chris J. Pickard, Cambridge University | ============================================================ All quantities are given in atomic units - so energies in Hartree (1Ha =26.4eV) and lengths in Bohr (1 bohr = 0.88Ang) Element: This is just the symbol for the element Ionic Charge: Sum of nuclear charge and the core electrons (C Z=6 core=1s2 gives ionic charge as +6-2=+4) Level of theory: The Exchange-Correlation potential used. Atomic-solver: Koelling-Harmon is the default atomic solver. Reference electronic structure. This section describes the valence states included in the calculation. For Carbon these are the 2s and 2p states. Their occupations and energies are given. Pseudopotential Definition (Advanced) The definitions of each of the non-local projector (aka beta projectors) is given here. Beta - the number of the projector l - angular momentum quantum number e - energy of the corresponding orbital Rc - Cutoff (matching) radius for the orbital scheme - pseudization scheme (qc = qc tuned) norm - 1=norm-conserving 0-ultrasoft (norm not conserved) This is a standard Ultrasoft pseudopotential with two beta projectors per angular momentum channel. One projector is from an orbital at the eigen-energy (i.e. -0.505Ha for 2s) while the second projector corresponds to a non-bound orbital at an energy of 0.25Ha. The final line gives the choice of local potential. In this case the local potential is constructed from a l=2 state with the same cutoff radius as for the local projectors. Augmentation charge Rinner . This is specific to the Ultrasoft scheme - and describes the radius outside which the augmentation charge matches the all-electron charge. Partial core correction . As the exchange correlation energy is a non-linear function of charge there is an error introduced if we compute the xc energy of the valence and core electron separately. We therefore include the core charge in the calculation of the xc energy. The core charge is challenging to represent on a grid - and so a pseudized core charge is used. Rc is the cut-off for this pseudized core charge. Carbon - Normconserving ============================================================ | Pseudopotential Report - Date of generation 8-07-2020 | ------------------------------------------------------------ | Element: C Ionic charge: 4.00 Level of theory: PBE | | Atomic Solver: Koelling-Harmon | | | | Reference Electronic Structure | | Orbital Occupation Energy | | 2s 2.000 -0.505 | | 2p 2.000 -0.194 | | | | Pseudopotential Definition | | Beta l e Rc scheme norm | | 1 0 -0.505 1.201 qc 1 | | loc 1 -0.194 1.201 qc 1 | | | | No charge augmentation | | Partial core correction Rc = 0.839 | ------------------------------------------------------------ | \"1|1.2|17|20|23|20N:21L(qc=8)\" | ------------------------------------------------------------ | Author: Chris J. Pickard, Cambridge University | ============================================================ Note that the Reference Electronic Structure section is identical to the ultrasoft potential above. This relates to the all-electron atom and is unaffected by the details of the pseudopotential. From the pseudopotential definition we see there is one beta projector for l=0 (s) and the local potential is set to be l=1 (p). For norm-conserving potentials it is common to only need one projector per angular momentum chanel, and for one of the occupied channels to be represented by the local potential. There is no charge augmentation (this is only needed for ultrasofts) however, a non-linear core correction is used. Uranium - J-dependent ============================================================ | Pseudopotential Report - Date of generation 4-07-2020 | ------------------------------------------------------------ | Element: U Ionic charge: 14.00 Level of theory: LDA | | Atomic Solver: Dirac (FR) | | | | Reference Electronic Structure | | Orbital Occupation Energy | | 6s1/2 2.000 -1.748 | | 6p1/2 2.000 -1.101 | | 6p3/2 4.000 -0.776 | | 7s1/2 2.000 -0.161 | | 5f5/2 1.286 -0.147 | | 5f7/2 1.714 -0.116 | | 6d3/2 0.400 -0.103 | | 6d5/2 0.600 -0.085 | | | | Pseudopotential Definition | | Beta l 2j e Rc scheme norm | | 1 0 1 -1.748 2.106 qc 1 | | 2 0 1 -0.161 2.106 qc 1 | | 3 1 3 -0.776 2.106 qc 1 | | 4 1 1 -1.101 2.106 qc 1 | | 5 2 5 -0.085 2.106 qc 1 | | 6 2 3 -0.103 2.106 qc 1 | | 7 3 7 -0.116 2.106 qc 1 | | 8 3 5 -0.147 2.106 qc 1 | | loc 4 0 0.000 2.106 pn 0 | | | | No charge augmentation | | Partial core correction Rc = 1.472 | ------------------------------------------------------------ | \"4|2.1|17|19|22|60N:70N:61N:62N:53N(qc=6,q3=8)\" | ------------------------------------------------------------ | Author: Chris J. Pickard, Cambridge University | ============================================================ This pseudopotential is calculated by using a Dirac equation solver including the spin-orbit interaction (FR=fully relativistic). It is a norm-conserving potential. There are 14 electrons included in the valence (6s2,7s2,6p6,6d1,5f3). Because of the spin orbit splitting states with different j quantum numbers have different energies. States with l>0 are split into j=l+1/2 j=l+1/2 and j=l-1/2 j=l-1/2 (e.g. the 6p states are split into 6p\u00bd and 6p3/2, the 5f into 5f5/2 5f7/2).","title":"Headers"},{"location":"documentation/Pseudopotentials/reading_headers/#carbon-ultrasoft","text":"============================================================ | Pseudopotential Report - Date of generation 8-07-2020 | ------------------------------------------------------------ | Element: C Ionic charge: 4.00 Level of theory: PBE | | Atomic Solver: Koelling-Harmon | | | | Reference Electronic Structure | | Orbital Occupation Energy | | 2s 2.000 -0.505 | | 2p 2.000 -0.194 | | | | Pseudopotential Definition | | Beta l e Rc scheme norm | | 1 0 -0.505 1.395 qc 0 | | 2 0 0.250 1.395 qc 0 | | 3 1 -0.194 1.395 qc 0 | | 4 1 0.250 1.395 qc 0 | | loc 2 0.000 1.395 pn 0 | | | | Augmentation charge Rinner = 0.983 | | Partial core correction Rc = 0.983 | ------------------------------------------------------------ | \"2|1.4|10|12|13|20:21(qc=7)\" | ------------------------------------------------------------ | Author: Chris J. Pickard, Cambridge University | ============================================================ All quantities are given in atomic units - so energies in Hartree (1Ha =26.4eV) and lengths in Bohr (1 bohr = 0.88Ang) Element: This is just the symbol for the element Ionic Charge: Sum of nuclear charge and the core electrons (C Z=6 core=1s2 gives ionic charge as +6-2=+4) Level of theory: The Exchange-Correlation potential used. Atomic-solver: Koelling-Harmon is the default atomic solver.","title":"Carbon - Ultrasoft"},{"location":"documentation/Pseudopotentials/reading_headers/#reference-electronic-structure","text":"This section describes the valence states included in the calculation. For Carbon these are the 2s and 2p states. Their occupations and energies are given.","title":"Reference electronic structure."},{"location":"documentation/Pseudopotentials/reading_headers/#pseudopotential-definition-advanced","text":"The definitions of each of the non-local projector (aka beta projectors) is given here. Beta - the number of the projector l - angular momentum quantum number e - energy of the corresponding orbital Rc - Cutoff (matching) radius for the orbital scheme - pseudization scheme (qc = qc tuned) norm - 1=norm-conserving 0-ultrasoft (norm not conserved) This is a standard Ultrasoft pseudopotential with two beta projectors per angular momentum channel. One projector is from an orbital at the eigen-energy (i.e. -0.505Ha for 2s) while the second projector corresponds to a non-bound orbital at an energy of 0.25Ha. The final line gives the choice of local potential. In this case the local potential is constructed from a l=2 state with the same cutoff radius as for the local projectors. Augmentation charge Rinner . This is specific to the Ultrasoft scheme - and describes the radius outside which the augmentation charge matches the all-electron charge. Partial core correction . As the exchange correlation energy is a non-linear function of charge there is an error introduced if we compute the xc energy of the valence and core electron separately. We therefore include the core charge in the calculation of the xc energy. The core charge is challenging to represent on a grid - and so a pseudized core charge is used. Rc is the cut-off for this pseudized core charge.","title":"Pseudopotential Definition (Advanced)"},{"location":"documentation/Pseudopotentials/reading_headers/#carbon-normconserving","text":"============================================================ | Pseudopotential Report - Date of generation 8-07-2020 | ------------------------------------------------------------ | Element: C Ionic charge: 4.00 Level of theory: PBE | | Atomic Solver: Koelling-Harmon | | | | Reference Electronic Structure | | Orbital Occupation Energy | | 2s 2.000 -0.505 | | 2p 2.000 -0.194 | | | | Pseudopotential Definition | | Beta l e Rc scheme norm | | 1 0 -0.505 1.201 qc 1 | | loc 1 -0.194 1.201 qc 1 | | | | No charge augmentation | | Partial core correction Rc = 0.839 | ------------------------------------------------------------ | \"1|1.2|17|20|23|20N:21L(qc=8)\" | ------------------------------------------------------------ | Author: Chris J. Pickard, Cambridge University | ============================================================ Note that the Reference Electronic Structure section is identical to the ultrasoft potential above. This relates to the all-electron atom and is unaffected by the details of the pseudopotential. From the pseudopotential definition we see there is one beta projector for l=0 (s) and the local potential is set to be l=1 (p). For norm-conserving potentials it is common to only need one projector per angular momentum chanel, and for one of the occupied channels to be represented by the local potential. There is no charge augmentation (this is only needed for ultrasofts) however, a non-linear core correction is used.","title":"Carbon - Normconserving"},{"location":"documentation/Pseudopotentials/reading_headers/#uranium-j-dependent","text":"============================================================ | Pseudopotential Report - Date of generation 4-07-2020 | ------------------------------------------------------------ | Element: U Ionic charge: 14.00 Level of theory: LDA | | Atomic Solver: Dirac (FR) | | | | Reference Electronic Structure | | Orbital Occupation Energy | | 6s1/2 2.000 -1.748 | | 6p1/2 2.000 -1.101 | | 6p3/2 4.000 -0.776 | | 7s1/2 2.000 -0.161 | | 5f5/2 1.286 -0.147 | | 5f7/2 1.714 -0.116 | | 6d3/2 0.400 -0.103 | | 6d5/2 0.600 -0.085 | | | | Pseudopotential Definition | | Beta l 2j e Rc scheme norm | | 1 0 1 -1.748 2.106 qc 1 | | 2 0 1 -0.161 2.106 qc 1 | | 3 1 3 -0.776 2.106 qc 1 | | 4 1 1 -1.101 2.106 qc 1 | | 5 2 5 -0.085 2.106 qc 1 | | 6 2 3 -0.103 2.106 qc 1 | | 7 3 7 -0.116 2.106 qc 1 | | 8 3 5 -0.147 2.106 qc 1 | | loc 4 0 0.000 2.106 pn 0 | | | | No charge augmentation | | Partial core correction Rc = 1.472 | ------------------------------------------------------------ | \"4|2.1|17|19|22|60N:70N:61N:62N:53N(qc=6,q3=8)\" | ------------------------------------------------------------ | Author: Chris J. Pickard, Cambridge University | ============================================================ This pseudopotential is calculated by using a Dirac equation solver including the spin-orbit interaction (FR=fully relativistic). It is a norm-conserving potential. There are 14 electrons included in the valence (6s2,7s2,6p6,6d1,5f3). Because of the spin orbit splitting states with different j quantum numbers have different energies. States with l>0 are split into j=l+1/2 j=l+1/2 and j=l-1/2 j=l-1/2 (e.g. the 6p states are split into 6p\u00bd and 6p3/2, the 5f into 5f5/2 5f7/2).","title":"Uranium - J-dependent"},{"location":"documentation/Pseudopotentials/theory/","text":"The electrons in an atom can be divided into two types --- core electrons and valence electrons. The core electrons are tightly bound to the nucleus, while the valence electrons are more extended. A working definition for core electrons is that they are the ones which play no part in the interactions between atoms, while the valence electrons dictate most of the properties of the material. It is common to make the frozen core approximation; the core electrons are constrained not to differ from their free atomic nature when placed in the solid state environment. This reduces the number of electronic degrees of freedom in an all-electron calculation. It is a very good approximation. A different, but physically related, approach is taken in the pseudopotential approximation. Since, in an all-electron calculation, the valence electron wavefunctions must be orthogonal to the core wavefunctions they necessarily have strong oscillations in the region near the nucleus (see the all-electron wavefunction in Figure~\\ref{fig:wvfn}). Given that a planewave basis set is to be used to describe the wavefunctions, these strong oscillations are undesirable --- requiring many plane waves for an accurate description. Further, these oscillations are of very little consequence for the electronic structure in the solid, since they occur close to the nucleus. In the pseudopotential approach only the valence electrons are explicitly considered, the effects of the core electrons being integrated within a new ionic potential. The valence wavefunctions need no longer be orthogonal to the core states, and so the orthogonality oscillations disappear; hence far fewer plane waves are required to describe the valence wavefunctions. Numerous schemes to produce optimally soft pseudopotentials have been developed. Common choices are the norm-conserving potentials due to Troullier and Martins\\cite{troullier91} and Vanderbilt's ultrasoft scheme.\\cite{vanderbilt90}","title":"Theory"},{"location":"documentation/Spectral/keywords/","text":"SPECTRAL_TASK - determines what will be calculated. All tasks will compute the eigenenergies (aka bands). The list of tasks, and the extra properties calculated are as follows: bandstructure dos band gradients optics optical matrix elements pdos atomic projections coreloss dipole matrix elements with core states Most spectral calculations will involve the calculation of unoccupied states. One of the following parameters should be set to determine the number of states calculated. SPECTRAL_NEXTRA_BANDS number of extra spectral bands SPECTRAL_PERC_EXTRA_BANDS percentage of extra spectral bands SPECTRAL_NBANDS number of bands/k-point in spectral calc It is possible to use a different exchange-correlation functional to the one used for the groundstate. An example might be when a semi-local functional (such as PBE) is used for the groundstate, and a more expensive non-local functional (e.g. PBE0) is used for the spectral calculation. This is an approximation and should be done with cuation. To set the xc functional use one of the two keywords. SPECTRAL_XC_FUNCTIONAL spectral exchange-correlation functional SPECTRAL_XC_DEFINITION spectral exchange-correlation functional To change the convergence tolerance for the eigenvalues set SPECTRAL_EIGENVALUE_TOL ! default: 10E-6 eV SPECTRAL_MAX_ITER maximum iterations in spectral calculation SPECTRAL_MAX_STEPS_PER_ITER maximum steps per iter in spectral calculation","title":"Keywords"},{"location":"documentation/Spectral/overview/","text":"`","title":"Overview"},{"location":"documentation/Spectral/restarts/","text":"Spectral calculations do not write a check file - however, they can write backups to enable restarting an unfinished calculation. The limitation is that a parallel calculation must be restarted on the same number of processors. #Sample param file cut_off_energy : 550 eV fix_occupancy : true task : spectral spectral_task : coreloss %block devel_code SPECTRAL_RESTART %endblock devel_code backup_interval 1800 ! time in seconds The devel_code keyword SPECTRAL_RESTART triggers both the writing an reading of Spectral backup files. backup_interval determines the time between writing backups. Backup will slow down the calculation as they require disk access (which is always slow). If you expect a job to run for several hours backing up every 30min is a reasonable compromise. After completing each k-point the CASTEP will check to see if time since the last backup is greater than backup_interval - is it is a backup will be written - if not CASTEP carries on with the next k-point. Note that a backup is always written (if backup_interval>0) after the final kpoint. This is useful insurance in case there is any problem when CASTEP writes the final output files. Here is an example .castep file with backup ===================================================================== + + + Calculation of Spectral Properties + + + + Calculation re-parallelised over 2 processes. + + Data distributed by G-vector(1-way), k-point(2-way), band(1-way) + + Data distributed by k-point(2-way) + + + ===================================================================== Starting k-point: 1 of 5 on this process |<-- SPEC Starting k-point: 2 of 5 on this process |<-- SPEC Starting k-point: 3 of 5 on this process |<-- SPEC Check-pointing spectral run |<-- SPEC Starting k-point: 4 of 5 on this process |<-- SPEC Starting k-point: 5 of 5 on this process |<-- SPEC Starting k-point: 1 of 5 on this process |<-- SPEC Check-pointing spectral run |<-- SPEC Starting k-point: 2 of 5 on this process |<-- SPEC Starting k-point: 3 of 5 on this process |<-- SPEC Starting k-point: 4 of 5 on this process |<-- SPEC We see that backups were written every three k-points. The last backup was done after the 1 st k-point for spin 2. As this calculation was run on two processors, we find two backup files have been created -rw-r--r-- 1 317700 18 Jul 10:53 Si2-core.0001.spec -rw-r--r-- 1 317700 18 Jul 10:53 Si2-core.0002.spec To restart, keep everything the same but add to the param file continuation : xxx.check Where xxx.check is the name of the check file containing the ground-state density etc. This will have been written during the first run - and xxx will be replaced with whatever is the seedname of your run. We now re-run the calculation. CASTEP will read the ground-state from the check file (so there should be no electronic minimisation) Restarting spectral calculation from restart file |<-- SPEC Starting k-point: 2 of 5 on this process |<-- SPEC Starting k-point: 3 of 5 on this process |<-- SPEC Starting k-point: 4 of 5 on this process |<-- SPEC Check-pointing spectral run |<-- SPEC Starting k-point: 5 of 5 on this process |<-- SPEC Check-pointing spectral run |<-- SPEC Total time to compute matrix elements 3500.45 sec |<\u2014- SPEC So the calculation did restart from the 2 nd k-point on spin 2.","title":"Restarts"},{"location":"documentation/TDDFT/overview/","text":"","title":"TDDFT Overview"},{"location":"documentation/Troubleshooting/linux_path/","text":"Command not found When you type castep , Linux doesn't know where that command is, so it looks in the places where programs are usually put (often /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin and /usr/local/sbin ; \"bin\" here is short for \"binary\"). Unless CASTEP is there, it will tell you that it can't find it. Notice in particular that the directory you're in when you type the command is not in Linux's list of usual places to look, which is especially confusing when you first encounter it! Telling Linux where to find CASTEP There are several ways to fix this. If you're on a shared machine, it is usually best to make a subdirectory in your home directory, perhaps called \"bin\": mkdir ~/bin and put CASTEP in there (along with any other programs you compile yourself), e.g. cp ~/CASTEP-22.1/obj/linux_x86_64_gfortran--serial/castep.serial ~/bin This still won't mean that Linux will find CASTEP, because this is also not a place it will look for programs. The places Linux looks in are stored in a special Linux environment variable called the \"path\", and the final step is to add the new directory to this \"path\". Exactly how you do this depends on what kind of command-line interpreter (called a \"shell\") you're using in Linux, but there are only really two main kinds: bash and csh. Type export PATH=${PATH}:~/bin if you're using bash, or setenv PATH ${PATH}:~/bin if you're using csh. These commands tell Linux to look in all the places it's looking in already, and also \"~/bin\". If you don't know which shell you're using, try typing: echo $SHELL and see what it says. If it says something like \"/bin/bash\" then you're using bash, if it's \"/bin/csh\" or \"/bin/tcsh\" then it's csh (or close enough). If it gives something else, just try the line starting \"export\" and if it gives an error, try the \"setenv\" one instead. Now try typing \"castep.serial\" and you should see this: Usage: castep <seedname> : Run files <seedname>.cell [and <seedname>.param] \" [-d|--dryrun] <seedname> : Perform a dryrun calculation on files <seedname>.cell \" [-s|--search] <text> : print list of keywords with <text> match in description \" [-v|--version] : print version information \" [-h|--help] <keyword> : describe specific keyword in <>.cell or <>.param \" \" all : print list of all keywords \" \" basic : print list of basic-level keywords \" \" inter : print list of intermediate-level keywords \" \" expert : print list of expert-level keywords \" \" dummy : print list of dummy keywords Automatically adding to your PATH The changes so far will be lost when you exit the command-line. We need to make sure that your directory is added to the PATH variable every time you log in or open a new terminal. If you're using bash, edit the file ~/.bashrc with a text editor (e.g. gedit), go to the end, and add the line to set the PATH: export PATH=${PATH}:~/bin Note that the file is in your home directory (\"~/\"), and the name starts with a dot (\".\" a full stop). Save and exit, and it should all be set up for you. If you're using csh, edit the file \"~/.cshrc\" instead, and add the appropriate line to set the PATH: setenv PATH ${PATH}:~/bin Save and exit, and it should all be set up for you.","title":"Linux help"},{"location":"documentation/Troubleshooting/linux_path/#command-not-found","text":"When you type castep , Linux doesn't know where that command is, so it looks in the places where programs are usually put (often /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin and /usr/local/sbin ; \"bin\" here is short for \"binary\"). Unless CASTEP is there, it will tell you that it can't find it. Notice in particular that the directory you're in when you type the command is not in Linux's list of usual places to look, which is especially confusing when you first encounter it!","title":"Command not found"},{"location":"documentation/Troubleshooting/linux_path/#telling-linux-where-to-find-castep","text":"There are several ways to fix this. If you're on a shared machine, it is usually best to make a subdirectory in your home directory, perhaps called \"bin\": mkdir ~/bin and put CASTEP in there (along with any other programs you compile yourself), e.g. cp ~/CASTEP-22.1/obj/linux_x86_64_gfortran--serial/castep.serial ~/bin This still won't mean that Linux will find CASTEP, because this is also not a place it will look for programs. The places Linux looks in are stored in a special Linux environment variable called the \"path\", and the final step is to add the new directory to this \"path\". Exactly how you do this depends on what kind of command-line interpreter (called a \"shell\") you're using in Linux, but there are only really two main kinds: bash and csh. Type export PATH=${PATH}:~/bin if you're using bash, or setenv PATH ${PATH}:~/bin if you're using csh. These commands tell Linux to look in all the places it's looking in already, and also \"~/bin\". If you don't know which shell you're using, try typing: echo $SHELL and see what it says. If it says something like \"/bin/bash\" then you're using bash, if it's \"/bin/csh\" or \"/bin/tcsh\" then it's csh (or close enough). If it gives something else, just try the line starting \"export\" and if it gives an error, try the \"setenv\" one instead. Now try typing \"castep.serial\" and you should see this: Usage: castep <seedname> : Run files <seedname>.cell [and <seedname>.param] \" [-d|--dryrun] <seedname> : Perform a dryrun calculation on files <seedname>.cell \" [-s|--search] <text> : print list of keywords with <text> match in description \" [-v|--version] : print version information \" [-h|--help] <keyword> : describe specific keyword in <>.cell or <>.param \" \" all : print list of all keywords \" \" basic : print list of basic-level keywords \" \" inter : print list of intermediate-level keywords \" \" expert : print list of expert-level keywords \" \" dummy : print list of dummy keywords","title":"Telling Linux where to find CASTEP"},{"location":"documentation/Troubleshooting/linux_path/#automatically-adding-to-your-path","text":"The changes so far will be lost when you exit the command-line. We need to make sure that your directory is added to the PATH variable every time you log in or open a new terminal. If you're using bash, edit the file ~/.bashrc with a text editor (e.g. gedit), go to the end, and add the line to set the PATH: export PATH=${PATH}:~/bin Note that the file is in your home directory (\"~/\"), and the name starts with a dot (\".\" a full stop). Save and exit, and it should all be set up for you. If you're using csh, edit the file \"~/.cshrc\" instead, and add the appropriate line to set the PATH: setenv PATH ${PATH}:~/bin Save and exit, and it should all be set up for you.","title":"Automatically adding to your PATH"},{"location":"documentation/Troubleshooting/troubleshooting/","text":"CASTEP fails to start Command not found If you see a message like this on the command-line when you run CASTEP: castep mytest castep: command not found then your computer has not located the CASTEP program. Check that: you've used the correct CASTEP name ( castep.serial or castep.mpi ) the CASTEP program is somewhere your computer expects programs to be See here for details of where Linux looks for programs, and how to change it. CASTEP aborts a calculation If CASTEP detects a serious problem, it will stop and write an error message to a .err file. If you are using the parallel version of CASTEP on many cores, you may see error messages from each of these cores. They are named using the same seedname, but with the process ID added, e.g. if CASTEP is run on 2 cores and a serious problem occurs, you might see the files mytest.0001.err mytest.0002.err These files contain useful information about what went wrong, so it is always worth looking at them. Failed to converge","title":"Common errors"},{"location":"documentation/Troubleshooting/troubleshooting/#castep-fails-to-start","text":"","title":"CASTEP fails to start"},{"location":"documentation/Troubleshooting/troubleshooting/#command-not-found","text":"If you see a message like this on the command-line when you run CASTEP: castep mytest castep: command not found then your computer has not located the CASTEP program. Check that: you've used the correct CASTEP name ( castep.serial or castep.mpi ) the CASTEP program is somewhere your computer expects programs to be See here for details of where Linux looks for programs, and how to change it.","title":"Command not found"},{"location":"documentation/Troubleshooting/troubleshooting/#castep-aborts-a-calculation","text":"If CASTEP detects a serious problem, it will stop and write an error message to a .err file. If you are using the parallel version of CASTEP on many cores, you may see error messages from each of these cores. They are named using the same seedname, but with the process ID added, e.g. if CASTEP is run on 2 cores and a serious problem occurs, you might see the files mytest.0001.err mytest.0002.err These files contain useful information about what went wrong, so it is always worth looking at them.","title":"CASTEP aborts a calculation"},{"location":"documentation/Troubleshooting/troubleshooting/#failed-to-converge","text":"","title":"Failed to converge"},{"location":"documentation/Vibrations/overview/","text":"","title":"Vibrations"},{"location":"documentation/XC/XC/","text":"The exchange and correlation functional used for calculations in Castep can be specified in one of two main ways. xc_functional The most straightforward is with the .param file keyword xc_functional . For example to use the PBE functional in the .param file simply use xc_functional : PBE There are a number of standard functionals that can be used in Castep with the xc_functional keyword: Local density approximation: LDA LDA-X LDA-C Generalised gradient approximations (GGA): PW91 PBE PBEsol RPBE WC BLYP B86PBE PBE_X PBE_C PBEsol_X PBEsol_C B88_X LYP_C Hybrid (non-local) functionals: HF SHF-LDA PBE0 B3LYP HSE03 HSE06 SPBE0 Meta-GGA functionals: RSCAN MS2 xc_definition The keyword xc_definition in the .param file (used instead of xc_functional) is used when you want to modify the standard behaviour of hybrid functionals, or if you want to construct your own hybrid functionals. The simplest use of xc_definition is to replicate that of xc_functional , for example %block xc_definition PBE 1.0 %endblock xc_definition is the same as xc_functional : PBE The \"1.0\" is what weighted fraction of the functional you want, so in this case 1.0 (i.e. 100% PBE). Recall that hybrids are (usually) a mixture of pure (or screened) non-local Hartree-Fock exchange, some local exchange and local correlation. So you could, for example, build a functional that could be 20% Hartree Fock, 80% LDA exchange and 100% LDA correlation. You can run a Castep calculation with this using %block xc_definition HF 0.2 LDA-X 0.8 LDA-C 1.0 %endblock xc_definition Examples: 1. B3LYP Firstly you cansimply use xc_functional : B3LYP , however B3LYP is a hybrid functional consisting of a mixture of Hartree-Fock, LDA and B88 exchange, LYP and LDA correlation. This functional can be specified component by component: %block xc_definition LDA-X 0.08 B88_X 0.72 LYP_C 0.81 LDA-C 0.19 HF 0.20 %endblock xc_definition Using the full specification in xc_definition makes it straightforward to adjust the various component weightings to your own specification. There are other adjustments that can be made within the functional. For example the popular functional HSE06 contains a screened Hartree-Fock component, with a mixture of other local functionals. It can be specified component by component as %block xc_definition SHF 0.25 PBE 1.0 PBE_X_SR -0.25 NLXC_SCREENING_LENGTH 0.11 NLXC_SCREENING_FUNCTION ERRORFUNCTION %endblock xc_definition In this case we have 25% screened Hartree-Fock offsetting -25% screened PBE exchange (and 100% PBE correlation within PBE). The default HF screening is exponential, but this can be changed to an error function as shown in the block. Also the strength of the screening can be altered by the NLXC_SCREENING_LENGTH parameter (natural units). 2. Hybrid functionals are expensive calculations, much(!) more computationally intensive than (semi-)local functionals. They are often used because they are able to give much better electronic band gaps. If we do LDA and SHF-LDA band structure for silicon we can use the cell file %block lattice_cart 2.7 2.7 0.0 2.7 0.0 2.7 0.0 2.7 2.7 %endblock lattice_cart %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac symmetry_generate %block spectral_kpoint_path W G X W L G %endblock spectral_kpoint_path %block species_pot NCP %endblock species_pot and then the .param file for LDA task : spectral spectral_task : BandStructure xc_functional : lda and for screened exchange, task : spectral spectral_task : BandStructure xc_functional : shf-lda If we then plot these two band structures together, the difference in results can be seen, the band gap opens from the LDA value of around 0.5eV to a more realistic 1.","title":"Controlling XC"},{"location":"documentation/XC/XCoverview/","text":"There are many sources of description of the role of exchange and correlation within density functional theory, https://en.wikipedia.org/wiki/Density_functional_theory Here we will look at how to give both a basic control over the XC functional that your calculation will use and well as giving finer control over functionals that have free parameters.","title":"Overview"},{"location":"documentation/XC/libXC/","text":"There are many (many!) XC functionals (of varying quality and applicability). LIBXC ( https://www.tddft.org/programs/libxc/ ) is a maintained library of functionals that is upgraded regularly. The list of functionals available in LIBXC is at https://www.tddft.org/programs/libxc/functionals/ . Castep interfaces to this library which can be used instead of Castep's in-built library of XC functionals. Prepend the string LIBXC_ to Castep's functional name in the parameter keyword xc_functional to use LIBXC. For example: xc_functional : PBE for Castep's in-built PBE functional xc_functional : LIBXC_PBE for the LIBXC version of the PBE functional In the LIBXC library there are many functionals, covering LDAs, GGAs, Meta-GGAs, Hybrids, etc. Most of these are separated into exchange and correlation contributions. To use these functionals, build your own combination using Castep's xc_definition keyword in the .param file. Firstly at https://www.tddft.org/programs/libxc/functionals/ find the exchange and correlation functionals that you require, note the name LIBXC calls is and then prepend the string LIBXC_ to them. For example to construct Perdew and Zunger's LDA, LDA exchange is called LDA_X and correlation is called LDA_C_PZ. In the .param file use %block xc_definition LIBXC_LDA_X 1.0 LIBXC_LDA_C_PZ 1.0 %endblock xc_definition The \"1.0\" after each is the fraction of how much of each you require to use, in this case 100% of each. Example, construct the PBE functional from LIBXC: In LIBXC, PBE exchange is called GGA_X_PBE and its correlation is called GGA_C_PBE. Prepend with LIBXC_ and construct xc_definition : %block xc_definition LIBXC_GGA_X_PBE 1.0 LIBXC_GGA_C_PBE 1.0 %endblock xc_definition There are a few functional in LIBXC that have combined exchange and correlation parts, so this can be listed in xc_definition on its own. For example the HCTH93 XC functional is called GGA_XC_HCTH_93 in LIBXC hence it can be used in Castep with %block xc_definition LIBXC_GGA_XC_HCTH_93 1.0 %endblock xc_definition LIBXC can also be used to construct hybrid (non-local) functionals that contain (screened) Hartree-Fock components. Note that LIBXC does not contain the non-local part of such functionals, just the local part. Construct the functional using Castep's non-local functionality. For example, the PBE0 functional is called HYB_GGA_XC_PBE0 in LIBXC, so to construct this use %block xc_definition LIBXC_HYB_GGA_XC_PBE0 1.0 HF 0.25 %endblock xc_definition Note here you need to know (ie. read the HYB_GGA_XC_PBE0 reference given in https://www.tddft.org/programs/libxc/functionals/ ) what fraction of local exchange is in the functional and so infer what the fraction of non-local exchange is required (here 0.25). If you want to vary the fraction of non-local exchange then you need to balance this with offsetting it with the correct fraction of local exchange. For this construct the whole functional yourself. For example PBE0 is 0.25HF + 0.75PBE_X + 1.0PBE_C. Varying the HF component in PBE0 can be done with %block xc_definition HF 0.20 LIBXC_GGA_PBE_X 0.80 LIBXC_GGA_PBE_C_1.0 %endblock xc_definition where here it's set to 20% non-local and 80% local exchange, with 100% PBE correlation. Meta-GGAs are also supported. For example the RSCAN functional can be used with %block xc_definition LIBXC_MGGA_X_RSCAN 1.0 LIBXC_MGGA_C_RSCAN 1.0 %endblock xc_definition (although RSCAN is also natively supported in Castep with xc_functional : RSCAN ). The xc_definition keyword in the .param file will allow you to mix and match any of the hundreds of functionals in LIBXC https://www.tddft.org/programs/libxc/functionals/ . DO SO WITH EXTREME CAUTION!","title":"libXC"},{"location":"documentation/XRD/overview/","text":"X-ray Structure Factors Basic Theory The X-ray structure factor (SF) intensities can be measured by diffraction experiments involving either X-rays, \\gamma \\gamma -rays or electron beams. It is directly related to the electron density within the unit cell of a material, n(\\mathbf{r}) n(\\mathbf{r}) , by a Fourier transformation 1 : F(\\mathbf{H}) = \\mathcal{F}[n(\\mathbf{r})] = \\int_\\textrm{unit cell} n(\\mathbf{r})\\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}) \\mathrm{d}\\mathbf{r}, F(\\mathbf{H}) = \\mathcal{F}[n(\\mathbf{r})] = \\int_\\textrm{unit cell} n(\\mathbf{r})\\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}) \\mathrm{d}\\mathbf{r}, where \\mathbf{H} = h \\mathbf{a}^* + k \\mathbf{b}^* + l\\mathbf{c}^* \\mathbf{H} = h \\mathbf{a}^* + k \\mathbf{b}^* + l\\mathbf{c}^* is the scattering vector corresponding to the (hkl) (hkl) plane, with \\mathbf{a}^*, \\mathbf{b}^* \\mathbf{a}^*, \\mathbf{b}^* and \\mathbf{c}^* \\mathbf{c}^* being the reciprocal lattice vectors of the conventional unit cell. Computation of the SF is difficult within plane-wave pseudopotential DFT codes since the total \"all-electron'' electron density is not normally directly computed and the FFT grids used to house the pseudised valence electron density do not have enough spatial resolution to capture the rapid oscillations near the atomic cores of the total electron density, requiring large plane-wave energy cutoffs in the order of several thousands of eV. Within CASTEP, we have developed an efficient and accurate approach towards calculating these SFs without having to move to large FFT grids or plane-wave energy cutoffs. Details of this implementation can be found in the paper (CITE PAPER WHEN PUBLISHED) but the key observation that has enabled this development is that the electron density can be separated into atom-centred contributions which can be treated on separate radial grids. The resulting structure factor has the form 2 : F(\\mathbf{H}) = \\sum_{j} f_{j} (\\mathbf{H}) \\exp(i 2\\pi \\mathbf{H} \\cdot \\mathbf{r}_{j}), F(\\mathbf{H}) = \\sum_{j} f_{j} (\\mathbf{H}) \\exp(i 2\\pi \\mathbf{H} \\cdot \\mathbf{r}_{j}), where f_j(\\mathbf{H}) f_j(\\mathbf{H}) is an effective atomic scattering factor of atom j j within the unit cell, defined to be the Fourier transform of its effective atomic density \\rho_j(\\mathbf{r}) \\rho_j(\\mathbf{r}) : f_j (\\mathbf{H}) = \\int \\rho_j (\\mathbf{r}) \\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}) \\mathrm{d}{\\mathbf{r}}. f_j (\\mathbf{H}) = \\int \\rho_j (\\mathbf{r}) \\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}) \\mathrm{d}{\\mathbf{r}}. Incorporating Thermal Effects Within experiments, thermal vibrations (i.e. phonons) can modify the (time-averaged) electron density and, hence, SFs. Making the approximation that the electron density assigned to each atom \\rho_j(\\mathbf{r}) \\rho_j(\\mathbf{r}) directly follows its nuclear motion perfectly, the structure factors can incoporate these thermal vibration effects by including an atomic temperature factor T(\\mathbf{H}) T(\\mathbf{H}) : F(\\mathbf{H}) = \\sum_j T_j(\\mathbf{H}) f_j (\\mathbf{H}) \\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}_j). F(\\mathbf{H}) = \\sum_j T_j(\\mathbf{H}) f_j (\\mathbf{H}) \\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}_j). Taking the vibrations of an atom to follow that of a harmonic oscillator, the temperature factor can be shown to be of the form: T(\\mathbf{H}) = \\exp \\left(-\\frac{1}{4} \\mathbf{H}^\\mathbf{T} \\mathbf{B} \\mathbf{H} \\right), T(\\mathbf{H}) = \\exp \\left(-\\frac{1}{4} \\mathbf{H}^\\mathbf{T} \\mathbf{B} \\mathbf{H} \\right), where \\mathbf{B}^{jk} = 8 \\pi^2 \\langle u^j u^k \\rangle \\mathbf{B}^{jk} = 8 \\pi^2 \\langle u^j u^k \\rangle \\langle u^j u^k \\rangle \\langle u^j u^k \\rangle are the averaged, squared, thermal displacements of the atom. For the case where the vibrations are isotropic, this equation reduces to: T(\\mathbf{H}) = \\exp \\left(-\\frac{B |\\mathbf{H}|^2}{4} \\right), T(\\mathbf{H}) = \\exp \\left(-\\frac{B |\\mathbf{H}|^2}{4} \\right), where B is termed the Debye-Waller factor. Keywords Currently, to enable CASTEP (versions 21 and beyond) to calculate X-ray SFs, the desired SFs must be placed between CALCULATE_XRD_SF: and :ENDCALCULATE_XRD_SF within the devel_code block of the seed.param file. For example, the (111) (111) and (200) (200) and (220) (220) SFs can be calculated by appending the following code to the end of the seed.param file: %block devel_code CALCULATE_XRD_SF: 1 1 1 2 0 0 2 2 0 :ENDCALCULATE_XRD_SF %endblock devel_code Alternatively, if no structure factors are listed, as in: %block devel_code CALCULATE_XRD_SF: :ENDCALCULATE_XRD_SF %endblock devel_code then the SFs on the entire FFT grid will be written out. Thermal effects can also be incoporated by placing the desired atomic Debye-Waller (DW) factors between DW_FACTOR: and :ENDDW_FACTOR within the devel_code block of the seed.param file. For isotropic DW factors, the value of the DW factor can be written next to the corresponding atomic symbol as below: %block devel_code DW_FACTOR: Mg 0.305 O 0.340 :ENDDW_FACTOR CALCULATE_XRD_SF: 1 1 1 2 0 0 2 2 0 :ENDCALCULATE_XRD_SF %endblock devel_code Alternatively, the entire anisotropic displacement tensor of each atomic species may be specified as follows: %block devel_code DW_FACTOR: Mg 0.305 0.000 0.000 0.000 0.305 0.000 0.000 0.000 0.305 O 0.340 0.000 0.000 0.000 0.340 0.000 0.000 0.000 0.340 :ENDDW_FACTOR CALCULATE_XRD_SF: 1 1 1 2 0 0 2 2 0 :ENDCALCULATE_XRD_SF %endblock devel_code Note Structure factor calculations are a post-processing calculation, so they can be restarted from a previous DFT calculation's .check file by using the CONTINUATION parameter in CASTEP. Output Files The resulting structure factors that have been calculated will be outputted into a file named seed.xrd_sf . For the following inputs: ! MgO.param xc_functional : PBE %block devel_code DW_FACTOR: Mg 0.305 O 0.340 :ENDDW_FACTOR CALCULATE_XRD_SF: 1 1 1 0 0 2 0 2 2 :ENDCALCULATE_XRD_SF %endblock devel_code ! MgO.cell %BLOCK LATTICE_CART ang 4.2112 0.0 0.0 0.0 4.2112 0.0 0.0 0.0 4.2112 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_FRAC Mg 0.00 0.00 0.00 Mg 0.50 0.50 0.00 Mg 0.50 0.00 0.50 Mg 0.00 0.50 0.50 O 0.00 0.50 0.00 O 0.50 0.00 0.00 O 0.00 0.00 0.50 O 0.50 0.50 0.50 %ENDBLOCK POSITIONS_FRAC kpoint_mp_grid 8 8 8 SYMMETRY_GENERATE We get a resulting seed.xrd_sf file with the output: h k l Re(F_PAW) Im(F_PAW) Re(F_IAM) Im(F_IAM) Re(F_PP) Im(F_PP) Re(F_core) Im(F_core) Re(F_soft) Im(F_soft) Re(F_aug) Im(F_aug) 1 1 1 11.115757 -0.000000 12.492143 -0.000000 10.926445 -0.000000 0.085890 -0.000000 -9.892234 0.000000 20.922101 -0.000000 0 0 2 52.877502 0.000000 51.830521 -0.000000 52.626486 0.000000 15.464656 -0.000000 15.585172 -0.000000 21.827675 0.000000 0 2 2 41.051122 0.000000 40.948429 -0.000000 40.609195 0.000000 14.950468 -0.000000 7.954567 -0.000000 18.146087 0.000000 After the header, the structure factors are listed along each row based on the order in which they have been listed in the seed.param file. Across the columns along each row, the h, k,l h, k,l vectors are first listed before the real and imaginary components of the SF are listed under Re(F_PAW) and Im(F_PAW) respectively. Several other (less accurate) SFs that are commonly found in literature as well as charge contributions to F_PAW are also listed in columns further to the right, as described below: Label Description F_PAW DFT structure factor with all-electron augmentation charge F_IAM Indepedent atom model structure factor; electron densit formed from superposition of atomic electron densities obtained by numerically solving the Koelling-Harmon equation F_PP DFT structure factor with pseudised (inaccurate) augmentation charge F_core Structure factor contribution to F_PAW due to the (frozen) core electrons F_soft Structure factor contribution to F_PAW due to the soft valence charge (where augmentation charge contribute is removed) F_aug Structure factor contribution due to the all-electron valence augmentation charge P. Coppens, X-Ray Charge Densities and Chemical Bonding (International Union of Crystallography, New York, 1997) \u21a9 U. Shmueli and Internationale Union f\u00fcr Kristallographie, editors , International Tables for Crystallography. Vol. B: Reciprocal Space, 2. ed (Kluwer Acad. Publ, Dordrecht, 2001) \u21a9","title":"XRD"},{"location":"documentation/XRD/overview/#x-ray-structure-factors","text":"","title":"X-ray Structure Factors"},{"location":"documentation/XRD/overview/#basic-theory","text":"The X-ray structure factor (SF) intensities can be measured by diffraction experiments involving either X-rays, \\gamma \\gamma -rays or electron beams. It is directly related to the electron density within the unit cell of a material, n(\\mathbf{r}) n(\\mathbf{r}) , by a Fourier transformation 1 : F(\\mathbf{H}) = \\mathcal{F}[n(\\mathbf{r})] = \\int_\\textrm{unit cell} n(\\mathbf{r})\\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}) \\mathrm{d}\\mathbf{r}, F(\\mathbf{H}) = \\mathcal{F}[n(\\mathbf{r})] = \\int_\\textrm{unit cell} n(\\mathbf{r})\\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}) \\mathrm{d}\\mathbf{r}, where \\mathbf{H} = h \\mathbf{a}^* + k \\mathbf{b}^* + l\\mathbf{c}^* \\mathbf{H} = h \\mathbf{a}^* + k \\mathbf{b}^* + l\\mathbf{c}^* is the scattering vector corresponding to the (hkl) (hkl) plane, with \\mathbf{a}^*, \\mathbf{b}^* \\mathbf{a}^*, \\mathbf{b}^* and \\mathbf{c}^* \\mathbf{c}^* being the reciprocal lattice vectors of the conventional unit cell. Computation of the SF is difficult within plane-wave pseudopotential DFT codes since the total \"all-electron'' electron density is not normally directly computed and the FFT grids used to house the pseudised valence electron density do not have enough spatial resolution to capture the rapid oscillations near the atomic cores of the total electron density, requiring large plane-wave energy cutoffs in the order of several thousands of eV. Within CASTEP, we have developed an efficient and accurate approach towards calculating these SFs without having to move to large FFT grids or plane-wave energy cutoffs. Details of this implementation can be found in the paper (CITE PAPER WHEN PUBLISHED) but the key observation that has enabled this development is that the electron density can be separated into atom-centred contributions which can be treated on separate radial grids. The resulting structure factor has the form 2 : F(\\mathbf{H}) = \\sum_{j} f_{j} (\\mathbf{H}) \\exp(i 2\\pi \\mathbf{H} \\cdot \\mathbf{r}_{j}), F(\\mathbf{H}) = \\sum_{j} f_{j} (\\mathbf{H}) \\exp(i 2\\pi \\mathbf{H} \\cdot \\mathbf{r}_{j}), where f_j(\\mathbf{H}) f_j(\\mathbf{H}) is an effective atomic scattering factor of atom j j within the unit cell, defined to be the Fourier transform of its effective atomic density \\rho_j(\\mathbf{r}) \\rho_j(\\mathbf{r}) : f_j (\\mathbf{H}) = \\int \\rho_j (\\mathbf{r}) \\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}) \\mathrm{d}{\\mathbf{r}}. f_j (\\mathbf{H}) = \\int \\rho_j (\\mathbf{r}) \\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}) \\mathrm{d}{\\mathbf{r}}.","title":"Basic Theory"},{"location":"documentation/XRD/overview/#incorporating-thermal-effects","text":"Within experiments, thermal vibrations (i.e. phonons) can modify the (time-averaged) electron density and, hence, SFs. Making the approximation that the electron density assigned to each atom \\rho_j(\\mathbf{r}) \\rho_j(\\mathbf{r}) directly follows its nuclear motion perfectly, the structure factors can incoporate these thermal vibration effects by including an atomic temperature factor T(\\mathbf{H}) T(\\mathbf{H}) : F(\\mathbf{H}) = \\sum_j T_j(\\mathbf{H}) f_j (\\mathbf{H}) \\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}_j). F(\\mathbf{H}) = \\sum_j T_j(\\mathbf{H}) f_j (\\mathbf{H}) \\exp(i 2 \\pi \\mathbf{H} \\cdot \\mathbf{r}_j). Taking the vibrations of an atom to follow that of a harmonic oscillator, the temperature factor can be shown to be of the form: T(\\mathbf{H}) = \\exp \\left(-\\frac{1}{4} \\mathbf{H}^\\mathbf{T} \\mathbf{B} \\mathbf{H} \\right), T(\\mathbf{H}) = \\exp \\left(-\\frac{1}{4} \\mathbf{H}^\\mathbf{T} \\mathbf{B} \\mathbf{H} \\right), where \\mathbf{B}^{jk} = 8 \\pi^2 \\langle u^j u^k \\rangle \\mathbf{B}^{jk} = 8 \\pi^2 \\langle u^j u^k \\rangle \\langle u^j u^k \\rangle \\langle u^j u^k \\rangle are the averaged, squared, thermal displacements of the atom. For the case where the vibrations are isotropic, this equation reduces to: T(\\mathbf{H}) = \\exp \\left(-\\frac{B |\\mathbf{H}|^2}{4} \\right), T(\\mathbf{H}) = \\exp \\left(-\\frac{B |\\mathbf{H}|^2}{4} \\right), where B is termed the Debye-Waller factor.","title":"Incorporating Thermal Effects"},{"location":"documentation/XRD/overview/#keywords","text":"Currently, to enable CASTEP (versions 21 and beyond) to calculate X-ray SFs, the desired SFs must be placed between CALCULATE_XRD_SF: and :ENDCALCULATE_XRD_SF within the devel_code block of the seed.param file. For example, the (111) (111) and (200) (200) and (220) (220) SFs can be calculated by appending the following code to the end of the seed.param file: %block devel_code CALCULATE_XRD_SF: 1 1 1 2 0 0 2 2 0 :ENDCALCULATE_XRD_SF %endblock devel_code Alternatively, if no structure factors are listed, as in: %block devel_code CALCULATE_XRD_SF: :ENDCALCULATE_XRD_SF %endblock devel_code then the SFs on the entire FFT grid will be written out. Thermal effects can also be incoporated by placing the desired atomic Debye-Waller (DW) factors between DW_FACTOR: and :ENDDW_FACTOR within the devel_code block of the seed.param file. For isotropic DW factors, the value of the DW factor can be written next to the corresponding atomic symbol as below: %block devel_code DW_FACTOR: Mg 0.305 O 0.340 :ENDDW_FACTOR CALCULATE_XRD_SF: 1 1 1 2 0 0 2 2 0 :ENDCALCULATE_XRD_SF %endblock devel_code Alternatively, the entire anisotropic displacement tensor of each atomic species may be specified as follows: %block devel_code DW_FACTOR: Mg 0.305 0.000 0.000 0.000 0.305 0.000 0.000 0.000 0.305 O 0.340 0.000 0.000 0.000 0.340 0.000 0.000 0.000 0.340 :ENDDW_FACTOR CALCULATE_XRD_SF: 1 1 1 2 0 0 2 2 0 :ENDCALCULATE_XRD_SF %endblock devel_code Note Structure factor calculations are a post-processing calculation, so they can be restarted from a previous DFT calculation's .check file by using the CONTINUATION parameter in CASTEP.","title":"Keywords"},{"location":"documentation/XRD/overview/#output-files","text":"The resulting structure factors that have been calculated will be outputted into a file named seed.xrd_sf . For the following inputs: ! MgO.param xc_functional : PBE %block devel_code DW_FACTOR: Mg 0.305 O 0.340 :ENDDW_FACTOR CALCULATE_XRD_SF: 1 1 1 0 0 2 0 2 2 :ENDCALCULATE_XRD_SF %endblock devel_code ! MgO.cell %BLOCK LATTICE_CART ang 4.2112 0.0 0.0 0.0 4.2112 0.0 0.0 0.0 4.2112 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_FRAC Mg 0.00 0.00 0.00 Mg 0.50 0.50 0.00 Mg 0.50 0.00 0.50 Mg 0.00 0.50 0.50 O 0.00 0.50 0.00 O 0.50 0.00 0.00 O 0.00 0.00 0.50 O 0.50 0.50 0.50 %ENDBLOCK POSITIONS_FRAC kpoint_mp_grid 8 8 8 SYMMETRY_GENERATE We get a resulting seed.xrd_sf file with the output: h k l Re(F_PAW) Im(F_PAW) Re(F_IAM) Im(F_IAM) Re(F_PP) Im(F_PP) Re(F_core) Im(F_core) Re(F_soft) Im(F_soft) Re(F_aug) Im(F_aug) 1 1 1 11.115757 -0.000000 12.492143 -0.000000 10.926445 -0.000000 0.085890 -0.000000 -9.892234 0.000000 20.922101 -0.000000 0 0 2 52.877502 0.000000 51.830521 -0.000000 52.626486 0.000000 15.464656 -0.000000 15.585172 -0.000000 21.827675 0.000000 0 2 2 41.051122 0.000000 40.948429 -0.000000 40.609195 0.000000 14.950468 -0.000000 7.954567 -0.000000 18.146087 0.000000 After the header, the structure factors are listed along each row based on the order in which they have been listed in the seed.param file. Across the columns along each row, the h, k,l h, k,l vectors are first listed before the real and imaginary components of the SF are listed under Re(F_PAW) and Im(F_PAW) respectively. Several other (less accurate) SFs that are commonly found in literature as well as charge contributions to F_PAW are also listed in columns further to the right, as described below: Label Description F_PAW DFT structure factor with all-electron augmentation charge F_IAM Indepedent atom model structure factor; electron densit formed from superposition of atomic electron densities obtained by numerically solving the Koelling-Harmon equation F_PP DFT structure factor with pseudised (inaccurate) augmentation charge F_core Structure factor contribution to F_PAW due to the (frozen) core electrons F_soft Structure factor contribution to F_PAW due to the soft valence charge (where augmentation charge contribute is removed) F_aug Structure factor contribution due to the all-electron valence augmentation charge P. Coppens, X-Ray Charge Densities and Chemical Bonding (International Union of Crystallography, New York, 1997) \u21a9 U. Shmueli and Internationale Union f\u00fcr Kristallographie, editors , International Tables for Crystallography. Vol. B: Reciprocal Space, 2. ed (Kluwer Acad. Publ, Dordrecht, 2001) \u21a9","title":"Output Files"},{"location":"tutorials/Bands_and_DOS/magnetic/","text":"Iron ! Fe.cell %BLOCK LATTICE_CART -1.433199999999999 1.433200000000001 1.433200000000001 1.433200000000001 -1.433200000000000 1.433200000000000 1.433200000000000 1.433200000000000 -1.433200000000000 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_FRAC Fe 0.0000000000000000 0.0000000000000000 0.0000000000000000 %ENDBLOCK POSITIONS_FRAC symmetry_generate ! Kpoint grid for the Groundstate (SCF) calculation kpoint_mp_grid 8 8 8 ! kpoint path through the Brillouin Zone for the Bandstructure %BLOCK spectral_KPOINT_PATH 0.0 0.0 0.0 !G 0.5 0.5 0.5 !H 0.5 0.0 0.0 !N 0.0 0.0 0.0 !G 0.75 0.25 -0.25 !P 0.5 0.0 0.0 !N %ENDBLOCK spectral_KPOINT_PATH In the param file we set spin_polarised true in order to allow the up and down spin electrons to take different configurations. It is important to start the calculation with an initial spin density using e.g. spin: 1 . The value of the initial spin should not affect the final answer - a non-zero value is just needed to break the symmetry between the spin channels. ! Fe.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! grid_scale 2.0 ! opt_strategy speed ! Choose algorithms for best speed spin 1 ! Set the spin in the original cell to 1. spin_polarised true ! Run a spin polarised calculation spectral_nbands 6 ! number of bands to compute during the BS run At the end of the calculation the net spin of the unit cell is reported in the castep file e.g. Integrated Spin Density = 2.15322 hbar/2 Note The band structure has similarities with that of Copper - and other 3d elements - with flat 3d bands and dispersive s bands. We colour code the bands according to their spin chactacter (red=up, blue=down). We can see that there is an almost constant exchange splitting of 1.5eV between the up and down 3d bands. The splitting between the s-like bands is much smaller. More up states lie below the fermi energy than down states - hence the net spin of the unit cell. FeO FeO is an anti-ferromagnetic oxide. We set up the calculation with initial spins on the two Fe atoms pointing in opposite directions. ! FeO.cell %BLOCK LATTICE_CART 1.768531594289456 0.000000000000001 5.002162732258922 -0.884265797144728 1.531593288050063 5.002162732258921 -0.884265797144728 -1.531593288050063 5.002162732258922 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_FRAC O 0.75 0.750 -1.250 O -0.75 -0.750 1.250 Fe 0.00 0.000 -0.000 spin=-4.0 Fe 1.50 -0.500 -0.500 spin=4.0 %ENDBLOCK POSITIONS_FRAC kpoints_mp_grid: 6 6 6 symmetry_generate %block spectral_kpoint_path 0.500 0.500 0.000 0.000 0.000 0.000 0.500 0.500 0.500 0.000 0.500 0.000 0.000 0.000 0.000 %endblock spectral_kpoint_path ! FeO.param task : spectral ! The TASK keyword instructs CASTEP what to do xc_functional : PBE ! Which exchange-correlation functional to use. cutoff_energy 600 eV opt_strategy speed ! Choose algorithms for speed. nextra_bands : 6 spin_polarized : true A PBE calculation incorrectly finds FeO to be a metal (bandstructure on left below). Add the following to the cell file to run a PBE+U calculation %block hubbard_u Fe 1 d: 2.5 Fe 2 d: 2.5 %endblock hubbard_u FeO band structure with PBE (left) and with PBE+U (right) Note Adding a Hubbard U term to the calculation opens the band gap and FeO is (correctly) predicted to be an antiferromangetic insulator.","title":"Magnetic Materials"},{"location":"tutorials/Bands_and_DOS/magnetic/#iron","text":"! Fe.cell %BLOCK LATTICE_CART -1.433199999999999 1.433200000000001 1.433200000000001 1.433200000000001 -1.433200000000000 1.433200000000000 1.433200000000000 1.433200000000000 -1.433200000000000 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_FRAC Fe 0.0000000000000000 0.0000000000000000 0.0000000000000000 %ENDBLOCK POSITIONS_FRAC symmetry_generate ! Kpoint grid for the Groundstate (SCF) calculation kpoint_mp_grid 8 8 8 ! kpoint path through the Brillouin Zone for the Bandstructure %BLOCK spectral_KPOINT_PATH 0.0 0.0 0.0 !G 0.5 0.5 0.5 !H 0.5 0.0 0.0 !N 0.0 0.0 0.0 !G 0.75 0.25 -0.25 !P 0.5 0.0 0.0 !N %ENDBLOCK spectral_KPOINT_PATH In the param file we set spin_polarised true in order to allow the up and down spin electrons to take different configurations. It is important to start the calculation with an initial spin density using e.g. spin: 1 . The value of the initial spin should not affect the final answer - a non-zero value is just needed to break the symmetry between the spin channels. ! Fe.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! grid_scale 2.0 ! opt_strategy speed ! Choose algorithms for best speed spin 1 ! Set the spin in the original cell to 1. spin_polarised true ! Run a spin polarised calculation spectral_nbands 6 ! number of bands to compute during the BS run At the end of the calculation the net spin of the unit cell is reported in the castep file e.g. Integrated Spin Density = 2.15322 hbar/2 Note The band structure has similarities with that of Copper - and other 3d elements - with flat 3d bands and dispersive s bands. We colour code the bands according to their spin chactacter (red=up, blue=down). We can see that there is an almost constant exchange splitting of 1.5eV between the up and down 3d bands. The splitting between the s-like bands is much smaller. More up states lie below the fermi energy than down states - hence the net spin of the unit cell.","title":"Iron"},{"location":"tutorials/Bands_and_DOS/magnetic/#feo","text":"FeO is an anti-ferromagnetic oxide. We set up the calculation with initial spins on the two Fe atoms pointing in opposite directions. ! FeO.cell %BLOCK LATTICE_CART 1.768531594289456 0.000000000000001 5.002162732258922 -0.884265797144728 1.531593288050063 5.002162732258921 -0.884265797144728 -1.531593288050063 5.002162732258922 %ENDBLOCK LATTICE_CART %BLOCK POSITIONS_FRAC O 0.75 0.750 -1.250 O -0.75 -0.750 1.250 Fe 0.00 0.000 -0.000 spin=-4.0 Fe 1.50 -0.500 -0.500 spin=4.0 %ENDBLOCK POSITIONS_FRAC kpoints_mp_grid: 6 6 6 symmetry_generate %block spectral_kpoint_path 0.500 0.500 0.000 0.000 0.000 0.000 0.500 0.500 0.500 0.000 0.500 0.000 0.000 0.000 0.000 %endblock spectral_kpoint_path ! FeO.param task : spectral ! The TASK keyword instructs CASTEP what to do xc_functional : PBE ! Which exchange-correlation functional to use. cutoff_energy 600 eV opt_strategy speed ! Choose algorithms for speed. nextra_bands : 6 spin_polarized : true A PBE calculation incorrectly finds FeO to be a metal (bandstructure on left below). Add the following to the cell file to run a PBE+U calculation %block hubbard_u Fe 1 d: 2.5 Fe 2 d: 2.5 %endblock hubbard_u FeO band structure with PBE (left) and with PBE+U (right) Note Adding a Hubbard U term to the calculation opens the band gap and FeO is (correctly) predicted to be an antiferromangetic insulator.","title":"FeO"},{"location":"tutorials/Bands_and_DOS/metals/","text":"Here we use CASTEP to calculate the bandstructure of two typical metals. The cell and param files are very similar to the semiconductor examples - the one difference is that we use a finer sampling of the Brillouin Zone with the keyword kpoint_mp_grid . A finer sampling is needed to correctly represent the change in occupancy at the Fermi energy. Aluminium ! Al.cell %BLOCK LATTICE_ABC 2.86 2.86 2.86 60 60 60 %ENDBLOCK LATTICE_ABC %BLOCK POSITIONS_ABS Al 0 0 0 %ENDBLOCK POSITIONS_ABS kpoint_mp_grid 12 12 12 %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path symmetry_generate ! Al.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed Note Aluminium is a metal - there is no gap energy between the occupied and unoccupied states. The bands are close to parabolic (this is particularly noticeable around Gamma) - the electronic structure of aluminium closely follows a nearly-free electron model. Copper ! Cu.cell %BLOCK LATTICE_ABC 2.55 2.55 2.55 60 60 60 %ENDBLOCK LATTICE_ABC %BLOCK POSITIONS_ABS Cu 0 0 0 %ENDBLOCK POSITIONS_ABS kpoint_mp_grid 12 12 12 %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path symmetry_generate ! Cu.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed at expense of memory. spectral_nbands 8 ! Note Copper is a metal - there is no gap energy between the occupied and unoccupied states. The bandstructure of copper is typical for a transition metal - we have highly dispersive parabolic bands corresponding to the s electrons, these are crossed by 5 quite flat bands corresponding to more localised 3d electrons. In copper the 3d states are filled, and we see the flat bands lie below the Fermi level.","title":"Metals"},{"location":"tutorials/Bands_and_DOS/metals/#aluminium","text":"! Al.cell %BLOCK LATTICE_ABC 2.86 2.86 2.86 60 60 60 %ENDBLOCK LATTICE_ABC %BLOCK POSITIONS_ABS Al 0 0 0 %ENDBLOCK POSITIONS_ABS kpoint_mp_grid 12 12 12 %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path symmetry_generate ! Al.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed Note Aluminium is a metal - there is no gap energy between the occupied and unoccupied states. The bands are close to parabolic (this is particularly noticeable around Gamma) - the electronic structure of aluminium closely follows a nearly-free electron model.","title":"Aluminium"},{"location":"tutorials/Bands_and_DOS/metals/#copper","text":"! Cu.cell %BLOCK LATTICE_ABC 2.55 2.55 2.55 60 60 60 %ENDBLOCK LATTICE_ABC %BLOCK POSITIONS_ABS Cu 0 0 0 %ENDBLOCK POSITIONS_ABS kpoint_mp_grid 12 12 12 %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path symmetry_generate ! Cu.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed at expense of memory. spectral_nbands 8 ! Note Copper is a metal - there is no gap energy between the occupied and unoccupied states. The bandstructure of copper is typical for a transition metal - we have highly dispersive parabolic bands corresponding to the s electrons, these are crossed by 5 quite flat bands corresponding to more localised 3d electrons. In copper the 3d states are filled, and we see the flat bands lie below the Fermi level.","title":"Copper"},{"location":"tutorials/Bands_and_DOS/plotting_perl/","text":"In this tutorial we will walk through plotting a bandstructure and density of states using the perl utilities supplied with CASTEP. We will use Xmgace for plotting - however, the scripts also support gnuplot. Bandstructure Here is a cell file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file si-bands.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 ! Specify a path through the Brillouin Zone to compute the band structure. ! %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path Here is a param file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file si-bands.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed We can then run castep and use the tool dispersion.pl to plot a bandstructure with Xmgrace. To see all of the functionality run 'dispersion.pl -h' castep si-bands dispersion.pl -sym fcc -xg si-bands.bands You should get a plot Density of States Here is a cell file. It is the same as a bandstructure cell file except we have replaced the path through the Brillioun zone with a regular grid of k-points. You can use the icon in the top right of the box to copy and paste the text. Save it in a file si-dos.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 ! Specify a uniform sampling of the Brillouin Zone ! spectral_kpoint_mp_grid 17 17 17 Here is a param file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file si-dos.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task dos ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed We can then run castep and use the tool dos.pl to plot a bandstructure with Xmgrace. To see all of the functionality run 'dos.pl -h' castep si-dos dos.pl -xg si-dos.bands -w 0.3 You should get a plot like Note The procedure above is inefficient as we computed the groundstate of the system twice, once when computing the bandstructure and again when computing the dos. To avoid this we could put the following line in the si-dos.param file continuation: si-bands.check . This will restart the calculation of the dos using the previously computed groundstate.","title":"Plotting - CASTEP tools"},{"location":"tutorials/Bands_and_DOS/plotting_perl/#bandstructure","text":"Here is a cell file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file si-bands.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 ! Specify a path through the Brillouin Zone to compute the band structure. ! %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path Here is a param file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file si-bands.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed We can then run castep and use the tool dispersion.pl to plot a bandstructure with Xmgrace. To see all of the functionality run 'dispersion.pl -h' castep si-bands dispersion.pl -sym fcc -xg si-bands.bands You should get a plot","title":"Bandstructure"},{"location":"tutorials/Bands_and_DOS/plotting_perl/#density-of-states","text":"Here is a cell file. It is the same as a bandstructure cell file except we have replaced the path through the Brillioun zone with a regular grid of k-points. You can use the icon in the top right of the box to copy and paste the text. Save it in a file si-dos.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 ! Specify a uniform sampling of the Brillouin Zone ! spectral_kpoint_mp_grid 17 17 17 Here is a param file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file si-dos.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task dos ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed We can then run castep and use the tool dos.pl to plot a bandstructure with Xmgrace. To see all of the functionality run 'dos.pl -h' castep si-dos dos.pl -xg si-dos.bands -w 0.3 You should get a plot like Note The procedure above is inefficient as we computed the groundstate of the system twice, once when computing the bandstructure and again when computing the dos. To avoid this we could put the following line in the si-dos.param file continuation: si-bands.check . This will restart the calculation of the dos using the previously computed groundstate.","title":"Density of States"},{"location":"tutorials/Bands_and_DOS/plotting_sumo/","text":"This is stub for https://github.com/ajjackson/castep-sumo-tutorial/blob/master/castep-sumo.org","title":"Plotting - SUMO"},{"location":"tutorials/Bands_and_DOS/semiconductors/","text":"In this tutorial we will show you the cell and param files needed to plot bandstructures and density of states plots for various semiconductors. For the commands needed to make the plots refer to earlier tutorials. Silicon ! Si.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 ! Specify a path through the Brillouin Zone to compute the band structure. ! %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path ! Si.cell task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed Note Silicon is a semiconductor with a small gap between the occupied (blue) and unoccupied states (brown). The gap is indirect as the valence band maximum is as Gamma, but the conduction band minimum lies between Gamma and X. Gallium Arsenide The cell file is almost identical to the silicon example above, except that the unitc cell length is slighly larger, and we have replaced one Si atom with Ga, and the other Si with As. ! GaAs.cell %block lattice_abc 4 4 4 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Ga 0.00 0.00 0.00 As 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 ! Specify a path through the Brillouin Zone to compute the band structure. ! %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path The param file is unchanged from the Silicon example ! GaAs.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed Note GaAs is a semiconductor with a small gap between the occupied (blue) and unoccupied states (brown). The gap is direct both the valence band maximum and conduction band minimum are at Gamma. Compared with Silicon we see that the original bandstructure contains low lying flat bands at around -32eV and -12eV. This is because both the Ga and As pseudopotentials include semi-core states in the valence. The red states are the As 3d and the green are the Ga 3d.","title":"Semiconductors"},{"location":"tutorials/Bands_and_DOS/semiconductors/#silicon","text":"! Si.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 ! Specify a path through the Brillouin Zone to compute the band structure. ! %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path ! Si.cell task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed Note Silicon is a semiconductor with a small gap between the occupied (blue) and unoccupied states (brown). The gap is indirect as the valence band maximum is as Gamma, but the conduction band minimum lies between Gamma and X.","title":"Silicon"},{"location":"tutorials/Bands_and_DOS/semiconductors/#gallium-arsenide","text":"The cell file is almost identical to the silicon example above, except that the unitc cell length is slighly larger, and we have replaced one Si atom with Ga, and the other Si with As. ! GaAs.cell %block lattice_abc 4 4 4 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Ga 0.00 0.00 0.00 As 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 ! Specify a path through the Brillouin Zone to compute the band structure. ! %block spectral_kpoint_path 0.5 0.25 0.75 ! W 0.5 0.5 0.5 ! L 0.0 0.0 0.0 ! Gamma 0.5 0.0 0.5 ! X 0.5 0.25 0.75 ! W 0.375 0.375 0.75 ! K %endblock spectral_kpoint_path The param file is unchanged from the Silicon example ! GaAs.param task spectral ! The TASK keyword instructs CASTEP what to do spectral_task bandstructure ! xc_functional LDA ! Which exchange-correlation functional to use. cut_off_energy 500 eV ! opt_strategy speed ! Choose algorithms for best speed Note GaAs is a semiconductor with a small gap between the occupied (blue) and unoccupied states (brown). The gap is direct both the valence band maximum and conduction band minimum are at Gamma. Compared with Silicon we see that the original bandstructure contains low lying flat bands at around -32eV and -12eV. This is because both the Ga and As pseudopotentials include semi-core states in the valence. The red states are the As 3d and the green are the Ga 3d.","title":"Gallium Arsenide"},{"location":"tutorials/Bonding_and_Charge/charge_density/","text":"In this tutorial we will walk through plotting a charge density with Vesta https://jp-minerals.org/vesta/en/ Silicon Here is a cell file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file silicon.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 Here is a param file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file silicon.param xc_functional : LDA cutoff_energy : 1500 eV #this next line causes the charge to be written in a den_fmt file write_formatted_density : T spin_polarised : false The cutoff energy is somewhat higher than needed for a converged total energy - but it helps when making a smoother looking charge density plot. Run castep. You will see a file called silicon.den_fmt this contains the charge density in a formatted (i.e. a human readable, ASCII file). We need to change this file into a format Vesta can read. Copy it to a file called silicon.charg_frm cp silicon.den_fmt silicon.charg_frm Now edit the file silicon.charg_frm with a text editor to remove the first 11 lines. The file should now begin with 1 1 1 and a number. You can now open silicon.charg_frm with Vesta. Note that Vesta needs both the cell and charge_frm files to make a plot. If you are working on a remote machine you will need to copy both of these back to your local machine to view with Vesta. You can find a walkthrough video of this process at https://youtu.be/_c2Hk4jxmm4 An alternative way to plot charge densities (and much more besides) is c2x https://www.c2x.org.uk","title":"Plotting Charge Density"},{"location":"tutorials/Bonding_and_Charge/charge_density/#silicon","text":"Here is a cell file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file silicon.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 Here is a param file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file silicon.param xc_functional : LDA cutoff_energy : 1500 eV #this next line causes the charge to be written in a den_fmt file write_formatted_density : T spin_polarised : false The cutoff energy is somewhat higher than needed for a converged total energy - but it helps when making a smoother looking charge density plot. Run castep. You will see a file called silicon.den_fmt this contains the charge density in a formatted (i.e. a human readable, ASCII file). We need to change this file into a format Vesta can read. Copy it to a file called silicon.charg_frm cp silicon.den_fmt silicon.charg_frm Now edit the file silicon.charg_frm with a text editor to remove the first 11 lines. The file should now begin with 1 1 1 and a number. You can now open silicon.charg_frm with Vesta. Note that Vesta needs both the cell and charge_frm files to make a plot. If you are working on a remote machine you will need to copy both of these back to your local machine to view with Vesta. You can find a walkthrough video of this process at https://youtu.be/_c2Hk4jxmm4 An alternative way to plot charge densities (and much more besides) is c2x https://www.c2x.org.uk","title":"Silicon"},{"location":"tutorials/Bonding_and_Charge/mulliken_population/","text":"By default castep will calculate the Mulliken Population analysis at the end of every calculation (the keyword popn_calculate is set to true by default). Silicon Here is a cell file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file silicon.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 Here is a param file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file silicon.param xc_functional : LDA cutoff_energy : 500 eV spin_polarised : false Run castep. Toward the end of the file silicon.castep you will find Atomic Populations (Mulliken) ----------------------------- Species Ion s p d f Total Charge (e) ========================================================================== Si 1 1.356 2.644 0.000 0.000 4.000 0.000 Si 2 1.356 2.644 0.000 0.000 4.000 0.000 ========================================================================== Bond Population Length (A) ====================================================================== Si 1 -- Si 2 2.99 2.32702 ====================================================================== The atoms are not charged overall, and there is a large bond population. This is all indicative of a strong covalent bond. To finish","title":"Population Analysis"},{"location":"tutorials/Bonding_and_Charge/mulliken_population/#silicon","text":"Here is a cell file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file silicon.cell %block lattice_abc 3.8 3.8 3.8 60 60 60 %endblock lattice_abc ! ! Atomic co-ordinates for each species. ! These are in fractional co-ordinates wrt to the cell. ! %block positions_frac Si 0.00 0.00 0.00 Si 0.25 0.25 0.25 %endblock positions_frac ! ! Analyse structure to determine symmetry ! symmetry_generate ! ! Specify M-P grid dimensions for electron wavevectors (K-points) ! kpoint_mp_grid 4 4 4 Here is a param file. You can use the icon in the top right of the box to copy and paste the text. Save it in a file silicon.param xc_functional : LDA cutoff_energy : 500 eV spin_polarised : false Run castep. Toward the end of the file silicon.castep you will find Atomic Populations (Mulliken) ----------------------------- Species Ion s p d f Total Charge (e) ========================================================================== Si 1 1.356 2.644 0.000 0.000 4.000 0.000 Si 2 1.356 2.644 0.000 0.000 4.000 0.000 ========================================================================== Bond Population Length (A) ====================================================================== Si 1 -- Si 2 2.99 2.32702 ====================================================================== The atoms are not charged overall, and there is a large bond population. This is all indicative of a strong covalent bond.","title":"Silicon"},{"location":"tutorials/Bonding_and_Charge/mulliken_population/#to-finish","text":"","title":"To finish"},{"location":"tutorials/NMR/NMR_shielding/","text":"We now start running castep calculations by looking at two small systems, and examining the issue of \"convergence\". Example 1 - Ethanol CH 3 CH 2 OH The discovery that one could actually see chemical shifts in hydrogen spectra was made in 1951 at Stanford University by Packard, Arnold, Dharmatti (shown below). We will try to reproduce this result. Fig1. Proton spectrum of ethanol Files ethanol.cell ethanol.param OBJECTIVES: Examine the convergence of the chemical shieldings with planewave cutoff Compare to experiment. INSTRUCTIONS: Look at the cell and param file. Note that the only special keyword is task = magres. Run castep. Look at the output file. At the end the isotropic chemical shielding, anisotropy, and asymmetry are reported (here we are only interested in the isotropic value.) This information, plus the full tensors is also given in the file ethanol.magres You might wish to transfer the *.magres file back to your desktop to visualise with MagresView Examine the effect of increasing the cutoff energy (say 20-50 Ryd in steps of 10 Ryd). It always helps to plot a graph of the convergence (eg with gnuplot or xmgrace on the cluster - or with excel on the pc) Find the \"converged\" hydrogen (or proton in NMR language) shieldings. We will compare them to experiment. The three methyl (CH3) protons undergo fast exchange; they \"rotate\" faster than the nuclear magnetic moment processes. The magnetic moment will therefore \"see\" an average chemical shielding. The same is true of the CH2 protons. Average the CH 3 and CH 2 chemical shieldings. This will give you 3 unique chemical shieldings. We now need to convert the chemical shieldings \u03c3 iso to chemical shifts \u03b4 iso on the experimental scale. We use the relation: \\delta_{iso}=\\sigma_{ref}-\\sigma_{iso} \\delta_{iso}=\\sigma_{ref}-\\sigma_{iso} , A suitable \u03c3 ref for 1H is 30.97ppm. %block rframe width=200px padding=10px%\\ %width=180px%Attach:nmr_tut2.png Fig1. Proton spectrum of liquid ethanol.%% Fig 2 shows a modern high-resolution 1H spectrum for liquid ethanol. Note that the peaks are split due to J-coupling - the interaction of the 1H magnetic moments - but let's ignore that for now. The three peaks are roughly at 1.2ppm, 3.7ppm and 5ppm. You should find that your computed values agree for two sites. Do you know why the other site has such a large disagreement with experiment? Example 2 - Diamond FILES: *diamond.cell *diamond.param OBJECTIVES: * Examine the convergence of the chemical shielding as the sampling of the electronic Brillouin zone (BZ) is increased. INSTRUCTIONS: * Look at the files diamond.cell and diamond.param * We have specified the kpoints in the cell file using the keyword kpoints_mp_grid 4 4 4 * Run CASTEP for a range of kpoint meshes (say 2,4,6,8,10) * Examine (plot?) the convergence of the chemical shielding. The computational cost scales linearly with the number of kpoints (ie the number of points in the irreducible Brillouin Zone). For a large unit cell (ie a small BZ) it may be possible to get converged results using a single k-point. But which kpoint should we choose? For diamond we will look at 3 different k-points (0,0,0), (\u00bd,\u00bd,\u00bd) (\u00bc,\u00bc,\u00bc). Specify the kpoint in the cell file using %BLOCK KPOINTS_LIST 0.25 0.25 0.25 1.0 %ENDBLOCK KPOINTS_LIST Which gives a result closest to the converged answer? (as the diamond unit cell is rather small the 1 kpoint answer is not too close to converged. However, the observation holds true for all orthorhombic cells) PART 3 We now look at some more realistic examples. Oxygen-17 Oxygen is a component of many geological materials. Oxygen is also important element in organic and biological molecules since it is often intimately involved in hydrogen bonding. Solid State 17 O NMR should be a uniquely valuable probe as the chemical shift range of 17 O covers almost 1000 ppm in organic molecules. Furthermore 17 O has spin I = 5/2 and hence a net quadrupole moment. As a consequence of this the solid state NMR spectrum is strongly affected by the electric field gradient at the nucleus. Because the isotopic abundance of 17 O is very low (0.037%) and the NMR linewidths due to the electric field gradient relatively large, only limited Solid State NMR data is available. This is particularly true for organic materials. First principles calculations of 17 O NMR parameters have played a vital role in assigning experimental spectra, and developing empirical rules between NMR parameters and local atomic structure. Example 3 - Alanine, a simple amino acid FILES: *alanine.cell *alanine.param *alanine.pdb OBJECTIVES: Compute the chemical shift and Electric field gradient for alanine Assign the 17 NMR spectrum %block rframe width=200px padding=10px%\\ %width=180px%Attach:nmr_tut3.png Fig3. Solid-State O17 NMR spectrum of L-alanine. (b) is from MAS (magicangle- spinning) \u00a9 is from DOR (double-orientation rotation)%% INSTRUCTIONS: *Look at the cell and param files. The geometry for alanine was obtained by neutron diffraction and was downloaded from the Cambridge Crystallographic database. View the original pdb file note the hydrogen bonding Run the example - the calculation is not fully converged. However, the relative shift between the two sites is fairly converged. The experimental 17 O NMR spectrum shows two peaks (Fig 3 (b)) - they are very broad due to the quadrupolar coupling, and overlap. The experimental parameters are given in Table 1. Assign the two resonances A and B. Do all three computed parameters support this assignment? ||border=1 width=50% ||\u03b4(A)-\u03b4 (B) (ppm)|| 23.5|| ||C Q (A) (MHz)|| 7.86|| ||\u03b7 Q (A)|| 0.28|| ||C Q (A) (MHz)|| 6.53|| ||\u03b7 Q (A)|| 0.70|| Table 1: Experimental 17 O NMR parameters for alanine. The two resonances are labeled A and B. Isotropic chemical shift \u03b4 , quadrupolar coupling C Q , and EFG asymmetry \u03b7 Q . Example 4 - Silicates Quartz and Cristoballite FILES: *quartz.cell *quartz.param *crist.cell *crist.param OBJECTIVES: * Compute the chemical shift and Electric field gradient for two silicates. * Assign the 17 O NMR spectrum INSTRUCTIONS: * The 17 O parameters for two silicates are reported in Table 2. From the values you compute can you tell which one is quartz? (a suitable \u03c3 ref is 263ppm) ||border=1 width=50% || || \u03b4 (ppm) || C Q (MHz) || \u03b7 Q || ||Material A|| 37.2 || 5.21 || 0.13 || ||Material B|| 40.8 || 5.19 || 0.19 || Table 2: Experimental 17O NMR parameters for two silicates. Isotropic chemical shift \u03b4 , quadrupolar coupling C Q , and EFG asymmetry \u03b7 Q .","title":"NMR shielding"},{"location":"tutorials/NMR/NMR_shielding/#example-1-ethanol-ch3ch2oh","text":"The discovery that one could actually see chemical shifts in hydrogen spectra was made in 1951 at Stanford University by Packard, Arnold, Dharmatti (shown below). We will try to reproduce this result. Fig1. Proton spectrum of ethanol Files ethanol.cell ethanol.param OBJECTIVES: Examine the convergence of the chemical shieldings with planewave cutoff Compare to experiment. INSTRUCTIONS: Look at the cell and param file. Note that the only special keyword is task = magres. Run castep. Look at the output file. At the end the isotropic chemical shielding, anisotropy, and asymmetry are reported (here we are only interested in the isotropic value.) This information, plus the full tensors is also given in the file ethanol.magres You might wish to transfer the *.magres file back to your desktop to visualise with MagresView Examine the effect of increasing the cutoff energy (say 20-50 Ryd in steps of 10 Ryd). It always helps to plot a graph of the convergence (eg with gnuplot or xmgrace on the cluster - or with excel on the pc) Find the \"converged\" hydrogen (or proton in NMR language) shieldings. We will compare them to experiment. The three methyl (CH3) protons undergo fast exchange; they \"rotate\" faster than the nuclear magnetic moment processes. The magnetic moment will therefore \"see\" an average chemical shielding. The same is true of the CH2 protons. Average the CH 3 and CH 2 chemical shieldings. This will give you 3 unique chemical shieldings. We now need to convert the chemical shieldings \u03c3 iso to chemical shifts \u03b4 iso on the experimental scale. We use the relation: \\delta_{iso}=\\sigma_{ref}-\\sigma_{iso} \\delta_{iso}=\\sigma_{ref}-\\sigma_{iso} , A suitable \u03c3 ref for 1H is 30.97ppm. %block rframe width=200px padding=10px%\\ %width=180px%Attach:nmr_tut2.png Fig1. Proton spectrum of liquid ethanol.%% Fig 2 shows a modern high-resolution 1H spectrum for liquid ethanol. Note that the peaks are split due to J-coupling - the interaction of the 1H magnetic moments - but let's ignore that for now. The three peaks are roughly at 1.2ppm, 3.7ppm and 5ppm. You should find that your computed values agree for two sites. Do you know why the other site has such a large disagreement with experiment?","title":"Example 1 - Ethanol CH3CH2OH"},{"location":"tutorials/NMR/NMR_shielding/#example-2-diamond","text":"FILES: *diamond.cell *diamond.param OBJECTIVES: * Examine the convergence of the chemical shielding as the sampling of the electronic Brillouin zone (BZ) is increased. INSTRUCTIONS: * Look at the files diamond.cell and diamond.param * We have specified the kpoints in the cell file using the keyword kpoints_mp_grid 4 4 4 * Run CASTEP for a range of kpoint meshes (say 2,4,6,8,10) * Examine (plot?) the convergence of the chemical shielding. The computational cost scales linearly with the number of kpoints (ie the number of points in the irreducible Brillouin Zone). For a large unit cell (ie a small BZ) it may be possible to get converged results using a single k-point. But which kpoint should we choose? For diamond we will look at 3 different k-points (0,0,0), (\u00bd,\u00bd,\u00bd) (\u00bc,\u00bc,\u00bc). Specify the kpoint in the cell file using %BLOCK KPOINTS_LIST 0.25 0.25 0.25 1.0 %ENDBLOCK KPOINTS_LIST Which gives a result closest to the converged answer? (as the diamond unit cell is rather small the 1 kpoint answer is not too close to converged. However, the observation holds true for all orthorhombic cells)","title":"Example 2 - Diamond"},{"location":"tutorials/NMR/NMR_shielding/#part-3","text":"We now look at some more realistic examples.","title":"PART 3"},{"location":"tutorials/NMR/NMR_shielding/#oxygen-17","text":"Oxygen is a component of many geological materials. Oxygen is also important element in organic and biological molecules since it is often intimately involved in hydrogen bonding. Solid State 17 O NMR should be a uniquely valuable probe as the chemical shift range of 17 O covers almost 1000 ppm in organic molecules. Furthermore 17 O has spin I = 5/2 and hence a net quadrupole moment. As a consequence of this the solid state NMR spectrum is strongly affected by the electric field gradient at the nucleus. Because the isotopic abundance of 17 O is very low (0.037%) and the NMR linewidths due to the electric field gradient relatively large, only limited Solid State NMR data is available. This is particularly true for organic materials. First principles calculations of 17 O NMR parameters have played a vital role in assigning experimental spectra, and developing empirical rules between NMR parameters and local atomic structure.","title":"Oxygen-17"},{"location":"tutorials/NMR/NMR_shielding/#example-3-alanine-a-simple-amino-acid","text":"FILES: *alanine.cell *alanine.param *alanine.pdb OBJECTIVES: Compute the chemical shift and Electric field gradient for alanine Assign the 17 NMR spectrum %block rframe width=200px padding=10px%\\ %width=180px%Attach:nmr_tut3.png Fig3. Solid-State O17 NMR spectrum of L-alanine. (b) is from MAS (magicangle- spinning) \u00a9 is from DOR (double-orientation rotation)%% INSTRUCTIONS: *Look at the cell and param files. The geometry for alanine was obtained by neutron diffraction and was downloaded from the Cambridge Crystallographic database. View the original pdb file note the hydrogen bonding Run the example - the calculation is not fully converged. However, the relative shift between the two sites is fairly converged. The experimental 17 O NMR spectrum shows two peaks (Fig 3 (b)) - they are very broad due to the quadrupolar coupling, and overlap. The experimental parameters are given in Table 1. Assign the two resonances A and B. Do all three computed parameters support this assignment? ||border=1 width=50% ||\u03b4(A)-\u03b4 (B) (ppm)|| 23.5|| ||C Q (A) (MHz)|| 7.86|| ||\u03b7 Q (A)|| 0.28|| ||C Q (A) (MHz)|| 6.53|| ||\u03b7 Q (A)|| 0.70|| Table 1: Experimental 17 O NMR parameters for alanine. The two resonances are labeled A and B. Isotropic chemical shift \u03b4 , quadrupolar coupling C Q , and EFG asymmetry \u03b7 Q .","title":"Example 3 - Alanine, a simple amino acid"},{"location":"tutorials/NMR/NMR_shielding/#example-4-silicates-quartz-and-cristoballite","text":"FILES: *quartz.cell *quartz.param *crist.cell *crist.param OBJECTIVES: * Compute the chemical shift and Electric field gradient for two silicates. * Assign the 17 O NMR spectrum INSTRUCTIONS: * The 17 O parameters for two silicates are reported in Table 2. From the values you compute can you tell which one is quartz? (a suitable \u03c3 ref is 263ppm) ||border=1 width=50% || || \u03b4 (ppm) || C Q (MHz) || \u03b7 Q || ||Material A|| 37.2 || 5.21 || 0.13 || ||Material B|| 40.8 || 5.19 || 0.19 || Table 2: Experimental 17O NMR parameters for two silicates. Isotropic chemical shift \u03b4 , quadrupolar coupling C Q , and EFG asymmetry \u03b7 Q .","title":"Example 4 - Silicates Quartz and Cristoballite"},{"location":"tutorials/dispersion_corrections/castep-ase-dispersion-tutorial/","text":"Interlayer binding energy of graphite Here we'll explore the van der Waals interaction that holds sheets of graphene together to form graphite. We will see how a standard semi-local density functional approximation fails to predict the correct interlayer binding energy in graphite and how we can do better using semi-empirical dispersion corrections in CASTEP. For this tutorial we will use the CASTEP-ASE interface to setup and run many short calculations and analyse the results, though you can of course adapt the content here to use a scripting language of your choice. I have broken up the parts of the script to add clarification in places, but you can download the jupyter notebook with all the cells here . We start by importing several python libraries. For more information on using the atomic simulation environment (ASE) with CASTEP, see the documentation here . # ASE version 3.22.1 from ase.io import read , write from ase.calculators.castep import Castep from ase.io.castep import read_seed from ase.visualize import view # pandas version 1.3.4 import pandas as pd # castep.mpi on path already, version 21.11 castep_cmd = 'mpirun -n 4 castep.mpi' # plotting from matplotlib import pyplot as plt % matplotlib inline # Python version: 3.9.5 For this tutorial I will use CASTEP version 21.11. See here for a list of the different dispersion correction schemes and which version of CASTEP they are available from. Separation of layers: setup and run the calculations The script below loops over several different dispersion corrections schemes and, for each one, calculates the total energy of a 4-atom graphite cell at several different values of the c lattice constant. This effectively increases the interlayer spacing between the sheets of graphene. By separating them far enough apart, we can estimate the interlayer binding energy predicte by each method. The script took about 10 minutes to run using 4 cores on a relatively powerful laptop. You can decrease the k-point sampling or basis set precision, or loop over fewer methods or c parameters in order to speed things up. # run in this directorsy directory = 'separate-layers-tutorial/' # k-point grid # -- try coarser grid if this is too slow, # but higher if you want more reliable results! kpts = [ 13 , 13 , 5 ] # xc functional to use xc = 'PBE' # range of unit c parameters in Angstroms (interlayer spacings are half these!) crange = [ 4 , 5 , 6 , 6.25 , 6.5 , 6.75 , 7 , 7.25 , 7.5 , 8.5 , 10 , 14 , 16 ] #SEDC correction schemes to try: schemes = [ '' , 'G06' , 'D3' , 'D3-BJ' , 'TS' , 'MBD' , 'XDM' ] # pandas dataframe to store the results df = pd . DataFrame ({ 'crange' : crange }) # loop over the different correction schemes for sedc_scheme in schemes : print ( ' \\n ' , 50 * '=' ) print ( f ' { xc } + { sedc_scheme } \\n ' ) # list to temporarily hold the total energy for each calculation energies = [] # loop over c parameters: for c in crange : label = f ' { xc } - { sedc_scheme } - { c : 3.2f } ' try : graphite = read_seed ( directory + label ) except : # if the calculation doesn't already exist, we set it up and # run it # read in cif file (taken from here: https://materialsproject.org/materials/mp-48 ) graphite = read ( 'C_mp-48_primitive.cif' ) # we could make a supercell to get more accurate results for TS, MBD and XDM schemes. # graphite = graphite * (3,3,1) # scale c parameter to new value cellpar = graphite . cell . cellpar () cellpar [ 2 ] = c graphite . set_cell ( cellpar , scale_atoms = True ) # set up castep calculator calc = Castep ( xc = xc , kpts = kpts , label = label , castep_command = castep_cmd , basis_precision = 'precise' , # switch to something cheaper (e.g. FINE) to speed things up for this example.. directory = directory , write_checkpoint = 'None' , # don't need the checkpoint files now write_cst_esp = False , # don't need the electrostatic potential file now write_bands = False , # don't need the bands file now _rename_existing_dir = False , # allows us to write all these calculations to the same directory... symmetry_generate = True , # use symmetry to speed up the calculation snap_to_symmetry = True , # enforce symmetry ) # Switch on the SEDC flags if sedc_scheme != '' : calc . param . sedc_apply = True calc . param . sedc_scheme = sedc_scheme # For the XDM scheme we need to set this manually # otherwise the calculation crashes... if sedc_scheme == 'XDM' : calc . param . SEDC_SC_XDM = 1.0 graphite . set_calculator ( calc ) e = graphite . get_potential_energy () energies . append ( e ) print ( f ' { c : 8.3f } A \\t { e : 12.8f } eV' ) # save the energy wrt to furthest energy: energies = [ e - energies [ - 1 ] for e in energies ] df [ f ' { xc } - { sedc_scheme } ' ] = energies # Save to a .csv file: df . to_csv ( 'graphite_layer_separation.csv' ) The .param files generated look something like this: WRITE_CST_ESP: FALSE WRITE_BANDS: FALSE WRITE_CHECKPOINT: None XC_FUNCTIONAL: PBE SEDC_APPLY: TRUE SEDC_SCHEME: D3 # or TS or D3-BJ etc. BASIS_PRECISION: precise The task defaults to SINGLEPOINT (which is what we want in this case). The .cell files simply have the crystal structure in which the cell is scaled in the c direction. Read in and analyse the results We can now read in and analyse the results from the previous step. Reading the data into a pandas dataframe object is convenient. df = pd . read_csv ( './graphite_layer_separation.csv' ) # scale by 1000 / 4 to get the energies per atom and in units of meV dfdiff = ( df . iloc [:, 1 :]) * 1000 / 4 # energy per atom in meV # the c parmeter is 2x the interlayer spacing, d dfdiff [ 'c/2' ] = df [ 'crange' ] / 2 styles = [ f ' { m } -' for m in [ \"o\" , \"v\" , \"^\" , \"s\" , \"+\" , \"x\" , \"D\" ]] # compared to this refence (and many others!) https://doi.org/10.1039/C3RA47187J ax = dfdiff . plot ( x = 'c/2' , y = [ 'PBE-' , 'PBE-G06' , 'PBE-D3' , 'PBE-D3-BJ' , 'PBE-TS' , 'PBE-MBD' , 'PBE-XDM' ], ylabel = 'energy/atom (meV)' , ylim = ( - 100 , 80 ), xlabel = r 'interlayer spacing d ( = c/2) (${\\AA}$)' , figsize = ( 16 , 10 ), style = styles , ) ax . axhline ( 0 , color = '0.3' ) ax . axvline ( 3.355 , ls = '--' , color = '0.4' ) # Experimental binding energies reported shown in the figure are 31 \u00b1 2, 43, 52 \u00b1 5 and 35 (+15 to \u201310) meV per atom ax . axhspan ( ymin =- 57 , ymax =- 25 , color = '0.8' , alpha = 0.5 ) ax . set_title ( 'graphite interlayer binding energy' ) plt . savefig ( 'graphite-interlayer-binding-castep-dispersions.png' ) which produces the following figure: where the dashed vertical line is the experimental interlayer spacing and the shaded grey region is the range of experimentally obtained interlayer binding energies. Please note that these are not fully converged calculations and so do not represent the actual performance of these methods but is simply a guide for how to use them with CASTEP. We can see that the plain PBE functional severely underestimates the binding energy of graphite and that many of the dispersion-corrected results are in much better agreement. The TS scheme strongly overbinds graphite, but has been found to be accurate for other types of systems. Testing such methods carefully is always required when you encounter a new system. Further suggestions CASTEP writes out a warning for the TS, MBD and XDM schemes about the unit cell being too small for accurate corrections. Try repeat the above calculations for these three methods using a larger supercell to see what the effect is and what sized supercell you would need to converge the dispersion correction. For the D3 and D3-BJ methods, try to switch on the three-body interaction term by setting: %BLOCK devel_code d3_threebody TRUE %ENDBLOCK devel_code in the .param file. What effect does this have on the interlayer binding energy in graphite? (You may also want to set IPRINT = 2 to see more information about the dispersion correction parameters.) Compare to other XC functionals with and without the dispersion corrections (though note that of the corrections are only parameterised for a few functionals .)","title":"Dispersion corrections"},{"location":"tutorials/dispersion_corrections/castep-ase-dispersion-tutorial/#interlayer-binding-energy-of-graphite","text":"Here we'll explore the van der Waals interaction that holds sheets of graphene together to form graphite. We will see how a standard semi-local density functional approximation fails to predict the correct interlayer binding energy in graphite and how we can do better using semi-empirical dispersion corrections in CASTEP. For this tutorial we will use the CASTEP-ASE interface to setup and run many short calculations and analyse the results, though you can of course adapt the content here to use a scripting language of your choice. I have broken up the parts of the script to add clarification in places, but you can download the jupyter notebook with all the cells here . We start by importing several python libraries. For more information on using the atomic simulation environment (ASE) with CASTEP, see the documentation here . # ASE version 3.22.1 from ase.io import read , write from ase.calculators.castep import Castep from ase.io.castep import read_seed from ase.visualize import view # pandas version 1.3.4 import pandas as pd # castep.mpi on path already, version 21.11 castep_cmd = 'mpirun -n 4 castep.mpi' # plotting from matplotlib import pyplot as plt % matplotlib inline # Python version: 3.9.5 For this tutorial I will use CASTEP version 21.11. See here for a list of the different dispersion correction schemes and which version of CASTEP they are available from.","title":"Interlayer binding energy of graphite"},{"location":"tutorials/dispersion_corrections/castep-ase-dispersion-tutorial/#separation-of-layers-setup-and-run-the-calculations","text":"The script below loops over several different dispersion corrections schemes and, for each one, calculates the total energy of a 4-atom graphite cell at several different values of the c lattice constant. This effectively increases the interlayer spacing between the sheets of graphene. By separating them far enough apart, we can estimate the interlayer binding energy predicte by each method. The script took about 10 minutes to run using 4 cores on a relatively powerful laptop. You can decrease the k-point sampling or basis set precision, or loop over fewer methods or c parameters in order to speed things up. # run in this directorsy directory = 'separate-layers-tutorial/' # k-point grid # -- try coarser grid if this is too slow, # but higher if you want more reliable results! kpts = [ 13 , 13 , 5 ] # xc functional to use xc = 'PBE' # range of unit c parameters in Angstroms (interlayer spacings are half these!) crange = [ 4 , 5 , 6 , 6.25 , 6.5 , 6.75 , 7 , 7.25 , 7.5 , 8.5 , 10 , 14 , 16 ] #SEDC correction schemes to try: schemes = [ '' , 'G06' , 'D3' , 'D3-BJ' , 'TS' , 'MBD' , 'XDM' ] # pandas dataframe to store the results df = pd . DataFrame ({ 'crange' : crange }) # loop over the different correction schemes for sedc_scheme in schemes : print ( ' \\n ' , 50 * '=' ) print ( f ' { xc } + { sedc_scheme } \\n ' ) # list to temporarily hold the total energy for each calculation energies = [] # loop over c parameters: for c in crange : label = f ' { xc } - { sedc_scheme } - { c : 3.2f } ' try : graphite = read_seed ( directory + label ) except : # if the calculation doesn't already exist, we set it up and # run it # read in cif file (taken from here: https://materialsproject.org/materials/mp-48 ) graphite = read ( 'C_mp-48_primitive.cif' ) # we could make a supercell to get more accurate results for TS, MBD and XDM schemes. # graphite = graphite * (3,3,1) # scale c parameter to new value cellpar = graphite . cell . cellpar () cellpar [ 2 ] = c graphite . set_cell ( cellpar , scale_atoms = True ) # set up castep calculator calc = Castep ( xc = xc , kpts = kpts , label = label , castep_command = castep_cmd , basis_precision = 'precise' , # switch to something cheaper (e.g. FINE) to speed things up for this example.. directory = directory , write_checkpoint = 'None' , # don't need the checkpoint files now write_cst_esp = False , # don't need the electrostatic potential file now write_bands = False , # don't need the bands file now _rename_existing_dir = False , # allows us to write all these calculations to the same directory... symmetry_generate = True , # use symmetry to speed up the calculation snap_to_symmetry = True , # enforce symmetry ) # Switch on the SEDC flags if sedc_scheme != '' : calc . param . sedc_apply = True calc . param . sedc_scheme = sedc_scheme # For the XDM scheme we need to set this manually # otherwise the calculation crashes... if sedc_scheme == 'XDM' : calc . param . SEDC_SC_XDM = 1.0 graphite . set_calculator ( calc ) e = graphite . get_potential_energy () energies . append ( e ) print ( f ' { c : 8.3f } A \\t { e : 12.8f } eV' ) # save the energy wrt to furthest energy: energies = [ e - energies [ - 1 ] for e in energies ] df [ f ' { xc } - { sedc_scheme } ' ] = energies # Save to a .csv file: df . to_csv ( 'graphite_layer_separation.csv' ) The .param files generated look something like this: WRITE_CST_ESP: FALSE WRITE_BANDS: FALSE WRITE_CHECKPOINT: None XC_FUNCTIONAL: PBE SEDC_APPLY: TRUE SEDC_SCHEME: D3 # or TS or D3-BJ etc. BASIS_PRECISION: precise The task defaults to SINGLEPOINT (which is what we want in this case). The .cell files simply have the crystal structure in which the cell is scaled in the c direction.","title":"Separation of layers: setup and run the calculations"},{"location":"tutorials/dispersion_corrections/castep-ase-dispersion-tutorial/#read-in-and-analyse-the-results","text":"We can now read in and analyse the results from the previous step. Reading the data into a pandas dataframe object is convenient. df = pd . read_csv ( './graphite_layer_separation.csv' ) # scale by 1000 / 4 to get the energies per atom and in units of meV dfdiff = ( df . iloc [:, 1 :]) * 1000 / 4 # energy per atom in meV # the c parmeter is 2x the interlayer spacing, d dfdiff [ 'c/2' ] = df [ 'crange' ] / 2 styles = [ f ' { m } -' for m in [ \"o\" , \"v\" , \"^\" , \"s\" , \"+\" , \"x\" , \"D\" ]] # compared to this refence (and many others!) https://doi.org/10.1039/C3RA47187J ax = dfdiff . plot ( x = 'c/2' , y = [ 'PBE-' , 'PBE-G06' , 'PBE-D3' , 'PBE-D3-BJ' , 'PBE-TS' , 'PBE-MBD' , 'PBE-XDM' ], ylabel = 'energy/atom (meV)' , ylim = ( - 100 , 80 ), xlabel = r 'interlayer spacing d ( = c/2) (${\\AA}$)' , figsize = ( 16 , 10 ), style = styles , ) ax . axhline ( 0 , color = '0.3' ) ax . axvline ( 3.355 , ls = '--' , color = '0.4' ) # Experimental binding energies reported shown in the figure are 31 \u00b1 2, 43, 52 \u00b1 5 and 35 (+15 to \u201310) meV per atom ax . axhspan ( ymin =- 57 , ymax =- 25 , color = '0.8' , alpha = 0.5 ) ax . set_title ( 'graphite interlayer binding energy' ) plt . savefig ( 'graphite-interlayer-binding-castep-dispersions.png' ) which produces the following figure: where the dashed vertical line is the experimental interlayer spacing and the shaded grey region is the range of experimentally obtained interlayer binding energies. Please note that these are not fully converged calculations and so do not represent the actual performance of these methods but is simply a guide for how to use them with CASTEP. We can see that the plain PBE functional severely underestimates the binding energy of graphite and that many of the dispersion-corrected results are in much better agreement. The TS scheme strongly overbinds graphite, but has been found to be accurate for other types of systems. Testing such methods carefully is always required when you encounter a new system.","title":"Read in and analyse the results"},{"location":"tutorials/dispersion_corrections/castep-ase-dispersion-tutorial/#further-suggestions","text":"CASTEP writes out a warning for the TS, MBD and XDM schemes about the unit cell being too small for accurate corrections. Try repeat the above calculations for these three methods using a larger supercell to see what the effect is and what sized supercell you would need to converge the dispersion correction. For the D3 and D3-BJ methods, try to switch on the three-body interaction term by setting: %BLOCK devel_code d3_threebody TRUE %ENDBLOCK devel_code in the .param file. What effect does this have on the interlayer binding energy in graphite? (You may also want to set IPRINT = 2 to see more information about the dispersion correction parameters.) Compare to other XC functionals with and without the dispersion corrections (though note that of the corrections are only parameterised for a few functionals .)","title":"Further suggestions"},{"location":"workshop/00_starting/","text":"Connecting to the Arcus Cluster in Oxford We will use mobaXterm to connect to the arcus cluster. This uses Xwindows and ssh . You will find mobaXterm in the H: drive on your machine. Click on the Session icon. Choose ssh . Enter arc-login.arc.ox.ac.uk as the remote host and enter the username given to you (e.g. teaching99 ). Click OK and it will then prompt you for your ARC password. Do not allow the computer to save your password You are connected to the arcus Cluster!! Running your first cluster job For this very first example you are going to submit a castep job to the queuing system. This will take place in the following steps: Creating a working area and copying some example code into it Preparing and and submitting the job Checking the output All the things which you should type are in bold and your Linux prompt is always shown as: [teaching01@arc-login01 ~]$ i.e. you do not need to type [teaching01@arc-login01 ~]$ Step 0 Copy over the environment [teaching01@arc-login01 ~]$ cp /home/jryates/WORKSHOP/bash_profile_castep $HOME/.bash_profile Note carefully the dot ( . ) before the second bash and the fact that the above is all on one line. Now you've copied the environment you need to activate it: source $HOME/.bash_profile Step 1 Copying the examples into a working area. Firstly, let's create a temporary working area to do the examples in. This is usually a good idea for every distinct problem you're working on as it keeps things tidy and manageable. We'll create a directory (or folder in Windows parlance) called intro using the Linux command mkdir [teaching01@arc-login01 ~]$ mkdir intro Now check that your intro directory has been made properly by listing the directory (or folder) you are already in: [teaching01@arc-login01 ~]$ ls and you should see a list of files and directories including the new examples directory. Now let's move into that directory: [teaching01@arc-login01 ~]$ cd intro Note that cd is the Linux command for changing directories. You can move back to your home directory at any time by typing cd just on its own. You can check your current directory at anytime with the pwd command: [teaching01@arc-login01 ~]$ pwd If you run ls in the examples directory, nothing is listed as there are no files yet (try it). Let's copy the example code from one directory (provided by the tutors) to your current location. Note the space between the * and . : [teaching01@arc-login01 ~]$ cp /home/jryates/WORKSHOP/intro/* . Do NOT forget the . character. To Linux this means \"my current directory\". So you are copying (with the cp command) all files (represented by * ) in the directory /home/jryates/WORKSHOP/intro to your current directory. Now try an ls to see what you've got. You should see several files: [teaching01@arc-login01 ~]$ ls diamond.cell diamond.param These are the usual .cell and .param castep input files. To look at the files you can use the command called more (similar commands are cat and less ) [teaching01@arc-login01 ~]$ more diamond.cell Step 2 - Preparing & submitting a job Now we are ready to submit the job to the queue. The special command castepsub is used for this. We\u2019ve written this command specially for the workshop - on your local cluster there will be a different (but very similar) way to submit jobs to the cluster. [teaching01@arc-login01 ~]$ castepsub -n 4 diamond This will have submitted your job to the cluster to run on 4 processors. Use ls to to list your files. It should take only a few seconds to run. You can then examine the castep output file diamond.castep . Note how many kpoints were used. Rename the .castep file [teaching01@arc-login01 ~]$ mv diamond.castep diamond_200ev.castep Editing a file Edit the diamond.param file (increase the cutoff energy to 400 eV). To do this you will need to use an editor. (for experts vi and emacs are available). Otherwise I suggest using an editor called nano . This has helpful list of instructions are the bottom of the screen (but ask if you are confused!) [teaching01@arc-login01 ~]$ nano diamond.param Now submit the job again. Compare the runs at 200 and 400eV. Which took longer? Has the total energy gone up or down. Look at the Atomic Populations section - is it what you expect? Summary of useful commands mv - rename (or move) a file eg. mv oldfile newfile cp - copy a file eg. cp original copy pwd - print current (working) directory mkdir - make a new directory (aka folder) nano - a file editor eg. nano filename . Note you can use this to edit an existing file, or to create a new file. eg nano mynewfile will create a new file called mynewfile ls - list files in the current directory ls -l - list files - but give more details than plain ls exit - to close the terminal when you are finished cp fred/* jim/ - copy all the files in the folder fred into the folder jim cp ../myfile ./ - copy the file myfile in the folder below to the current folder cp ~/myfile ./ - copy the file myfile in your home folder to the current folder squeue - look at the list of jobs running and queued on the cluster squeue -u teachingXX - look at the list of jobs running for the user teachingXX castepsub -n 8 diamond - submits a castep job with diamond.cell and diamond.param as inputs onto 8 cores with a time limit of 1 hour castepsub -n 8 -W 00:20:00 - as above but only run for 20 minutes c2x This is a handy free program written by Michael Rutter (TCM group Cambridge). It can convert castep.cell and castep.check files into various formats eg .cell , .pdb . (and many other things!) c2x -h - list all the options c2x --pdbn castep.cell castep.pdb c2x --pdbn castep.check castep.pdb c2x --cell castep.check new.cell (useful at the end of geometry optimisation)","title":"0 Logging on"},{"location":"workshop/00_starting/#connecting-to-the-arcus-cluster-in-oxford","text":"We will use mobaXterm to connect to the arcus cluster. This uses Xwindows and ssh . You will find mobaXterm in the H: drive on your machine. Click on the Session icon. Choose ssh . Enter arc-login.arc.ox.ac.uk as the remote host and enter the username given to you (e.g. teaching99 ). Click OK and it will then prompt you for your ARC password. Do not allow the computer to save your password You are connected to the arcus Cluster!!","title":"Connecting to the Arcus Cluster in Oxford"},{"location":"workshop/00_starting/#running-your-first-cluster-job","text":"For this very first example you are going to submit a castep job to the queuing system. This will take place in the following steps: Creating a working area and copying some example code into it Preparing and and submitting the job Checking the output All the things which you should type are in bold and your Linux prompt is always shown as: [teaching01@arc-login01 ~]$ i.e. you do not need to type [teaching01@arc-login01 ~]$","title":"Running your first cluster job"},{"location":"workshop/00_starting/#step-0","text":"Copy over the environment [teaching01@arc-login01 ~]$ cp /home/jryates/WORKSHOP/bash_profile_castep $HOME/.bash_profile Note carefully the dot ( . ) before the second bash and the fact that the above is all on one line. Now you've copied the environment you need to activate it: source $HOME/.bash_profile","title":"Step 0"},{"location":"workshop/00_starting/#step-1","text":"Copying the examples into a working area. Firstly, let's create a temporary working area to do the examples in. This is usually a good idea for every distinct problem you're working on as it keeps things tidy and manageable. We'll create a directory (or folder in Windows parlance) called intro using the Linux command mkdir [teaching01@arc-login01 ~]$ mkdir intro Now check that your intro directory has been made properly by listing the directory (or folder) you are already in: [teaching01@arc-login01 ~]$ ls and you should see a list of files and directories including the new examples directory. Now let's move into that directory: [teaching01@arc-login01 ~]$ cd intro Note that cd is the Linux command for changing directories. You can move back to your home directory at any time by typing cd just on its own. You can check your current directory at anytime with the pwd command: [teaching01@arc-login01 ~]$ pwd If you run ls in the examples directory, nothing is listed as there are no files yet (try it). Let's copy the example code from one directory (provided by the tutors) to your current location. Note the space between the * and . : [teaching01@arc-login01 ~]$ cp /home/jryates/WORKSHOP/intro/* . Do NOT forget the . character. To Linux this means \"my current directory\". So you are copying (with the cp command) all files (represented by * ) in the directory /home/jryates/WORKSHOP/intro to your current directory. Now try an ls to see what you've got. You should see several files: [teaching01@arc-login01 ~]$ ls diamond.cell diamond.param These are the usual .cell and .param castep input files. To look at the files you can use the command called more (similar commands are cat and less ) [teaching01@arc-login01 ~]$ more diamond.cell","title":"Step 1"},{"location":"workshop/00_starting/#step-2-preparing-submitting-a-job","text":"Now we are ready to submit the job to the queue. The special command castepsub is used for this. We\u2019ve written this command specially for the workshop - on your local cluster there will be a different (but very similar) way to submit jobs to the cluster. [teaching01@arc-login01 ~]$ castepsub -n 4 diamond This will have submitted your job to the cluster to run on 4 processors. Use ls to to list your files. It should take only a few seconds to run. You can then examine the castep output file diamond.castep . Note how many kpoints were used. Rename the .castep file [teaching01@arc-login01 ~]$ mv diamond.castep diamond_200ev.castep","title":"Step 2 - Preparing &amp; submitting a job"},{"location":"workshop/00_starting/#editing-a-file","text":"Edit the diamond.param file (increase the cutoff energy to 400 eV). To do this you will need to use an editor. (for experts vi and emacs are available). Otherwise I suggest using an editor called nano . This has helpful list of instructions are the bottom of the screen (but ask if you are confused!) [teaching01@arc-login01 ~]$ nano diamond.param Now submit the job again. Compare the runs at 200 and 400eV. Which took longer? Has the total energy gone up or down. Look at the Atomic Populations section - is it what you expect?","title":"Editing a file"},{"location":"workshop/00_starting/#summary-of-useful-commands","text":"mv - rename (or move) a file eg. mv oldfile newfile cp - copy a file eg. cp original copy pwd - print current (working) directory mkdir - make a new directory (aka folder) nano - a file editor eg. nano filename . Note you can use this to edit an existing file, or to create a new file. eg nano mynewfile will create a new file called mynewfile ls - list files in the current directory ls -l - list files - but give more details than plain ls exit - to close the terminal when you are finished cp fred/* jim/ - copy all the files in the folder fred into the folder jim cp ../myfile ./ - copy the file myfile in the folder below to the current folder cp ~/myfile ./ - copy the file myfile in your home folder to the current folder squeue - look at the list of jobs running and queued on the cluster squeue -u teachingXX - look at the list of jobs running for the user teachingXX castepsub -n 8 diamond - submits a castep job with diamond.cell and diamond.param as inputs onto 8 cores with a time limit of 1 hour castepsub -n 8 -W 00:20:00 - as above but only run for 20 minutes","title":"Summary of useful commands"},{"location":"workshop/00_starting/#c2x","text":"This is a handy free program written by Michael Rutter (TCM group Cambridge). It can convert castep.cell and castep.check files into various formats eg .cell , .pdb . (and many other things!) c2x -h - list all the options c2x --pdbn castep.cell castep.pdb c2x --pdbn castep.check castep.pdb c2x --cell castep.check new.cell (useful at the end of geometry optimisation)","title":"c2x"},{"location":"workshop/01_bonding/","text":"Learning Objectives Introduction to CASTEP input and output files. Running on the Arcus machine at Oxford University. Introduction The aim of this exercise is to familiarise you with CASTEP input and output files and running the code, some associated utilities and conversion programs. You will run some simple and small CASTEP calculations on canonical examples of covalently and ionically bonded materials - silicon and sodium chloride - and use the results to study the bonding from an electronic structure perspective. While performing the exercises try to think about the reasons for each step, and about how to interpret the results. The point of the exercise is not merely to reach the end but to learn the path. The exercise below contains a number of questions. Please take note when a question is asked of you, and think about the answer. Feel free to discuss the answer with one of the demonstrators after you have thought about it for a while. The secondary aim of this exercise is to learn to run programs on Oxford University's Arcus cluster. This is a powerful parallel computer. (Although the runs in this first exercise should take only seconds on a desktop.) For information about how to login to and use this cluster please refer to the instructions provided. ` Where To Find Help If you want more information about a particular CASTEP keyword, or you want to find if CASTEP has particular functionality, there are a few places you can look. There is information on this website: www.castep.org . CASTEP has an in built help option to assist with using particular keywords. Information on using CASTEP can be seen by using: $ castep --help To get more information on a particular input file keyword (e.g. kpoint_mp_grid ) use: $ castep --help kpoints_mp_grid If you don't know the keyword you need to use, then you can search on a particular keyword. This returns a list of keywords that you might be interested in, e.g. to look at all keywords which contain a reference to symmetry. $ castep --search symmetry Finally, to list all keywords, use: $ castep --search all Note that the long-form arguments --help and --search can optionally be replaced with -h and -s , respectively. Example 1 - Silicon Download the files to arcus $ wget http://www.castep.org/files/Si2.tgz Unzip and untar them, then move into the new directory $ gunzip Si2.tgz $ tar -xvf Si2.tar $ cd Si2 Examine the CASTEP input files Si2.cell and Si2.param using your favourite text editor (e.g. nano ). The Si_00.usp file is a pseudopotential file, you do not need to understand it at the moment. $ nano Si2.cell $ nano Si2.param It is useful to view the structure before submitting your calculation using CASTEP. Copy the Si2.cell to your local machine using the sftp window (left) in mobaXterm. Cell Structure Visualisation Jmol To open the Si2.cell file using Jmol : Open Jmol (You will need to copy it from the h: drive to your desktop. Then double click jmol.jar ) then use File => Open and navigate to your Si2.cell file. Alternatively, you can drag and drop the Si2.cell file into the Jmol window, and Jmol will open it. It can be helpful to view multiple repeat units of your unit cell. The easiest way to do this in Jmol is to open a console window, click File => Console and type: $ load \"\" { 2 2 2 } to show a 2x2x2 supercell. Check the geometry of the input file is what you expect it to be before moving onto the next step. Vesta To open the Si2.cell file using VESTA : Open VESTA (You will need to copy it from the h: drive to your desktop. Then double click VESTA.exe ) then use File => Open and navigate to your Si2.cell file. You cannot drag and drop into VESTA. If you wish to create a supercell as above, use Objects => Boundary . Then edit the maximum and/or minimum values of x, y, and z in order to change your boundaries. Setting x(max) , y(max) , and z(max) to 2 will create the 2 by 2 by 2 supercell as above. Check the geometry of the input file is as expected before moving on to the next step. Now run CASTEP on Arcus using the 2-atom input files. $ castepsub -n 1 Si2 This should only take a few seconds and produce a readable output file Si2.castep . Examine this file and try to understand the meaning of the various parts. In particular check the section following the header which lists all of the input parameters, both explicit and default. Note what default values of the major parameters CASTEP chose where you did not specify them explicitly. (There will be some whose meaning has not been explained. Don't worry about these.) Find the section of the file which monitors the SCF loop and the approach to convergence. How many SCF iterations did it need? Copy the output files Si2.castep and Si2.den_fmt to the local machine using sftp . Visualisation of the charge density Jmol Jmol can also be used to view the isodensity map, open the .castep file by dragging and dropping the Si2.castep file into the Jmol window. Open the Jmol console (File => Console) and type the following commands: $ load \"\" { 2 2 2 } $ isosurface rho cutoff 14 \"Si2.den_fmt\" lattice { 2 2 2 } Note: you can use the cd command within Jmol to navigate to the folder with your .castep files. Jmol uses forward slash for paths to files on windows and linux based machines. This Si2.den_fmt file is a formatted file produced by CASTEP that contains the value of the electron density on a grid of points. This isosurface command in Jmol plots an isodensity surface over your atomic positions. Vesta You will see a file called Si2.den_fmt which contains the charge density in a formatted (i.e. a human readable, ASCII file). We need to change this file into a format Vesta can read. Copy it to a file called Si2.charg_frm cp Si2.den_fmt Si2.charg_frm Now edit the file Si2.charg_frm with a text editor to remove the first 11 lines. The file should now begin with 1 1 1 and a number. You can now open Si2.charg_frm with Vesta. Note that Vesta needs both the .cell and .charge_frm files to make a plot. If you are working on a remote machine you will need to copy both of these back to your local machine to view with Vesta. You can find a walkthrough video of this process here . An alternative way to plot charge densities (and much more besides) is c2x . Answer the following questions: Can you explain what you see as you vary the isosurface value? Can you see any features which might be characteristic of a covalently-bonded crystal. Do you notice anything strange about the electron density close to the Si nucleus? Can you explain this as a consequence of the particular kind of electronic structure calculation you have just performed? Repeat steps 1-8 using input files for sodium chloride and aluminium. $ wget http://www.castep.org/files/Al.tgz $ wget http://www.castep.org/files/NaCl.tgz Think about the following questions: Note what similarities and differences you find compared to silicon? Does this help explain the difference in bond chemistry between silicon, sodium chloride and aluminium? Does this help explain why there are many reasonable classical potential functions for NaCl to be found in the simulation literature, but that finding good potentials for silicon is a very tough challenge? What about aluminium, can you find good potentials for aluminium?","title":"1 Bonding   "},{"location":"workshop/01_bonding/#learning-objectives","text":"Introduction to CASTEP input and output files. Running on the Arcus machine at Oxford University.","title":"Learning Objectives"},{"location":"workshop/01_bonding/#introduction","text":"The aim of this exercise is to familiarise you with CASTEP input and output files and running the code, some associated utilities and conversion programs. You will run some simple and small CASTEP calculations on canonical examples of covalently and ionically bonded materials - silicon and sodium chloride - and use the results to study the bonding from an electronic structure perspective. While performing the exercises try to think about the reasons for each step, and about how to interpret the results. The point of the exercise is not merely to reach the end but to learn the path. The exercise below contains a number of questions. Please take note when a question is asked of you, and think about the answer. Feel free to discuss the answer with one of the demonstrators after you have thought about it for a while. The secondary aim of this exercise is to learn to run programs on Oxford University's Arcus cluster. This is a powerful parallel computer. (Although the runs in this first exercise should take only seconds on a desktop.) For information about how to login to and use this cluster please refer to the instructions provided. `","title":"Introduction"},{"location":"workshop/01_bonding/#where-to-find-help","text":"If you want more information about a particular CASTEP keyword, or you want to find if CASTEP has particular functionality, there are a few places you can look. There is information on this website: www.castep.org . CASTEP has an in built help option to assist with using particular keywords. Information on using CASTEP can be seen by using: $ castep --help To get more information on a particular input file keyword (e.g. kpoint_mp_grid ) use: $ castep --help kpoints_mp_grid If you don't know the keyword you need to use, then you can search on a particular keyword. This returns a list of keywords that you might be interested in, e.g. to look at all keywords which contain a reference to symmetry. $ castep --search symmetry Finally, to list all keywords, use: $ castep --search all Note that the long-form arguments --help and --search can optionally be replaced with -h and -s , respectively.","title":"Where To Find Help"},{"location":"workshop/01_bonding/#example-1-silicon","text":"Download the files to arcus $ wget http://www.castep.org/files/Si2.tgz Unzip and untar them, then move into the new directory $ gunzip Si2.tgz $ tar -xvf Si2.tar $ cd Si2 Examine the CASTEP input files Si2.cell and Si2.param using your favourite text editor (e.g. nano ). The Si_00.usp file is a pseudopotential file, you do not need to understand it at the moment. $ nano Si2.cell $ nano Si2.param It is useful to view the structure before submitting your calculation using CASTEP. Copy the Si2.cell to your local machine using the sftp window (left) in mobaXterm. Cell Structure Visualisation","title":"Example 1 - Silicon"},{"location":"workshop/01_bonding/#jmol","text":"To open the Si2.cell file using Jmol : Open Jmol (You will need to copy it from the h: drive to your desktop. Then double click jmol.jar ) then use File => Open and navigate to your Si2.cell file. Alternatively, you can drag and drop the Si2.cell file into the Jmol window, and Jmol will open it. It can be helpful to view multiple repeat units of your unit cell. The easiest way to do this in Jmol is to open a console window, click File => Console and type: $ load \"\" { 2 2 2 } to show a 2x2x2 supercell. Check the geometry of the input file is what you expect it to be before moving onto the next step.","title":"Jmol"},{"location":"workshop/01_bonding/#vesta","text":"To open the Si2.cell file using VESTA : Open VESTA (You will need to copy it from the h: drive to your desktop. Then double click VESTA.exe ) then use File => Open and navigate to your Si2.cell file. You cannot drag and drop into VESTA. If you wish to create a supercell as above, use Objects => Boundary . Then edit the maximum and/or minimum values of x, y, and z in order to change your boundaries. Setting x(max) , y(max) , and z(max) to 2 will create the 2 by 2 by 2 supercell as above. Check the geometry of the input file is as expected before moving on to the next step. Now run CASTEP on Arcus using the 2-atom input files. $ castepsub -n 1 Si2 This should only take a few seconds and produce a readable output file Si2.castep . Examine this file and try to understand the meaning of the various parts. In particular check the section following the header which lists all of the input parameters, both explicit and default. Note what default values of the major parameters CASTEP chose where you did not specify them explicitly. (There will be some whose meaning has not been explained. Don't worry about these.) Find the section of the file which monitors the SCF loop and the approach to convergence. How many SCF iterations did it need? Copy the output files Si2.castep and Si2.den_fmt to the local machine using sftp . Visualisation of the charge density","title":"Vesta"},{"location":"workshop/01_bonding/#jmol_1","text":"Jmol can also be used to view the isodensity map, open the .castep file by dragging and dropping the Si2.castep file into the Jmol window. Open the Jmol console (File => Console) and type the following commands: $ load \"\" { 2 2 2 } $ isosurface rho cutoff 14 \"Si2.den_fmt\" lattice { 2 2 2 } Note: you can use the cd command within Jmol to navigate to the folder with your .castep files. Jmol uses forward slash for paths to files on windows and linux based machines. This Si2.den_fmt file is a formatted file produced by CASTEP that contains the value of the electron density on a grid of points. This isosurface command in Jmol plots an isodensity surface over your atomic positions.","title":"Jmol"},{"location":"workshop/01_bonding/#vesta_1","text":"You will see a file called Si2.den_fmt which contains the charge density in a formatted (i.e. a human readable, ASCII file). We need to change this file into a format Vesta can read. Copy it to a file called Si2.charg_frm cp Si2.den_fmt Si2.charg_frm Now edit the file Si2.charg_frm with a text editor to remove the first 11 lines. The file should now begin with 1 1 1 and a number. You can now open Si2.charg_frm with Vesta. Note that Vesta needs both the .cell and .charge_frm files to make a plot. If you are working on a remote machine you will need to copy both of these back to your local machine to view with Vesta. You can find a walkthrough video of this process here . An alternative way to plot charge densities (and much more besides) is c2x .","title":"Vesta"},{"location":"workshop/01_bonding/#answer-the-following-questions","text":"Can you explain what you see as you vary the isosurface value? Can you see any features which might be characteristic of a covalently-bonded crystal. Do you notice anything strange about the electron density close to the Si nucleus? Can you explain this as a consequence of the particular kind of electronic structure calculation you have just performed? Repeat steps 1-8 using input files for sodium chloride and aluminium. $ wget http://www.castep.org/files/Al.tgz $ wget http://www.castep.org/files/NaCl.tgz","title":"Answer the following questions:"},{"location":"workshop/01_bonding/#think-about-the-following-questions","text":"Note what similarities and differences you find compared to silicon? Does this help explain the difference in bond chemistry between silicon, sodium chloride and aluminium? Does this help explain why there are many reasonable classical potential functions for NaCl to be found in the simulation literature, but that finding good potentials for silicon is a very tough challenge? What about aluminium, can you find good potentials for aluminium?","title":"Think about the following questions:"},{"location":"workshop/02_bands_dos/","text":"Learning Objectives Gain awareness and familiarity with the tools available to produce band structure and density of states plots with CASTEP. Investigate how band structures differ for metallic and semiconductor systems differ. Running spin polarised calculations in CASTEP. Note This tutorial we will be running on Arcus, you should be able to complete this tutorial without copying files backwards and forwards; however if you wish to visualise your system (e.g. using VESTA) then you will need to copy files to your local machine to do so. If you don't remember how to do this, remind yourself by referring to Tutorial 0 and Tutorial 1 Xterminals, Plotting and other computational hassle To save some effort transferring files backwards and forwards to and from Arcus we are going to use Arcus to plot the band structure and DOS and send the image to your monitor. Introduction The aim of this tutorial is to enable you to compute band structures using CASTEP and introduce you to a few of the tools which allow you to visualise the band structure and density of electronic states computed using CASTEP. The band structure of metals and semiconductors will be plotted so that you can look at the differences between different types of systems. First you will look at the CASTEP input files (.cell and .param) used to produce band structure information. Next you will use the perl script dispersion.pl which can be used to take CASTEP output and plot band structure diagrams. Then you will use orbitals2bands. A tool which provides more information about the orbitals that contribute to different bands in your band structure diagram. Finally you will look at the band structure of iron, to show how magnetic systems can be studied using CASTEP, you will also plot the density of states of iron using dos.pl. You will need: In addition to CASTEP and the suite of tools it comes with you will need: Grace - A 2D plotting program. Perl - a scripting language. These are available on the Arcus cluster. Example files: Download the input files wget http://www.castep.org/files/bandstructure.tgz Then untar and unzip it using: gunzip bandstructure.tgz tar -xvf bandstructure.tar Example 1 - Graphite. Move into the graphite directory, look at the CASTEP .cell and .param files and notice the differences from the previous single point energy runs. To the .param file the task (which lets CASTEP know what you want it to do) needs to be changed to: task : bandstructure The .cell file requires a path through the Brillouin Zone along which you want the bandstructure to be plotted: %BLOCK BS_KPOINT_PATH 0.0000 0.00000 0.00000 ! G 0.0000 0.00000 0.50000 ! A -0.3333 0.66667 0.50000 ! H -0.3333 0.66667 0.00000 ! K 0.0000 0.00000 0.00000 ! G 0.0000 0.50000 0.00000 ! M 0.0000 0.50000 0.50000 ! L -0.3333 0.66667 0.50000 ! H %ENDBLOCK BS_KPOINT_PATH Run CASTEP using: $ castepsub -n 16 graphite Once the CASTEP calculation has finished a graphite.bands file will be present in the directory. A band structure plot can be viewed by using the dispersion.pl tool. $ dispersion.pl -xg -bs -symmetry hexagonal graphite.bands The -xg option tells dispersion.pl that you are using grace to plot the band structure, the -bs option tells the script that you want to plot using CASTEP output files, the -symmetry hexagonal option labels the high symmetry points on the bands structure plot. When you view this band structure plot you will notice the bands are coloured from lowest to highest energy. Using information about the wavefunction CASTEP can improve this band structure plot, so bands are coloured due to the orbitals that contribute. The orbitals2bands tool can be used to alter the Si.bands file represent the orbitals that contribute to the bands. This tool can be run in the same directory that you ran CASTEP in. The program orbitals2bands overwrites your Si.bands file, so it's best to copy it to another file to preserve it $ cp graphite.bands graphite.bands.orig $ orbitals2bandssub -n 16 graphite orbitals2bandssub is a wrapper, similar to castepsub to run orbitals2bands on the compute nodes on arc . Example 2 - Silicon and Aluminium. Very similar to example 1, but this time comparing a semiconductor and a metal, both with FCC crystal structures. Go into the silicon and aluminium directories and compute the band structures as above. The dispersion symmetry option needs to be told that these are FCC materials, not hexagonal. Compare the band structure of the Silicon and Aluminium crystals. What are the main similarities and differences? Can you explain this using your knowledge of the bonding in these materials? Example 3 - Iron In the iron directory there is a set of input files for iron. As iron is a magnetic system you need to instruct CASTEP that it is spin polarised. You also need to set up the calculation with the total spin set to a non-zero value, in order to find the magnetic ground state. (If you're interested you could try removing the spin : 1 line from the Fe.param file and see what happens). You set the spin in the .param file: spin : 1 spin_polarised : true The path through the Brillouin Zone is found in the Fe.cell file. Run the iron computation using CASTEP and plot the band structure for iron using dispersion.pl . You might find the -mono option to dispersion.pl to be useful - it colours the bands by spin channel. Iron's Density of States To plot the density of states of iron, we need to run CASTEP again, instead of computing the band structure along a high symmetry line, we compute it on a grid. To your Fe.cell file, remove the bs_kpoint_path block and replace it with: BS_KPOINT_MP_GRID 12 12 12 Run CASTEP using these new input files then use the dos.pl plotting script dos.pl -xg -bs -w 0.2 Fe.bands Can you relate the features in the DOS to those in the Bandstructure? You might find the -mirror option useful. The -w option sets the Gaussian broadening in eV. Try smaller (0.05) and larger (0.5) values - explain what you see. DOS for the other crystals in this tutorial can be computed in a similar way. Further work a) Compute the band-structure of hexagonal monolayer boron nitride. What is the key difference to graphene? b) MoS2 has attracted much recent interest. What is its structure? Can you make a cell file for this (if not ask). What about its band structure - metal or insulator, direct vs indirect gap.","title":"2 Bandstructure and DOS"},{"location":"workshop/02_bands_dos/#learning-objectives","text":"Gain awareness and familiarity with the tools available to produce band structure and density of states plots with CASTEP. Investigate how band structures differ for metallic and semiconductor systems differ. Running spin polarised calculations in CASTEP.","title":"Learning Objectives"},{"location":"workshop/02_bands_dos/#note","text":"This tutorial we will be running on Arcus, you should be able to complete this tutorial without copying files backwards and forwards; however if you wish to visualise your system (e.g. using VESTA) then you will need to copy files to your local machine to do so. If you don't remember how to do this, remind yourself by referring to Tutorial 0 and Tutorial 1","title":"Note"},{"location":"workshop/02_bands_dos/#xterminals-plotting-and-other-computational-hassle","text":"To save some effort transferring files backwards and forwards to and from Arcus we are going to use Arcus to plot the band structure and DOS and send the image to your monitor.","title":"Xterminals, Plotting and other computational hassle"},{"location":"workshop/02_bands_dos/#introduction","text":"The aim of this tutorial is to enable you to compute band structures using CASTEP and introduce you to a few of the tools which allow you to visualise the band structure and density of electronic states computed using CASTEP. The band structure of metals and semiconductors will be plotted so that you can look at the differences between different types of systems. First you will look at the CASTEP input files (.cell and .param) used to produce band structure information. Next you will use the perl script dispersion.pl which can be used to take CASTEP output and plot band structure diagrams. Then you will use orbitals2bands. A tool which provides more information about the orbitals that contribute to different bands in your band structure diagram. Finally you will look at the band structure of iron, to show how magnetic systems can be studied using CASTEP, you will also plot the density of states of iron using dos.pl.","title":"Introduction"},{"location":"workshop/02_bands_dos/#you-will-need","text":"In addition to CASTEP and the suite of tools it comes with you will need: Grace - A 2D plotting program. Perl - a scripting language. These are available on the Arcus cluster.","title":"You will need:"},{"location":"workshop/02_bands_dos/#example-files","text":"Download the input files wget http://www.castep.org/files/bandstructure.tgz Then untar and unzip it using: gunzip bandstructure.tgz tar -xvf bandstructure.tar","title":"Example files:"},{"location":"workshop/02_bands_dos/#example-1-graphite","text":"Move into the graphite directory, look at the CASTEP .cell and .param files and notice the differences from the previous single point energy runs. To the .param file the task (which lets CASTEP know what you want it to do) needs to be changed to: task : bandstructure The .cell file requires a path through the Brillouin Zone along which you want the bandstructure to be plotted: %BLOCK BS_KPOINT_PATH 0.0000 0.00000 0.00000 ! G 0.0000 0.00000 0.50000 ! A -0.3333 0.66667 0.50000 ! H -0.3333 0.66667 0.00000 ! K 0.0000 0.00000 0.00000 ! G 0.0000 0.50000 0.00000 ! M 0.0000 0.50000 0.50000 ! L -0.3333 0.66667 0.50000 ! H %ENDBLOCK BS_KPOINT_PATH Run CASTEP using: $ castepsub -n 16 graphite Once the CASTEP calculation has finished a graphite.bands file will be present in the directory. A band structure plot can be viewed by using the dispersion.pl tool. $ dispersion.pl -xg -bs -symmetry hexagonal graphite.bands The -xg option tells dispersion.pl that you are using grace to plot the band structure, the -bs option tells the script that you want to plot using CASTEP output files, the -symmetry hexagonal option labels the high symmetry points on the bands structure plot. When you view this band structure plot you will notice the bands are coloured from lowest to highest energy. Using information about the wavefunction CASTEP can improve this band structure plot, so bands are coloured due to the orbitals that contribute. The orbitals2bands tool can be used to alter the Si.bands file represent the orbitals that contribute to the bands. This tool can be run in the same directory that you ran CASTEP in. The program orbitals2bands overwrites your Si.bands file, so it's best to copy it to another file to preserve it $ cp graphite.bands graphite.bands.orig $ orbitals2bandssub -n 16 graphite orbitals2bandssub is a wrapper, similar to castepsub to run orbitals2bands on the compute nodes on arc .","title":"Example 1 - Graphite."},{"location":"workshop/02_bands_dos/#example-2-silicon-and-aluminium","text":"Very similar to example 1, but this time comparing a semiconductor and a metal, both with FCC crystal structures. Go into the silicon and aluminium directories and compute the band structures as above. The dispersion symmetry option needs to be told that these are FCC materials, not hexagonal. Compare the band structure of the Silicon and Aluminium crystals. What are the main similarities and differences? Can you explain this using your knowledge of the bonding in these materials?","title":"Example 2 - Silicon and Aluminium."},{"location":"workshop/02_bands_dos/#example-3-iron","text":"In the iron directory there is a set of input files for iron. As iron is a magnetic system you need to instruct CASTEP that it is spin polarised. You also need to set up the calculation with the total spin set to a non-zero value, in order to find the magnetic ground state. (If you're interested you could try removing the spin : 1 line from the Fe.param file and see what happens). You set the spin in the .param file: spin : 1 spin_polarised : true The path through the Brillouin Zone is found in the Fe.cell file. Run the iron computation using CASTEP and plot the band structure for iron using dispersion.pl . You might find the -mono option to dispersion.pl to be useful - it colours the bands by spin channel.","title":"Example 3 - Iron"},{"location":"workshop/02_bands_dos/#irons-density-of-states","text":"To plot the density of states of iron, we need to run CASTEP again, instead of computing the band structure along a high symmetry line, we compute it on a grid. To your Fe.cell file, remove the bs_kpoint_path block and replace it with: BS_KPOINT_MP_GRID 12 12 12 Run CASTEP using these new input files then use the dos.pl plotting script dos.pl -xg -bs -w 0.2 Fe.bands Can you relate the features in the DOS to those in the Bandstructure? You might find the -mirror option useful. The -w option sets the Gaussian broadening in eV. Try smaller (0.05) and larger (0.5) values - explain what you see. DOS for the other crystals in this tutorial can be computed in a similar way.","title":"Iron's Density of States"},{"location":"workshop/02_bands_dos/#further-work","text":"a) Compute the band-structure of hexagonal monolayer boron nitride. What is the key difference to graphene? b) MoS2 has attracted much recent interest. What is its structure? Can you make a cell file for this (if not ask). What about its band structure - metal or insulator, direct vs indirect gap.","title":"Further work"},{"location":"workshop/03_geometry/","text":"Geometry Optimisation Exercise 1 - Dihydrogen dimer In this tutorial we will model the bond length of a H2 molecule. This will give you the opportunity to get used to geometry optimisations and gain familiarity Remember you can use castep --help to assist you with finding the appropriate input parameters. Create a new file, H2.cell using your favourite text editor, e.g. nano H2.cell Start by creating a lattice block in your cell file. %block lattice_abc 5 5 5 90 90 90 %endblock lattice_abc or %block lattice_cart 5 0 0 0 5 0 0 0 5 %endblock lattice_cart Will produce a cube 5 Angstroms long on each side. NOTE: ONLY USE ONE OF THESE TWO FORMATS Q: Is this a big enough box to represent a molecule? (Recall Periodic Boundary Conditions) A: You may wish to test this by changing the size of the box. Add atoms into our cell. This can be done either relative to the lattice vectors using %block positions_frac H 0.5 0.5 0.5 H 0.5 0.5 0.2 %endblock positions_frac or relative to the origin of the cell file %block positions_abs H 3 3 3 H 3 3 4 %endblock positions_abs Q: If you are varying the size of your unit cell for tests, which one will be more convenient? Add final components to unit cell fix_all_cell: true kpoint_mp_grid: 1 1 1 Q: Why do we only want to use a single k-point? Q: Why do we want to fix the lattice parameters rather than letting them relax? Now close H2.cell and create a H2.param file. In H2.param add Task: GeometryOptimisation XC_Functional: LDA Cut_Off_Energy: 300 If you want to get Castep to automatically print out the final structure, you can also add write_cell_structure: true You can now use castepsub to submit your geometry optimisation! Results Analysis Scroll down through the file. Check to see how the forces and bond-length varies over iterations. For advanced bash users, try grep \"F|max\" H2.castep to extract this from the file. You may also want to visualise the H2.cell and (if you tolda castep to print it) the H2-out.cell files as in previous tutorials Finally, consider watching the optimisation by drag-and-dropping the H2.geom file into Jmol (VESTA will not animate it) The experimental H2 bond length is about 0.74 Angstroms. How does your result compare? Extension A may give some insight into this! Extensions You may wish to split these between groups and discuss the results A. Functional Choice So far you've used the local density approximation (LDA) for the exchange-correlation functional in this exercise. Repeat your calculation with the PBE exchange-correlation functional (a popular GGA): xc_functional : PBE You may also want to consider a hybrid functional such as HSE06 or the meta-GGA RSCAN B. More Precise Structural Optimisations You may wish to have more precise structure for certain calculations such as NMR or Phonons . These may be controlled in the .param file with geom_force_tol: 0.05 eV/ang geom_energy_tol: 2e-5 eV geom_stress_tol: 0.1 GPa geom_disp_tol: 0.001 ang These are the default values; what happens to your final values when you alter them? Hint: You have fixed the lattice - what will stress do? C. Wavefunction Convergence If you have a bad wavefunction you will get bad forces. To demonstrate this try adding elec_energy_tol: 0.1 This overwrites the default of 0.00001 ev and will make the SCF convergence very fast. What does this do to the geometry optimisation? NOTE: This is not something you want to do in practice! Hopefully working through this example will demonstrate why. Exercise 2 Run a geometry optimisation on silicon. You can use a silicon input file from one of the previous tutorials as a starting point for your input files. Set CASTEP's parameters to perform a geometry optimisation using a 160 eV plane-wave cut-off energy and an 8x8x8 Monkhorst-Pack k-point grid: In Si2.param : task : geometry optimisation cut_off_energy : 160 eV In Si2.cell : kpoints_MP_grid 8 8 8 Because you're going to change the lattice vectors, CASTEP will do a finite basis-set correction (FBSC); this will calculate and print out dEtotal/dlog(Ecut) \u2013 anything more than 0.1 eV/atom is big and a sign of incomplete convergence. Q: What is the final lattice parameter? Do convergence tests (cut_off_energy, kpoints etc). The experimental lattice constant is 3.84 Angstrom - how does your value compare? What is the difference in your results between calculations using an LDA and a PBE exchange-correlation functional? Exercise 3 - Graphene It can be useful to know how to construct a monolayer material, such as graphene. This requires the use of cell constraints so that we force a large distance between periodic images (and we don't have the system collapse to form graphite!) In your .cell file: %block cell_constraints 1 1 0 3 4 5 %endblock cell_constraints Will force the a and b lattice parameters to be the same (though free to vary jointly), fix the c lattice vector, and let all angles relax independently. This is similar to the %block lattice_abc structure you saw earlier. For the mathematically minded, this is taking the limit that the interlayer spacing, controlled by the out-of-plane lattice vector, goes to infinity! Practically, we cannot actually set the lattice parameter to infinity - try varying it and seeing how it converges with distance.","title":"3 Geometry Optimisation"},{"location":"workshop/03_geometry/#geometry-optimisation","text":"","title":"Geometry Optimisation"},{"location":"workshop/03_geometry/#exercise-1-dihydrogen-dimer","text":"In this tutorial we will model the bond length of a H2 molecule. This will give you the opportunity to get used to geometry optimisations and gain familiarity Remember you can use castep --help to assist you with finding the appropriate input parameters. Create a new file, H2.cell using your favourite text editor, e.g. nano H2.cell Start by creating a lattice block in your cell file. %block lattice_abc 5 5 5 90 90 90 %endblock lattice_abc or %block lattice_cart 5 0 0 0 5 0 0 0 5 %endblock lattice_cart Will produce a cube 5 Angstroms long on each side. NOTE: ONLY USE ONE OF THESE TWO FORMATS Q: Is this a big enough box to represent a molecule? (Recall Periodic Boundary Conditions) A: You may wish to test this by changing the size of the box. Add atoms into our cell. This can be done either relative to the lattice vectors using %block positions_frac H 0.5 0.5 0.5 H 0.5 0.5 0.2 %endblock positions_frac or relative to the origin of the cell file %block positions_abs H 3 3 3 H 3 3 4 %endblock positions_abs Q: If you are varying the size of your unit cell for tests, which one will be more convenient? Add final components to unit cell fix_all_cell: true kpoint_mp_grid: 1 1 1 Q: Why do we only want to use a single k-point? Q: Why do we want to fix the lattice parameters rather than letting them relax? Now close H2.cell and create a H2.param file. In H2.param add Task: GeometryOptimisation XC_Functional: LDA Cut_Off_Energy: 300 If you want to get Castep to automatically print out the final structure, you can also add write_cell_structure: true You can now use castepsub to submit your geometry optimisation! Results Analysis Scroll down through the file. Check to see how the forces and bond-length varies over iterations. For advanced bash users, try grep \"F|max\" H2.castep to extract this from the file. You may also want to visualise the H2.cell and (if you tolda castep to print it) the H2-out.cell files as in previous tutorials Finally, consider watching the optimisation by drag-and-dropping the H2.geom file into Jmol (VESTA will not animate it) The experimental H2 bond length is about 0.74 Angstroms. How does your result compare? Extension A may give some insight into this!","title":"Exercise 1 - Dihydrogen dimer"},{"location":"workshop/03_geometry/#extensions","text":"You may wish to split these between groups and discuss the results","title":"Extensions"},{"location":"workshop/03_geometry/#a-functional-choice","text":"So far you've used the local density approximation (LDA) for the exchange-correlation functional in this exercise. Repeat your calculation with the PBE exchange-correlation functional (a popular GGA): xc_functional : PBE You may also want to consider a hybrid functional such as HSE06 or the meta-GGA RSCAN","title":"A. Functional Choice"},{"location":"workshop/03_geometry/#b-more-precise-structural-optimisations","text":"You may wish to have more precise structure for certain calculations such as NMR or Phonons . These may be controlled in the .param file with geom_force_tol: 0.05 eV/ang geom_energy_tol: 2e-5 eV geom_stress_tol: 0.1 GPa geom_disp_tol: 0.001 ang These are the default values; what happens to your final values when you alter them? Hint: You have fixed the lattice - what will stress do?","title":"B. More Precise Structural Optimisations"},{"location":"workshop/03_geometry/#c-wavefunction-convergence","text":"If you have a bad wavefunction you will get bad forces. To demonstrate this try adding elec_energy_tol: 0.1 This overwrites the default of 0.00001 ev and will make the SCF convergence very fast. What does this do to the geometry optimisation? NOTE: This is not something you want to do in practice! Hopefully working through this example will demonstrate why.","title":"C. Wavefunction Convergence"},{"location":"workshop/03_geometry/#exercise-2","text":"Run a geometry optimisation on silicon. You can use a silicon input file from one of the previous tutorials as a starting point for your input files. Set CASTEP's parameters to perform a geometry optimisation using a 160 eV plane-wave cut-off energy and an 8x8x8 Monkhorst-Pack k-point grid: In Si2.param : task : geometry optimisation cut_off_energy : 160 eV In Si2.cell : kpoints_MP_grid 8 8 8 Because you're going to change the lattice vectors, CASTEP will do a finite basis-set correction (FBSC); this will calculate and print out dEtotal/dlog(Ecut) \u2013 anything more than 0.1 eV/atom is big and a sign of incomplete convergence. Q: What is the final lattice parameter? Do convergence tests (cut_off_energy, kpoints etc). The experimental lattice constant is 3.84 Angstrom - how does your value compare? What is the difference in your results between calculations using an LDA and a PBE exchange-correlation functional?","title":"Exercise 2"},{"location":"workshop/03_geometry/#exercise-3-graphene","text":"It can be useful to know how to construct a monolayer material, such as graphene. This requires the use of cell constraints so that we force a large distance between periodic images (and we don't have the system collapse to form graphite!) In your .cell file: %block cell_constraints 1 1 0 3 4 5 %endblock cell_constraints Will force the a and b lattice parameters to be the same (though free to vary jointly), fix the c lattice vector, and let all angles relax independently. This is similar to the %block lattice_abc structure you saw earlier. For the mathematically minded, this is taking the limit that the interlayer spacing, controlled by the out-of-plane lattice vector, goes to infinity! Practically, we cannot actually set the lattice parameter to infinity - try varying it and seeing how it converges with distance.","title":"Exercise 3 - Graphene"},{"location":"workshop/04_nmr_shiedling_efg/","text":"4 NMR shielding and EFG Part 1 We start running castep calculations by looking at two small systems, and examining the issue of \"convergence\". Start by copying the input files into your home directory i.e. cp /home/jryates/WORKSHOP/workshop_nmr_intro.tgz ./ unpack it tar -zxvf workshop_nmr_intro.tgz Example 1 - Ethanol CH 3 CH 2 OH Fig1. Proton spectrum of ethanol The discovery that one could actually see chemical shifts in hydrogen spectra was made in 1951 at Stanford University by Packard, Arnold, Dharmatti (shown in Fig 1). We will try to reproduce this result. FILES: ethanol.cell %BLOCK LATTICE_ABC 6 6 6 90 90 90 %ENDBLOCK LATTICE_ABC %BLOCK POSITIONS_ABS H 3.980599 4.178342 3.295079 H 5.033394 3.43043 4.504759 H 5.71907 4.552257 3.315353 H 3.720235 5.329505 5.509909 H 4.412171 6.433572 4.317001 H 5.911611 5.032284 6.242202 C 4.84694 4.350631 3.941136 C 4.603025 5.518738 4.882532 O 5.746254 5.812705 5.6871 %ENDBLOCK POSITIONS_ABS %BLOCK KPOINTS_LIST 0.25 0.25 0.25 1.0 %ENDBLOCK KPOINTS_LIST ethanol.param xcfunctional = PBE fix_occupancy = true opt_strate.g.y : speed task = magres cut_off_energy = 20 ry OBJECTIVES: Examine the convergence of the chemical shieldings with planewave cutoff Compare to experiment. INSTRUCTIONS: Look at the cell and param file. Note that the only special keyword is task = magres Run castep. castepsub -n 4 ethanol Look at the output file. At the end the isotropic chemical shielding, anisotropy, and asymmetry are reported (here we are only interested in the isotropic value.) This information, plus the full tensors is also given in the file ethanol.magres You might wish to transfer the *.magres file back to your desktop to visualise with MagresView . Examine the effect of increasing the cutoff energy (say 20-50 Ryd in steps of 10 Ryd). It always helps to plot a graph of the convergence (e.g. with gnuplot or xmgrace on the cluster - or with excel on the pc) Find the \"converged\" hydrogen (or proton in NMR language) shieldings. We will compare them to experiment. The three methyl (CH 3 ) protons undergo fast exchange; they \"rotate\" faster than the nuclear magnetic moment processes. The magnetic moment will therefore \"see\" an average chemical shielding. The same is true of the CH 2 protons. Average the CH 3 and CH 2 chemical shieldings. This will give you 3 unique chemical shieldings. We now need to convert the chemical shieldings \u03c3 iso to chemical shifts \u03b4 iso on the experimental scale. We use the relation: \u03b4 iso =\u03c3 ref -\u03c3 A suitable \u03c3 ref for 1H is 30.97ppm. Fig2. 1H NMR spectrum of liquid ethanol Fig. 2 shows a modern high-resolution 1H spectrum for liquid ethanol. Note that the peaks are split due to J-coupling - the interaction of the 1H magnetic moments - but let's ignore that for now. The three peaks are roughly at 1.2ppm, 3.7ppm and 5ppm. You should find that your computed values agree for two sites. Do you know why the other site has such a large disagreement with experiment? Example 2 - Diamond FILES: diamond.cell %block LATTICE_CART 0 1.7 1.7 1.7 0 1.7 1.7 1.7 0 %endblock LATTICE_CART %block POSITIONS_FRAC C 0.000000 0.000000 0.000000 C 0.250000 0.250000 0.250000 %endblock POSITIONS_FRAC kpoints_mp_grid 4 4 4 symmetry_generate * diamond.param comment = nmr testing iprint = 1 xcfunctional = LDA task : magres fix_occupancy = true opt_strategy : speed cut_off_energy = 30 Ry OBJECTIVES: Examine the convergence of the chemical shielding as the sampling of the electronic Brillouin zone (BZ) is increased. INSTRUCTIONS: Look at the files diamond.cell and diamond.param We have specified the kpoints in the cell file using the keyword kpoints_mp_grid 4 4 4 Run CASTEP for a range of kpoint meshes (say 2,4,6,8,10) Examine (plot?) the convergence of the chemical shielding. The computational cost scales linearly with the number of kpoints (i.e. the number of points in the irreducible Brillouin Zone). For a large unit cell (i.e. a small BZ) it may be possible to get converged results using a single k-point. But which kpoint should we choose? For diamond we will look at 3 different k-points (0,0,0), (\u00bd,\u00bd,\u00bd) (\u00bc,\u00bc,\u00bc). Specify the kpoint in the cell file using %BLOCK KPOINTS_LIST 0.25 0.25 0.25 1.0 %ENDBLOCK KPOINTS_LIST Which gives a result closest to the converged answer? (as the diamond unit cell is rather small the 1 kpoint answer is not too close to converged. However, the observation holds true for all orthorhombic cells) Part 2 We now look at some more realistic examples. Oxygen-17 Oxygen is a component of many geological materials. Oxygen is also important element in organic and biological molecules since it is often intimately involved in hydrogen bonding. Solid State 17 O NMR should be a uniquely valuable probe as the chemical shift range of 17 O covers almost 1000 ppm in organic molecules. Furthermore 17 O has spin I = 5/2 and hence a net quadrupole moment. As a consequence of this the solid state NMR spectrum is strongly affected by the electric field gradient at the nucleus. Because the isotopic abundance of 17 O is very low (0.037%) and the NMR linewidths due to the electric field gradient relatively large, only limited Solid State NMR data is available. This is particularly true for organic materials. First principles calculations of 17 O NMR parameters have played a vital role in assigning experimental spectra, and developing empirical rules between NMR parameters and local atomic structure. Example 3 - Alanine, a simple amino acid FILES: alanine.cell alanine.param alanine.pdb OBJECTIVES: Compute the chemical shift and Electric field gradient for alanine Assign the 17 NMR spectrum Fig3. Solid-State O17 NMR spectrum of L-alanine. (b) is from MAS (magicangle- spinning) (c) is from DOR (double-orientation rotation) INSTRUCTIONS: Look at the cell and param files. The geometry for alanine was obtained by neutron diffraction and was downloaded from the Cambridge Crystallographic database. View the original pdb file note the hydrogen bonding Run the example - the calculation is not fully converged. However, the relative shift between the two sites is fairly converged. The experimental 17 O NMR spectrum shows two peaks (Fig 3 (b)) - they are very broad due to the quadrupolar coupling, and overlap. The experimental parameters are given in Table 1. Assign the two resonances A and B. Do all three computed parameters support this assignment? Table 1: Experimental 17 O NMR parameters for alanine. The two resonances are labeled A and B. Isotropic chemical shift \u03b4, quadrupolar coupling C Q , and EFG asymmetry \u03b7 Q . \u03b4(A)-\u03b4 (B) (ppm) 23.5 C Q (A) (MHz) 7.86 \u03b7 Q (A) 0.28 C Q (B) (MHz) 6.53 \u03b7 Q (B) 0.70 Example 4 - Silicates Quartz and Cristoballite FILES: quartz.cell quartz.param crist.cell crist.param OBJECTIVES: Compute the chemical shift and Electric field gradient for two silicates. Assign the 17 O NMR spectrum INSTRUCTIONS: The 17 O parameters for two silicates are reported in Table 2. From the values you compute can you tell which one is quartz? (a suitable \u03c3 ref is 263ppm) Table 2 : Experimental 17 O NMR parameters for two silicates. Isotropic chemical shift \u03b4 , quadrupolar coupling C Q , and EFG asymmetry \u03b7 Q . \u03b4 (ppm) C Q (MHz) \u03b7 Q Material A 37.2 5.21 0.13 Material B 40.8 5.19 0.19","title":"4 NMR Shielding"},{"location":"workshop/04_nmr_shiedling_efg/#4-nmr-shielding-and-efg","text":"","title":"4 NMR shielding and EFG"},{"location":"workshop/04_nmr_shiedling_efg/#part-1","text":"We start running castep calculations by looking at two small systems, and examining the issue of \"convergence\". Start by copying the input files into your home directory i.e. cp /home/jryates/WORKSHOP/workshop_nmr_intro.tgz ./ unpack it tar -zxvf workshop_nmr_intro.tgz","title":"Part 1"},{"location":"workshop/04_nmr_shiedling_efg/#example-1-ethanol-ch3ch2oh","text":"Fig1. Proton spectrum of ethanol The discovery that one could actually see chemical shifts in hydrogen spectra was made in 1951 at Stanford University by Packard, Arnold, Dharmatti (shown in Fig 1). We will try to reproduce this result. FILES: ethanol.cell %BLOCK LATTICE_ABC 6 6 6 90 90 90 %ENDBLOCK LATTICE_ABC %BLOCK POSITIONS_ABS H 3.980599 4.178342 3.295079 H 5.033394 3.43043 4.504759 H 5.71907 4.552257 3.315353 H 3.720235 5.329505 5.509909 H 4.412171 6.433572 4.317001 H 5.911611 5.032284 6.242202 C 4.84694 4.350631 3.941136 C 4.603025 5.518738 4.882532 O 5.746254 5.812705 5.6871 %ENDBLOCK POSITIONS_ABS %BLOCK KPOINTS_LIST 0.25 0.25 0.25 1.0 %ENDBLOCK KPOINTS_LIST ethanol.param xcfunctional = PBE fix_occupancy = true opt_strate.g.y : speed task = magres cut_off_energy = 20 ry OBJECTIVES: Examine the convergence of the chemical shieldings with planewave cutoff Compare to experiment. INSTRUCTIONS: Look at the cell and param file. Note that the only special keyword is task = magres Run castep. castepsub -n 4 ethanol Look at the output file. At the end the isotropic chemical shielding, anisotropy, and asymmetry are reported (here we are only interested in the isotropic value.) This information, plus the full tensors is also given in the file ethanol.magres You might wish to transfer the *.magres file back to your desktop to visualise with MagresView . Examine the effect of increasing the cutoff energy (say 20-50 Ryd in steps of 10 Ryd). It always helps to plot a graph of the convergence (e.g. with gnuplot or xmgrace on the cluster - or with excel on the pc) Find the \"converged\" hydrogen (or proton in NMR language) shieldings. We will compare them to experiment. The three methyl (CH 3 ) protons undergo fast exchange; they \"rotate\" faster than the nuclear magnetic moment processes. The magnetic moment will therefore \"see\" an average chemical shielding. The same is true of the CH 2 protons. Average the CH 3 and CH 2 chemical shieldings. This will give you 3 unique chemical shieldings. We now need to convert the chemical shieldings \u03c3 iso to chemical shifts \u03b4 iso on the experimental scale. We use the relation: \u03b4 iso =\u03c3 ref -\u03c3 A suitable \u03c3 ref for 1H is 30.97ppm. Fig2. 1H NMR spectrum of liquid ethanol Fig. 2 shows a modern high-resolution 1H spectrum for liquid ethanol. Note that the peaks are split due to J-coupling - the interaction of the 1H magnetic moments - but let's ignore that for now. The three peaks are roughly at 1.2ppm, 3.7ppm and 5ppm. You should find that your computed values agree for two sites. Do you know why the other site has such a large disagreement with experiment?","title":"Example 1 - Ethanol CH3CH2OH"},{"location":"workshop/04_nmr_shiedling_efg/#example-2-diamond","text":"FILES: diamond.cell %block LATTICE_CART 0 1.7 1.7 1.7 0 1.7 1.7 1.7 0 %endblock LATTICE_CART %block POSITIONS_FRAC C 0.000000 0.000000 0.000000 C 0.250000 0.250000 0.250000 %endblock POSITIONS_FRAC kpoints_mp_grid 4 4 4 symmetry_generate * diamond.param comment = nmr testing iprint = 1 xcfunctional = LDA task : magres fix_occupancy = true opt_strategy : speed cut_off_energy = 30 Ry OBJECTIVES: Examine the convergence of the chemical shielding as the sampling of the electronic Brillouin zone (BZ) is increased. INSTRUCTIONS: Look at the files diamond.cell and diamond.param We have specified the kpoints in the cell file using the keyword kpoints_mp_grid 4 4 4 Run CASTEP for a range of kpoint meshes (say 2,4,6,8,10) Examine (plot?) the convergence of the chemical shielding. The computational cost scales linearly with the number of kpoints (i.e. the number of points in the irreducible Brillouin Zone). For a large unit cell (i.e. a small BZ) it may be possible to get converged results using a single k-point. But which kpoint should we choose? For diamond we will look at 3 different k-points (0,0,0), (\u00bd,\u00bd,\u00bd) (\u00bc,\u00bc,\u00bc). Specify the kpoint in the cell file using %BLOCK KPOINTS_LIST 0.25 0.25 0.25 1.0 %ENDBLOCK KPOINTS_LIST Which gives a result closest to the converged answer? (as the diamond unit cell is rather small the 1 kpoint answer is not too close to converged. However, the observation holds true for all orthorhombic cells)","title":"Example 2 - Diamond"},{"location":"workshop/04_nmr_shiedling_efg/#part-2","text":"We now look at some more realistic examples. Oxygen-17 Oxygen is a component of many geological materials. Oxygen is also important element in organic and biological molecules since it is often intimately involved in hydrogen bonding. Solid State 17 O NMR should be a uniquely valuable probe as the chemical shift range of 17 O covers almost 1000 ppm in organic molecules. Furthermore 17 O has spin I = 5/2 and hence a net quadrupole moment. As a consequence of this the solid state NMR spectrum is strongly affected by the electric field gradient at the nucleus. Because the isotopic abundance of 17 O is very low (0.037%) and the NMR linewidths due to the electric field gradient relatively large, only limited Solid State NMR data is available. This is particularly true for organic materials. First principles calculations of 17 O NMR parameters have played a vital role in assigning experimental spectra, and developing empirical rules between NMR parameters and local atomic structure.","title":"Part 2"},{"location":"workshop/04_nmr_shiedling_efg/#example-3-alanine-a-simple-amino-acid","text":"FILES: alanine.cell alanine.param alanine.pdb OBJECTIVES: Compute the chemical shift and Electric field gradient for alanine Assign the 17 NMR spectrum Fig3. Solid-State O17 NMR spectrum of L-alanine. (b) is from MAS (magicangle- spinning) (c) is from DOR (double-orientation rotation) INSTRUCTIONS: Look at the cell and param files. The geometry for alanine was obtained by neutron diffraction and was downloaded from the Cambridge Crystallographic database. View the original pdb file note the hydrogen bonding Run the example - the calculation is not fully converged. However, the relative shift between the two sites is fairly converged. The experimental 17 O NMR spectrum shows two peaks (Fig 3 (b)) - they are very broad due to the quadrupolar coupling, and overlap. The experimental parameters are given in Table 1. Assign the two resonances A and B. Do all three computed parameters support this assignment? Table 1: Experimental 17 O NMR parameters for alanine. The two resonances are labeled A and B. Isotropic chemical shift \u03b4, quadrupolar coupling C Q , and EFG asymmetry \u03b7 Q . \u03b4(A)-\u03b4 (B) (ppm) 23.5 C Q (A) (MHz) 7.86 \u03b7 Q (A) 0.28 C Q (B) (MHz) 6.53 \u03b7 Q (B) 0.70","title":"Example 3 - Alanine, a simple amino acid"},{"location":"workshop/04_nmr_shiedling_efg/#example-4-silicates-quartz-and-cristoballite","text":"FILES: quartz.cell quartz.param crist.cell crist.param OBJECTIVES: Compute the chemical shift and Electric field gradient for two silicates. Assign the 17 O NMR spectrum INSTRUCTIONS: The 17 O parameters for two silicates are reported in Table 2. From the values you compute can you tell which one is quartz? (a suitable \u03c3 ref is 263ppm) Table 2 : Experimental 17 O NMR parameters for two silicates. Isotropic chemical shift \u03b4 , quadrupolar coupling C Q , and EFG asymmetry \u03b7 Q . \u03b4 (ppm) C Q (MHz) \u03b7 Q Material A 37.2 5.21 0.13 Material B 40.8 5.19 0.19","title":"Example 4 - Silicates Quartz and Cristoballite"},{"location":"workshop/05_phonon/","text":"Phonons and Spectroscopy Tutorial The aims of this tutorial session is to introduce you to running larger-scale CASTEP jobs on supercomputer clusters, editing of input files for and setup of CASTEP jobs, and analysis of the results using standalone tools. To achieve results without waiting too long for jobs to complete the initial runs will be small ones, but the aim by the end of this afternoon should be to set up larger and more significant runs. Today's session will entirely comprise insulators or semiconductors. You may need to consult the CASTEP phonon users guide, which may be accessed here The practical will be conducted using the arc service. Make a directory called (e.g.) Phonons and copy the files /home/jryates/WORKSHOP/h-BN.cell and /home/jryates/WORKSHOP/h-BN.param into the new folder. A. \\Gamma \\Gamma -Point phonon in h-BN The first exercise will take you through the construction of a \\Gamma \\Gamma point phonon calculation and the generation of a simple model infrared spectrum of a semiconductor. It will also introduce you to the use of some additional analysis and visualisation tools. BN is one of a family of Nitride semiconductors, which occurs in cubic zincblende (c-BN), hexagonal wurtzite (h-BN) and graphite-like hexagonal (h-BN) polymorphs. We will calculate the phonons, infrared spectrum and Raman spectrum of h-BN. Phonon Calculation Set-up Your starting point will be the structure which is provided in the .cell file. The Phonons Manual contains a very similar example for the Wurtzite-structure polymorph of BN. Edit the .cell file using one of the text editors installed on the system (e.g. nano ). Uncomment the species_pot block and change it to read %block species_pot NCP %endblock species_pot to select norm-conserving pseudopotentials. Choose the k-point set to use \u2013 remove any block KPOINT_LIST and replace with the line kpoint_mp_grid 7 7 4 and one to specify a gamma-point phonon wavevector phonon_kpoint_mp_grid 1 1 1 Have a look in the .param file, look up the meaning of any keywords you don\u2019t know (you can use castep.serial -h <keyword> ). Test your configuration using castep.serial \u2013dryrun h-BN This tells CASTEP to read the intput files and summaries the calculation in the .castep file, but does not run the electronic structure calculation. It is very useful to check syntax before submitting to a batch queue (and finding out later you\u2019d made a spelling mistake!). Check to see if any .err files are produced and fix issues, if any. If / when no errors are returned, congratulations. You have set up the input files, and you can delete the dryrun .castep file. Once you have in place the <seed>.cell and <seed>.param files you are ready to submit the CASTEP job. This is done using our general script: castepsub -n 16 h-BN which requests a 16-core parallel run. Use the squeue -u $USER command to monitor the progress of your calculation. When it has finished, you can examine the output file h-BN.castep and find the frequencies. What you see is explained further in the Phonons user guide linked above. There is also a machine-readable file h-BN.phonon which contains the frequencies and also the eigenvectors which we will analyse. Analysis of h-BN phonon output. We will use Castep\u2019s tools to visualise the modes using the free Jmol visualiser. Use secure file transfer to copy the .phonon file back to the PC where Jmol is installed. Start Jmol and bring up a console window from the right-mouse menu. To use the full power of the command-line and find the files it is most convenient to set Jmol's current directory to the location of your working directory containing your output files. (It is possible and simpler to drag and drop the .phonon file onto Jmol window, but you need the power of the command line to display additional periodic repeats.) cd --- report the current directory cd .. or cd <subdir> -- navigate up/down the directory tree. Then type the Jmol command to load your .castep file load h-BN.phonon {3 3 2} PACKED Note that while you can read in the .phonon file from Jmol's File menu, you need the additional opitions of the command line to display additional periodic repeats. You can then use the Tools-Vibrate menu to turn on mode animation, and navigate the modes. Can you see from the mode eigenvectors which modes are IR-active and which are Raman active? Do you agree with the IR and Raman activity printed in the .castep file? Generation of IR spectrum The easiest way to generate a simple model IR spectrum is to use Castep\u2019s dos.pl tool. To run this in the most effective way and automatically display a plot, you will need to be running an X windows server on the PC. In that case the command dos.pl -ir -xg h-BN.phonon will generate a plot script and use the xmgrace plotting program to display it. You can create a gnuplot script instead of xmgrace by changing the -xg flag to -gp . Alternatively you can generate a GNUPLOT script without plotting by dos.pl -ir -gp -np h-BN.phonon > h-BN-phonon.plt You can then copy the h-BN-phonon.plt back to the PC and read this into GNUPLOT. Generation of Raman spectrum The calculation of a raman intensities is fairly expensive compared to infrared matrix elements and it is therefore not turned on by default however the .param file turned this on: CALCULATE_RAMAN : TRUE RAMAN_METHOD : DFPT You can use the -raman flag of dos.pl to generate and plot a Raman spectrum. B. Molecular modes in benzene The next part of this practical is to compute the modes and spectrum of a molecule and compare the result with a calculation of a molecular crystal. Our example is benzene. You are supplied (in the workshop direxctory on arc, /home/jryates/WORKSHOP ) with .pdb files describing a benzene molecule and a high-pressure crystalline polymorph, phase III. First run the isolated molecule calculation. Using the supplied PDB format file and using the pdb2cell utility, generate a .cell file for a single molecule calculation. There are a few other considerations to take into account for an isolated molecule calculation. The size of the simulation cell governs the interactions between periodic copies of the molecule and should be large enough that these are negligible. The shape of the simulation cell governs the crystallographic point groups allowed in the handling of the symmetry. It should be chosen to be commensurate (as far as possible) with the molecular point group to maximise the use of symmetry. In the case of benzene it should obviously be hexagonal, here we use a box 8A by 8A by 4A. Recall that there is no electronic dispersion for a molecule, so only a single electronic k-point is needed. The general rule is that all \u201cmolecule in a box\u201d calculations should use the G point only as Castep uses special performance optimisations in this case. Use the norm-conserving pseudopotentials ( NCP in the species_pot block) For simplicity use the local density approximation, LDA . In benzene not all atoms are on special symmetry sites so you should first perform a geometry optimisation, keeping the unit cell fixed (see fix_all_cell keyword in Castep\u2019s help). Then set up a follow-on calculation to compute the Gamma point phonons using the continuation keyword in the .param file. The Phonons User Guide linked above should help you fill in the details, but please ask if you are stuck. Check the phonon frequencies. How many zero frequency modes are there? What frequencies do you get? Can you explain? Benzene Phase III: The next stage is to compute the \\Gamma \\Gamma point phonon modes of the molecular crystal of benzene in the high pressure polymorph, Phase III. You are supplied with a .pdb file. You should use a 2x2x2 grid of electronic k-points, as dispersion is non-zero in this molecular crystal. Make sure that symmetry is detected and enabled using symmetry_generate in the .cell file. Also check that the unit cell parameters are fixed to optimise the geometry and NCP pseudopotentials are used. Use the same .param file as for the molecular case to ensure the settings are the same. Similar to the molecular case run a geometry optimisation followed by a phonon calculation. Once these calculations have completed you should generate a phonon DOS and IR spectra as in the previous practical and compare the molecule with the molecular crystal. You can also use Jmol to identify the modes. Are all your frequencies positive? If not, can you suggest why not? C. Phonon dispersion using interpolation in NaH From \\Gamma \\Gamma point only calculations we now explore the whole of the Brillouin zone of phonon wavevectors. Our example is the rocksalt-structured hydride, NaH which should run quickly enough to return results in a few minutes. Based on previous exercises, lectures and the user manual, you should be able to set up and run a DFPT phonon dispersion calculation and display a well converged set of dispersion curves. A starting point for your .cell file is: %block lattice_cart 2.0 2.0 0.0 2.0 0.0 2.0 0.0 2.0 2.0 %endblock lattice_cart %block positions_frac Li 0.0 0.0 0.0 H 0.5 0.5 0.5 %endblock positions_frac Symmetry_generate This contains the primitive fcc unit cell of the B1 rocksalt structure with the Na ion at (0,0,0) and the H ion at (\u00bd,\u00bd,\u00bd). This is a high-symmetry structure so it is important to instruct CASTEP to generate and use the full symmetry set. Also use norm-conserving pseudopotentials. A suitable list of points for the fine q-point path for an FCC crystal is: %block phonon_fine_kpoint_path 0.0 0.0 0.0 ! Gamma 0.5 0.5 0.0 ! X (along Delta 1.0 1.0 1.0 ! Gamma (Sigma ) 0.5 0.5 0.5 ! L (Delta) 0.5 0.75 0.25 ! W (Q) 0.5 0.5 0.0 ! X (Z) %endblock phonon_fine_kpoint_path Although you can now start the phonon calculation, knowing the accuracy of the result (error bounds) is good science. You should perform a k-point convergence test. For a phonon calculation, convergence of the forces is an appropriate test criterion. Since all of the ions are on symmetry positions the forces are zero by symmetry. Try to think of a way around this obstacle. And adopt a suitable compromise between accuracy and run-time. C.II Phonon DOS using interpolation The task here is to use the NaH example to compute and display not a dispersion curve but a density of states. This will exploit CASTEPs interpolation functionality, and you will be able to compute a good DOS without the need the repeat the expensive electronic structure calculation. To do this you will need to set up a calculation neatly identical to your previous one but with two differences. The calculation should be set up as a continuation. If your previous run wrote a .check file named NaH.check for example, then the param file should contain the line continuation : NaH.check Instead of a %block phonon_fine_kpoint_list in the .cell file, you can specify a grid phonon_fine_kpoint_mp_grid 16 16 16 You can run CASTEP on just 1-4 processors for this You can try this several times with different fine q-point grids. This will produce a .castep and .phonon file as before. You may analyse the .phonon file and generate a DOS using the dos.pl script dos.pl -xg NaH-dos.phonon (again, an X server running on the PC will be needed for grace to display; MobaXterm should have this enabled by default) .","title":"5 Phonons"},{"location":"workshop/05_phonon/#phonons-and-spectroscopy-tutorial","text":"The aims of this tutorial session is to introduce you to running larger-scale CASTEP jobs on supercomputer clusters, editing of input files for and setup of CASTEP jobs, and analysis of the results using standalone tools. To achieve results without waiting too long for jobs to complete the initial runs will be small ones, but the aim by the end of this afternoon should be to set up larger and more significant runs. Today's session will entirely comprise insulators or semiconductors. You may need to consult the CASTEP phonon users guide, which may be accessed here The practical will be conducted using the arc service. Make a directory called (e.g.) Phonons and copy the files /home/jryates/WORKSHOP/h-BN.cell and /home/jryates/WORKSHOP/h-BN.param into the new folder.","title":"Phonons and Spectroscopy Tutorial"},{"location":"workshop/05_phonon/#a-gammagamma-point-phonon-in-h-bn","text":"The first exercise will take you through the construction of a \\Gamma \\Gamma point phonon calculation and the generation of a simple model infrared spectrum of a semiconductor. It will also introduce you to the use of some additional analysis and visualisation tools. BN is one of a family of Nitride semiconductors, which occurs in cubic zincblende (c-BN), hexagonal wurtzite (h-BN) and graphite-like hexagonal (h-BN) polymorphs. We will calculate the phonons, infrared spectrum and Raman spectrum of h-BN. Phonon Calculation Set-up Your starting point will be the structure which is provided in the .cell file. The Phonons Manual contains a very similar example for the Wurtzite-structure polymorph of BN. Edit the .cell file using one of the text editors installed on the system (e.g. nano ). Uncomment the species_pot block and change it to read %block species_pot NCP %endblock species_pot to select norm-conserving pseudopotentials. Choose the k-point set to use \u2013 remove any block KPOINT_LIST and replace with the line kpoint_mp_grid 7 7 4 and one to specify a gamma-point phonon wavevector phonon_kpoint_mp_grid 1 1 1 Have a look in the .param file, look up the meaning of any keywords you don\u2019t know (you can use castep.serial -h <keyword> ). Test your configuration using castep.serial \u2013dryrun h-BN This tells CASTEP to read the intput files and summaries the calculation in the .castep file, but does not run the electronic structure calculation. It is very useful to check syntax before submitting to a batch queue (and finding out later you\u2019d made a spelling mistake!). Check to see if any .err files are produced and fix issues, if any. If / when no errors are returned, congratulations. You have set up the input files, and you can delete the dryrun .castep file. Once you have in place the <seed>.cell and <seed>.param files you are ready to submit the CASTEP job. This is done using our general script: castepsub -n 16 h-BN which requests a 16-core parallel run. Use the squeue -u $USER command to monitor the progress of your calculation. When it has finished, you can examine the output file h-BN.castep and find the frequencies. What you see is explained further in the Phonons user guide linked above. There is also a machine-readable file h-BN.phonon which contains the frequencies and also the eigenvectors which we will analyse. Analysis of h-BN phonon output. We will use Castep\u2019s tools to visualise the modes using the free Jmol visualiser. Use secure file transfer to copy the .phonon file back to the PC where Jmol is installed. Start Jmol and bring up a console window from the right-mouse menu. To use the full power of the command-line and find the files it is most convenient to set Jmol's current directory to the location of your working directory containing your output files. (It is possible and simpler to drag and drop the .phonon file onto Jmol window, but you need the power of the command line to display additional periodic repeats.) cd --- report the current directory cd .. or cd <subdir> -- navigate up/down the directory tree. Then type the Jmol command to load your .castep file load h-BN.phonon {3 3 2} PACKED Note that while you can read in the .phonon file from Jmol's File menu, you need the additional opitions of the command line to display additional periodic repeats. You can then use the Tools-Vibrate menu to turn on mode animation, and navigate the modes. Can you see from the mode eigenvectors which modes are IR-active and which are Raman active? Do you agree with the IR and Raman activity printed in the .castep file?","title":"A. \\Gamma\\Gamma-Point phonon in h-BN"},{"location":"workshop/05_phonon/#generation-of-ir-spectrum","text":"The easiest way to generate a simple model IR spectrum is to use Castep\u2019s dos.pl tool. To run this in the most effective way and automatically display a plot, you will need to be running an X windows server on the PC. In that case the command dos.pl -ir -xg h-BN.phonon will generate a plot script and use the xmgrace plotting program to display it. You can create a gnuplot script instead of xmgrace by changing the -xg flag to -gp . Alternatively you can generate a GNUPLOT script without plotting by dos.pl -ir -gp -np h-BN.phonon > h-BN-phonon.plt You can then copy the h-BN-phonon.plt back to the PC and read this into GNUPLOT.","title":"Generation of IR spectrum"},{"location":"workshop/05_phonon/#generation-of-raman-spectrum","text":"The calculation of a raman intensities is fairly expensive compared to infrared matrix elements and it is therefore not turned on by default however the .param file turned this on: CALCULATE_RAMAN : TRUE RAMAN_METHOD : DFPT You can use the -raman flag of dos.pl to generate and plot a Raman spectrum.","title":"Generation of Raman spectrum"},{"location":"workshop/05_phonon/#b-molecular-modes-in-benzene","text":"The next part of this practical is to compute the modes and spectrum of a molecule and compare the result with a calculation of a molecular crystal. Our example is benzene. You are supplied (in the workshop direxctory on arc, /home/jryates/WORKSHOP ) with .pdb files describing a benzene molecule and a high-pressure crystalline polymorph, phase III. First run the isolated molecule calculation. Using the supplied PDB format file and using the pdb2cell utility, generate a .cell file for a single molecule calculation. There are a few other considerations to take into account for an isolated molecule calculation. The size of the simulation cell governs the interactions between periodic copies of the molecule and should be large enough that these are negligible. The shape of the simulation cell governs the crystallographic point groups allowed in the handling of the symmetry. It should be chosen to be commensurate (as far as possible) with the molecular point group to maximise the use of symmetry. In the case of benzene it should obviously be hexagonal, here we use a box 8A by 8A by 4A. Recall that there is no electronic dispersion for a molecule, so only a single electronic k-point is needed. The general rule is that all \u201cmolecule in a box\u201d calculations should use the G point only as Castep uses special performance optimisations in this case. Use the norm-conserving pseudopotentials ( NCP in the species_pot block) For simplicity use the local density approximation, LDA . In benzene not all atoms are on special symmetry sites so you should first perform a geometry optimisation, keeping the unit cell fixed (see fix_all_cell keyword in Castep\u2019s help). Then set up a follow-on calculation to compute the Gamma point phonons using the continuation keyword in the .param file. The Phonons User Guide linked above should help you fill in the details, but please ask if you are stuck. Check the phonon frequencies. How many zero frequency modes are there? What frequencies do you get? Can you explain? Benzene Phase III: The next stage is to compute the \\Gamma \\Gamma point phonon modes of the molecular crystal of benzene in the high pressure polymorph, Phase III. You are supplied with a .pdb file. You should use a 2x2x2 grid of electronic k-points, as dispersion is non-zero in this molecular crystal. Make sure that symmetry is detected and enabled using symmetry_generate in the .cell file. Also check that the unit cell parameters are fixed to optimise the geometry and NCP pseudopotentials are used. Use the same .param file as for the molecular case to ensure the settings are the same. Similar to the molecular case run a geometry optimisation followed by a phonon calculation. Once these calculations have completed you should generate a phonon DOS and IR spectra as in the previous practical and compare the molecule with the molecular crystal. You can also use Jmol to identify the modes. Are all your frequencies positive? If not, can you suggest why not?","title":"B. Molecular modes in benzene"},{"location":"workshop/05_phonon/#c-phonon-dispersion-using-interpolation-in-nah","text":"From \\Gamma \\Gamma point only calculations we now explore the whole of the Brillouin zone of phonon wavevectors. Our example is the rocksalt-structured hydride, NaH which should run quickly enough to return results in a few minutes. Based on previous exercises, lectures and the user manual, you should be able to set up and run a DFPT phonon dispersion calculation and display a well converged set of dispersion curves. A starting point for your .cell file is: %block lattice_cart 2.0 2.0 0.0 2.0 0.0 2.0 0.0 2.0 2.0 %endblock lattice_cart %block positions_frac Li 0.0 0.0 0.0 H 0.5 0.5 0.5 %endblock positions_frac Symmetry_generate This contains the primitive fcc unit cell of the B1 rocksalt structure with the Na ion at (0,0,0) and the H ion at (\u00bd,\u00bd,\u00bd). This is a high-symmetry structure so it is important to instruct CASTEP to generate and use the full symmetry set. Also use norm-conserving pseudopotentials. A suitable list of points for the fine q-point path for an FCC crystal is: %block phonon_fine_kpoint_path 0.0 0.0 0.0 ! Gamma 0.5 0.5 0.0 ! X (along Delta 1.0 1.0 1.0 ! Gamma (Sigma ) 0.5 0.5 0.5 ! L (Delta) 0.5 0.75 0.25 ! W (Q) 0.5 0.5 0.0 ! X (Z) %endblock phonon_fine_kpoint_path Although you can now start the phonon calculation, knowing the accuracy of the result (error bounds) is good science. You should perform a k-point convergence test. For a phonon calculation, convergence of the forces is an appropriate test criterion. Since all of the ions are on symmetry positions the forces are zero by symmetry. Try to think of a way around this obstacle. And adopt a suitable compromise between accuracy and run-time.","title":"C. Phonon dispersion using interpolation in NaH"},{"location":"workshop/05_phonon/#cii-phonon-dos-using-interpolation","text":"The task here is to use the NaH example to compute and display not a dispersion curve but a density of states. This will exploit CASTEPs interpolation functionality, and you will be able to compute a good DOS without the need the repeat the expensive electronic structure calculation. To do this you will need to set up a calculation neatly identical to your previous one but with two differences. The calculation should be set up as a continuation. If your previous run wrote a .check file named NaH.check for example, then the param file should contain the line continuation : NaH.check Instead of a %block phonon_fine_kpoint_list in the .cell file, you can specify a grid phonon_fine_kpoint_mp_grid 16 16 16 You can run CASTEP on just 1-4 processors for this You can try this several times with different fine q-point grids. This will produce a .castep and .phonon file as before. You may analyse the .phonon file and generate a DOS using the dos.pl script dos.pl -xg NaH-dos.phonon (again, an X server running on the PC will be needed for grace to display; MobaXterm should have this enabled by default) .","title":"C.II Phonon DOS using interpolation"},{"location":"workshop/07_xc/","text":"XC-Functionals Introduction These exercises are intended to introduce you to some of the XC functionals available in CASTEP. They will show you how to choose and set up calculations using these functionals. They will also demonstrate the effect of chosen functional upon different physical properties. It is important to remember throughout that no XC functional is perfect (as discussed in the XC functional talk). In choosing a functional, we must be guided by an understanding of the XC functional itself and the physics of the system under consideration. It is also important to realise that sometimes ''inappropriate functionals get the 'right' answer for the wrong reasons!'' Some of these exercises will further illustrate this point. Many of the post-LDA functionals (HF, sX-LDA) are computationally intensive. For that reason, this practical session focusses upon small systems. However, by the end of this session you should be able to set up more complex and demanding systems. Where To Find Help If you want more information about a particular CASTEP keyword, or you want to find if CASTEP has particular functionality, there are a few places you can look. There is information on this website: www.castep.org . CASTEP has an in built help option to assist with using particular keywords. Information on using CASTEP can be seen by using: $ castep -help To get more information on a particular input file keyword (e.g. kpoint_mp_grid ) use: $ castep -help kpoint_mp_grid If you don't know the keyword you need to use, then you can search on a particular keyword. This returns a list of keywords that you might be interested in, e.g. to look at all keywords which contain a reference to symmetry. $ castep -help search symmetry Finally, to list all keywords, use: $ castep -help search all Example 1 - Si: LDA and GGA In this first exercise, we shall explore how to use different XC functionals to determine the electronic structure of silicon. Get the files required for this exercise : Si2 files We shall carry out these calculations on arcus. Transfer the files to arcus, and unzip and untar them. You can use: tar -xvf Si2.tar.gz We will begin by performing a simple band structure calculation. To do this, we must edit the Si2.param file. Open this file. Find the line that says task: . Amend this to say: task : bandstructure We can also choose the XC functional that we wish to employ in the param file. If we set xc_functional : lda then we will run a calculation using the LDA. This is the functional that will be employed in the SCF calculation that determines the ground state electronic density. If we do not specify otherwise, then it will also be used for the band structure calculation. Now we shall examine the .cell file. Open Si2.cell . Later in this tutorial, we shall use non-local functionals. In CASTEP, non-local functionals can only be used with norm-conserving pseudo potentials. (Question: Do you understand as to why this should be so? Ask if you do not.) For this reason, ensure that you are using the norm-conserving pseudo potential library by including: %block species_pot NCP %endblock species_pot in your .cell file. We will also need to set up an appropriate k-point path for the band structure calculation. We will use the following path: %block bs_kpoint_path 0.5 0.5 0.5 0.0 0.0 0.0 0.5 0.0 0.5 0.625 0.25 0.625 0.0 0.0 0.0 %endblock bs_kpoint_path Add this block to the .cell file. Ensure that your calculation is converged with respect to both kinetic energy cut-off and k-point sampling. Now run CASTEP on arcus using the 2-atom input files. $ castepsub -n Number Si2 where Number should be replaced by the number of processors that you wish to use. This should only take a few seconds and produce a readable output file Si2.castep . Examine this file and try to understand the meaning of the various parts. In particular check the section following the header which lists all of the input parameters, both explicit and default. Note what default values of the major parameters CASTEP chose where you did not specify them explicitly. (There will be some whose meaning has not been explained. Don't worry about these.) Note down how long the calculation takes for each k-point. We will now analyse the band structure. We can produce a plot of this from the Si2.bands file using: dispersion.pl -xg -bs Si2.bands Using the band structure plot, determine the band gap. How does this compare to the experimental value? Can you explain this? I recommend that you save the output from this calculation as Si2_lda or similar as later on we wish to compare with GGA and non-local calculations. Repeat steps 1-8 using a GGA functional. To change the functional employed, amend the .param file as follows: xc_functional : pw91 There is no one unique flavour of GGA, and this specifies the Perdew-Wang 91 implementation of the GGA. Other flavours such as PBE would be specified in similar fashion. How does the use of the GGA affect the band gap? Does it improve upon the LDA value? Why? Example 2 - Si: Non-local functionals We shall now move onto examining what happens with a non-local functional. In principle, we should, for a new functional, determine a ground state electronic density that is consistent with the functional employed. However, CASTEP allows us to be more flexible and to specify a different functional for the band structure calculation. We will use this to save some computational effort by using a LDA-derived ground state density. To begin, carry out a single-point energy calculation on our silicon system using the LDA. This calculation will be very quick. Alongside the .castep file, CASTEP there will also be a file Si2.check. This is the restart file. We will use this restart file to perform a band structure calculation using a different functional from that employed for the SCF. In the Si2.param file, add the following line: continuation : default This tells CASTEP that this is a re-start, and that the restart file is the default, which in this case is Si2.check. We could specify a different file here, if we wished. Add the following line to the .param file: bs_xc_functional : HF This allows us to specify a different functional for the band structure calculation, which in this case will be a Hartree-Fock calculation. However, we are using a LDA-derived ground state density to feed into this calculation. Now run the band structure calculation as before. When examining the .castep output look at the band structure timings. How do these compare to the LDA and GGA cases performed earlier? This should give some idea as to the more computationally intensive nature of a non-local calculation. Similarly, how do the memory estimates change? It is important to understand that this increased memory overhead can limit non-local calculations, even on HPC platforms (indeed, it can be more of a problem than the increased computational effort per step of the calculation). Plot the resulting band structure. How does this compare to the LDA and GGA values? How does the band gap compare? Why is this? Repeat steps 1-5, but for screened exchange with LDA correlation (sX-LDA). To do this, in Step 3 set bs_xc_functional : sX-lda Example 3 - FeO and DFT+U In the XC Functional talk, data were shown illustrating the effect of functional upon the electronic structure of antiferromagnetic FeO. In this example you will learn how to perform DFT+U calculations. Get the files required for this exercise : FeO Files We shall carry out these calculations on arcus. Transfer the files to arcus, and unzip and untar them. Open the .cell file. We are interested in examining an anti-ferromagnetic structure. Note the following in the block where the atomic positions are specified: Fe 0.0 0.0 0.0 spin=-4.0 Fe 0.0 0.0 0.0 spin=4.0 This specifies the initial antiferromagnetic spin arrangement, with spin = N_\\text{up}-N_\\text{down} N_\\text{up}-N_\\text{down} defining the initial spin polarisation on each Fe atom. NOTE: the spins specified here should be consistent with the overall spin (i.e. the initial number of unpaired electrons) specified in the .param file using the spin keyword. In this case, as the overall spin is zero (which is the CASTEP default value), we do not need to specify this, but if we examined a ferromagnetic structure then we would. CONVERGENCE NOTE: I suggest using a 6x6x6 MP grid. While not as converged as one would desire for serious science, this is sufficient for demonstrative purposes, and will allow us to perform several calculations in the time available. As we saw in the XC presentation, PBE obtains a metallic ground state for antiferromagnetic FeO. We shall therefore run this calculation as a metal. Ensure that the .param file has the following line: fix_occupancy : false which allows CASTEP to vary electronic occupancies. We shall use the default metals method, which is density mixing. Density mixing is the only method in CASTEP that allows us to specify initial magnetic moments on atoms. The convergence of calculations on metallic systems is often improved by the inclusion of a number of extra empty bands. We can specify this using the nextra_bands keyword. Set this to 14 with: nextra_bands : 14 4. As we wish to examine an anti-ferromagnetic structure in which individual Fe ions have non-zero spin, we must allow the system to be spin-polarised. To do this, open up and edit the .param file. Set: spin_polarized : true 5. We will set the XC functional to be the PBE flavour of GGA ( xc_functional : pbe ). Now run a band structure calculation and produce a band structure plot as before. There are certain features of the band structure plot that you should understand: the dispersive bands are ''sp'' bands derived from ''s'' and ''p'' electrons. The flat non-dispersive bands are derived from Fe ''d'' electrons. Can you explain why the ''d'' bands are so flat? When examining magnetic systems, it is also often useful to examine the spin on each atom. This information can be found in the .castep file in the section Atomic Populations (Mulliken) Note the spin on each Fe atom. How does this vary from the initial value specified? A DFT+U calculation To do this, open up and edit the .cell file. Add the following block to it: %block hubbard_u Fe 1 d: 2.5 Fe 2 d: 2.5 %endblock hubbard_u This specifies a Hubbard U parameter of 2.5 eV for each Fe ion in the system. Whilst schemes exist to determine the value of U from first principles, in CASTEP it is simply specified as a parameter. Of course, one could use ab initio calculations to determine a value of U then specify this in the .cell file. Run a band structure calculation and plot the results. How does this band structure compare to the PBE+U result? Can you explain which features change and which stay the same? What happens to the band gap? Now examine the spin on each Fe atom. Compare to the PBE values. Can you explain your observations? Repeat steps 7-9 for differing U values. Explain your findings. Example 4 - Graphite and DFT+D Graphite represents a prototypical example of a layered system in which the layers are weakly bound by van der Waals forces. As is well known, local and semi-local functionals such as the LDA and GGA neglect such interactions, and we could perhaps anticipate that they therefore perform poorly for such a system. We will explore the performance of these functionals. This example will also show you how to run dispersion corrected DFT+D functionals. Get the files required for this exercise : Graphite files As before, we shall carry out these calculations on arcus. Transfer the files to arcus, and unzip and untar them. Open the .param file using a text editor. We will do our first calculation with the PBE GGA functional. Ensure that this is the xc functional specified (see above if you cannot recall how to do this). Graphite has a semimetallic nature, with a non-zero DOS at the Fermi energy for the K and H points in reciprocal space. We will therefore run this calculation as a metal, as we did in the FeO example. Modify the .param file to ensure that this is the case. In contrast to FeO, however, we do not need to worry about spin polarisation. The convergence of calculations on metallic systems is often improved by the inclusion of a number of extra empty bands. We can specify this using the nextra_bands keyword. Set this to 14 with: nextra_bands : 14 We will run a geometry optimisation. Change the .param file so that this is the task. Now open up the .cell file using a text editor. We will perform our calculations for the experimental graphite structure. However, our atomic positions are slightly incommensurate with the symmetry of the unit cell; to remedy this, add the following line to the .cell file: snap_to_symmetry which puts the atoms on the symmetry positions. Now run a variable cell geometry optimisation. If you cannot recall how to do this, consult the earlier tutorial concerning geometry optimisations. Ensure that the calculation is converged with respect to both plane wave and k-point sampling. As we are interested in a geometry optimisation, examining the convergence with respect to force is a suitable criterion. However, as we have placed the ions on high symmetry positions, the forces on them will be zero by symmetry - can you think of how we can still examine the convergence of forces, given this fact? Once the calculation has completed, examine the unit cell parameters - how do they compare to the original (experimental) parameters? Can you explain this behaviour? We shall now investigate what happens with LDA. Repeat the above calculation with the LDA as the XC functional. What happens to the unit cell parameters in this case? Pay particular attention to the c axis. How does this compare to the GGA value? Is this behaviour expected? Can you explain it? Does this mean that LDA is particularly suitable to use to describe van der Waals bound systems? We shall now carry out a GGA calculation with a DFT+D correction. For this you can leave the .cell file unaltered. Open up the .param file using an editor. Add the following line: sedc_apply : true which tells CASTEP that it should apply the semi-empirical dispersion correction (i.e. DFT+D). Now specify the correction scheme. Begin with the G06 scheme (also known as D2): sedc_scheme : g06 Ensure that the XC functional to use is the PBE. Run the geometry optimisation. How do the results compare to the LDA and GGA answers? Repeat 10-13 but using the JCHS correction scheme. How do the results change? NOTE1: the TS scheme is not particularly suitable for such a small unit cell, as the code will warn you. The results should therefore be treated with caution. NOTE2: the OBS scheme is not compatible with the PBE functional. Further examples If you have worked through to this point in the tutorial, then feel free to apply these functionals to some more sophisticated systems that interest you. If you do not have particular systems in mind, then feel free to discuss possible choices with a demonstrator.","title":"7 XC"},{"location":"workshop/07_xc/#xc-functionals","text":"","title":"XC-Functionals"},{"location":"workshop/07_xc/#introduction","text":"These exercises are intended to introduce you to some of the XC functionals available in CASTEP. They will show you how to choose and set up calculations using these functionals. They will also demonstrate the effect of chosen functional upon different physical properties. It is important to remember throughout that no XC functional is perfect (as discussed in the XC functional talk). In choosing a functional, we must be guided by an understanding of the XC functional itself and the physics of the system under consideration. It is also important to realise that sometimes ''inappropriate functionals get the 'right' answer for the wrong reasons!'' Some of these exercises will further illustrate this point. Many of the post-LDA functionals (HF, sX-LDA) are computationally intensive. For that reason, this practical session focusses upon small systems. However, by the end of this session you should be able to set up more complex and demanding systems.","title":"Introduction"},{"location":"workshop/07_xc/#where-to-find-help","text":"If you want more information about a particular CASTEP keyword, or you want to find if CASTEP has particular functionality, there are a few places you can look. There is information on this website: www.castep.org . CASTEP has an in built help option to assist with using particular keywords. Information on using CASTEP can be seen by using: $ castep -help To get more information on a particular input file keyword (e.g. kpoint_mp_grid ) use: $ castep -help kpoint_mp_grid If you don't know the keyword you need to use, then you can search on a particular keyword. This returns a list of keywords that you might be interested in, e.g. to look at all keywords which contain a reference to symmetry. $ castep -help search symmetry Finally, to list all keywords, use: $ castep -help search all","title":"Where To Find Help"},{"location":"workshop/07_xc/#example-1-si-lda-and-gga","text":"In this first exercise, we shall explore how to use different XC functionals to determine the electronic structure of silicon. Get the files required for this exercise : Si2 files We shall carry out these calculations on arcus. Transfer the files to arcus, and unzip and untar them. You can use: tar -xvf Si2.tar.gz We will begin by performing a simple band structure calculation. To do this, we must edit the Si2.param file. Open this file. Find the line that says task: . Amend this to say: task : bandstructure We can also choose the XC functional that we wish to employ in the param file. If we set xc_functional : lda then we will run a calculation using the LDA. This is the functional that will be employed in the SCF calculation that determines the ground state electronic density. If we do not specify otherwise, then it will also be used for the band structure calculation. Now we shall examine the .cell file. Open Si2.cell . Later in this tutorial, we shall use non-local functionals. In CASTEP, non-local functionals can only be used with norm-conserving pseudo potentials. (Question: Do you understand as to why this should be so? Ask if you do not.) For this reason, ensure that you are using the norm-conserving pseudo potential library by including: %block species_pot NCP %endblock species_pot in your .cell file. We will also need to set up an appropriate k-point path for the band structure calculation. We will use the following path: %block bs_kpoint_path 0.5 0.5 0.5 0.0 0.0 0.0 0.5 0.0 0.5 0.625 0.25 0.625 0.0 0.0 0.0 %endblock bs_kpoint_path Add this block to the .cell file. Ensure that your calculation is converged with respect to both kinetic energy cut-off and k-point sampling. Now run CASTEP on arcus using the 2-atom input files. $ castepsub -n Number Si2 where Number should be replaced by the number of processors that you wish to use. This should only take a few seconds and produce a readable output file Si2.castep . Examine this file and try to understand the meaning of the various parts. In particular check the section following the header which lists all of the input parameters, both explicit and default. Note what default values of the major parameters CASTEP chose where you did not specify them explicitly. (There will be some whose meaning has not been explained. Don't worry about these.) Note down how long the calculation takes for each k-point. We will now analyse the band structure. We can produce a plot of this from the Si2.bands file using: dispersion.pl -xg -bs Si2.bands Using the band structure plot, determine the band gap. How does this compare to the experimental value? Can you explain this? I recommend that you save the output from this calculation as Si2_lda or similar as later on we wish to compare with GGA and non-local calculations. Repeat steps 1-8 using a GGA functional. To change the functional employed, amend the .param file as follows: xc_functional : pw91 There is no one unique flavour of GGA, and this specifies the Perdew-Wang 91 implementation of the GGA. Other flavours such as PBE would be specified in similar fashion. How does the use of the GGA affect the band gap? Does it improve upon the LDA value? Why?","title":"Example 1 - Si: LDA and GGA"},{"location":"workshop/07_xc/#example-2-si-non-local-functionals","text":"We shall now move onto examining what happens with a non-local functional. In principle, we should, for a new functional, determine a ground state electronic density that is consistent with the functional employed. However, CASTEP allows us to be more flexible and to specify a different functional for the band structure calculation. We will use this to save some computational effort by using a LDA-derived ground state density. To begin, carry out a single-point energy calculation on our silicon system using the LDA. This calculation will be very quick. Alongside the .castep file, CASTEP there will also be a file Si2.check. This is the restart file. We will use this restart file to perform a band structure calculation using a different functional from that employed for the SCF. In the Si2.param file, add the following line: continuation : default This tells CASTEP that this is a re-start, and that the restart file is the default, which in this case is Si2.check. We could specify a different file here, if we wished. Add the following line to the .param file: bs_xc_functional : HF This allows us to specify a different functional for the band structure calculation, which in this case will be a Hartree-Fock calculation. However, we are using a LDA-derived ground state density to feed into this calculation. Now run the band structure calculation as before. When examining the .castep output look at the band structure timings. How do these compare to the LDA and GGA cases performed earlier? This should give some idea as to the more computationally intensive nature of a non-local calculation. Similarly, how do the memory estimates change? It is important to understand that this increased memory overhead can limit non-local calculations, even on HPC platforms (indeed, it can be more of a problem than the increased computational effort per step of the calculation). Plot the resulting band structure. How does this compare to the LDA and GGA values? How does the band gap compare? Why is this? Repeat steps 1-5, but for screened exchange with LDA correlation (sX-LDA). To do this, in Step 3 set bs_xc_functional : sX-lda","title":"Example 2 - Si: Non-local functionals"},{"location":"workshop/07_xc/#example-3-feo-and-dftu","text":"In the XC Functional talk, data were shown illustrating the effect of functional upon the electronic structure of antiferromagnetic FeO. In this example you will learn how to perform DFT+U calculations. Get the files required for this exercise : FeO Files We shall carry out these calculations on arcus. Transfer the files to arcus, and unzip and untar them. Open the .cell file. We are interested in examining an anti-ferromagnetic structure. Note the following in the block where the atomic positions are specified: Fe 0.0 0.0 0.0 spin=-4.0 Fe 0.0 0.0 0.0 spin=4.0 This specifies the initial antiferromagnetic spin arrangement, with spin = N_\\text{up}-N_\\text{down} N_\\text{up}-N_\\text{down} defining the initial spin polarisation on each Fe atom. NOTE: the spins specified here should be consistent with the overall spin (i.e. the initial number of unpaired electrons) specified in the .param file using the spin keyword. In this case, as the overall spin is zero (which is the CASTEP default value), we do not need to specify this, but if we examined a ferromagnetic structure then we would. CONVERGENCE NOTE: I suggest using a 6x6x6 MP grid. While not as converged as one would desire for serious science, this is sufficient for demonstrative purposes, and will allow us to perform several calculations in the time available. As we saw in the XC presentation, PBE obtains a metallic ground state for antiferromagnetic FeO. We shall therefore run this calculation as a metal. Ensure that the .param file has the following line: fix_occupancy : false which allows CASTEP to vary electronic occupancies. We shall use the default metals method, which is density mixing. Density mixing is the only method in CASTEP that allows us to specify initial magnetic moments on atoms. The convergence of calculations on metallic systems is often improved by the inclusion of a number of extra empty bands. We can specify this using the nextra_bands keyword. Set this to 14 with: nextra_bands : 14 4. As we wish to examine an anti-ferromagnetic structure in which individual Fe ions have non-zero spin, we must allow the system to be spin-polarised. To do this, open up and edit the .param file. Set: spin_polarized : true 5. We will set the XC functional to be the PBE flavour of GGA ( xc_functional : pbe ). Now run a band structure calculation and produce a band structure plot as before. There are certain features of the band structure plot that you should understand: the dispersive bands are ''sp'' bands derived from ''s'' and ''p'' electrons. The flat non-dispersive bands are derived from Fe ''d'' electrons. Can you explain why the ''d'' bands are so flat? When examining magnetic systems, it is also often useful to examine the spin on each atom. This information can be found in the .castep file in the section Atomic Populations (Mulliken) Note the spin on each Fe atom. How does this vary from the initial value specified?","title":"Example 3 - FeO and DFT+U"},{"location":"workshop/07_xc/#a-dftu-calculation","text":"To do this, open up and edit the .cell file. Add the following block to it: %block hubbard_u Fe 1 d: 2.5 Fe 2 d: 2.5 %endblock hubbard_u This specifies a Hubbard U parameter of 2.5 eV for each Fe ion in the system. Whilst schemes exist to determine the value of U from first principles, in CASTEP it is simply specified as a parameter. Of course, one could use ab initio calculations to determine a value of U then specify this in the .cell file. Run a band structure calculation and plot the results. How does this band structure compare to the PBE+U result? Can you explain which features change and which stay the same? What happens to the band gap? Now examine the spin on each Fe atom. Compare to the PBE values. Can you explain your observations? Repeat steps 7-9 for differing U values. Explain your findings.","title":"A DFT+U calculation"},{"location":"workshop/07_xc/#example-4-graphite-and-dftd","text":"Graphite represents a prototypical example of a layered system in which the layers are weakly bound by van der Waals forces. As is well known, local and semi-local functionals such as the LDA and GGA neglect such interactions, and we could perhaps anticipate that they therefore perform poorly for such a system. We will explore the performance of these functionals. This example will also show you how to run dispersion corrected DFT+D functionals. Get the files required for this exercise : Graphite files As before, we shall carry out these calculations on arcus. Transfer the files to arcus, and unzip and untar them. Open the .param file using a text editor. We will do our first calculation with the PBE GGA functional. Ensure that this is the xc functional specified (see above if you cannot recall how to do this). Graphite has a semimetallic nature, with a non-zero DOS at the Fermi energy for the K and H points in reciprocal space. We will therefore run this calculation as a metal, as we did in the FeO example. Modify the .param file to ensure that this is the case. In contrast to FeO, however, we do not need to worry about spin polarisation. The convergence of calculations on metallic systems is often improved by the inclusion of a number of extra empty bands. We can specify this using the nextra_bands keyword. Set this to 14 with: nextra_bands : 14 We will run a geometry optimisation. Change the .param file so that this is the task. Now open up the .cell file using a text editor. We will perform our calculations for the experimental graphite structure. However, our atomic positions are slightly incommensurate with the symmetry of the unit cell; to remedy this, add the following line to the .cell file: snap_to_symmetry which puts the atoms on the symmetry positions. Now run a variable cell geometry optimisation. If you cannot recall how to do this, consult the earlier tutorial concerning geometry optimisations. Ensure that the calculation is converged with respect to both plane wave and k-point sampling. As we are interested in a geometry optimisation, examining the convergence with respect to force is a suitable criterion. However, as we have placed the ions on high symmetry positions, the forces on them will be zero by symmetry - can you think of how we can still examine the convergence of forces, given this fact? Once the calculation has completed, examine the unit cell parameters - how do they compare to the original (experimental) parameters? Can you explain this behaviour? We shall now investigate what happens with LDA. Repeat the above calculation with the LDA as the XC functional. What happens to the unit cell parameters in this case? Pay particular attention to the c axis. How does this compare to the GGA value? Is this behaviour expected? Can you explain it? Does this mean that LDA is particularly suitable to use to describe van der Waals bound systems? We shall now carry out a GGA calculation with a DFT+D correction. For this you can leave the .cell file unaltered. Open up the .param file using an editor. Add the following line: sedc_apply : true which tells CASTEP that it should apply the semi-empirical dispersion correction (i.e. DFT+D). Now specify the correction scheme. Begin with the G06 scheme (also known as D2): sedc_scheme : g06 Ensure that the XC functional to use is the PBE. Run the geometry optimisation. How do the results compare to the LDA and GGA answers? Repeat 10-13 but using the JCHS correction scheme. How do the results change? NOTE1: the TS scheme is not particularly suitable for such a small unit cell, as the code will warn you. The results should therefore be treated with caution. NOTE2: the OBS scheme is not compatible with the PBE functional.","title":"Example 4 - Graphite and DFT+D"},{"location":"workshop/07_xc/#further-examples","text":"If you have worked through to this point in the tutorial, then feel free to apply these functionals to some more sophisticated systems that interest you. If you do not have particular systems in mind, then feel free to discuss possible choices with a demonstrator.","title":"Further examples"},{"location":"workshop/08_cif2cell/","text":"We will use cif to cell to generate cell files from cif files. Cif files can be obtained from the ICSD (inorganic crystals) or the CSD (molecular crystals). '''MgO''' Examine the file . Look at the crystal structure with jmol or magresview (drag and drop the file onto the magresview window). You will see a cubic face-centre cubic cell. How many atoms in the cell? Use cif2cell to convert this cif file to a cell file. cif2cell MgO.cif --program=castep -o MgO.cell Look at the cell file. How many atoms in the cell? View this will jmol or magresview. Do you understand what cif2cell has done? '''Molecular Tweezers''' Examine the file","title":"8 Cif2cell"},{"location":"workshop/LST_QST/","text":"Transition State Search Tutorial How Transition State Searches Work There have been many suggestions for ways to identify transition states over the years, of which the two most popular are Linear Synchronous Transit / Quadratic Synchronous Transit (LST/QST) and Nudged Elastic Band (NEB) . These two techniques belong to the family of close-ended transition state searches - that is they require both an initial and final structure (reactant and product) and then they attempt to find the lowest barrier between them, the transition state. Open ended searches also exist in the literature, but they find the lowest barrier away from a reactant, which may not be useful for modelling a complex multi-step process. Finally, the gold standard technique (which can be performed in practice but is prohibitively expensive to use for more than verification of transition states) is mode following; the transition state is a stationary state at a saddle point, and accordingly it should have only one imaginary vibrational (phonon) mode. Once a transition structure is predicted, it is possible to perform a phonon calculation in CASTEP to verify this (see phonon tutorials). LST/QST LST/QST is probably the most conceptually simple of the transition state search techniques, and is in itself an extension to the simple LST technique. In LST, a linear interpolation between reactant and product states is made (with a variable weighting), and then the total energy of the system is evaluated at various points (choices of weighting) along this linear interpolation. A bisection search is then performed to find the local maximum along this path. Since LST performs a linear interpolation it is only guaranteed to find the energy maximum on that line - there is no guarantee that this sill in fact be the saddle point. Accordingly in QST , an energy minimisation is performed in directions orthogonal to the LST search direction. This then tends towards the saddle point, improving the estimate of the transition state. It is, however, possible that the QST optimisation will fall off the saddle point, which can make it a tricky process to converge, or cause the saddle point itself to be missed. Example: LST/QST Linear Synchronous Transit/ Quadratic Synchronous Transit (commonly known as LST/QST ) is a quick and reasonably accurate method to find a transition state. In this example, you will determine the transition barrier for a simple (and somewhat uninteresting) reaction, H + H2 -> H2 + H The files for this tutorial may be found at LST_Tutorial Geometry Optimisation Good transition state searches are based upon good structural relaxations of the initial and final states. The first step is therefore to perform geometry optimisations for your reactant H_Initial and product H_Final . Note that ionic constraints have been used in these to prevent translations of 2 of the ions and accelerate the geometry optimisation. You may wish to investigate what happens when these constraints are relaxed. Once you have checked your end points are relaxed (ask if you are unsure how to confirm this!), you will need to create a new block: %block positions_frac_product . . . %endblock positions_frac_product where you need to place the atomic positions from H_Final-out.cell . If doing this manually, you may find the following bash commands useful cp reactant-out.cell TS.cell cat product-out.cell >> TS.cell This will append the contents of a hypothetical product-out.cell to the end of the reactant-out.cell in a new file TS.cell . You will then need to rename the second positions_frac block and delete any repeated entries. FOR THIS TUTORIAL: An Example TS.cell and TS.param file have been provided! Run the TS Search job Using castepsub submit the TS job. Results Interpretation To watch the path of the transition search, you can drag the .ts file into Jmol and watch the animations in the same way outlined in the geometry optimisation tutorial. Try and find the LST Transition State in the .castep file. Is this what you would expect? grep -A 7 \"LST Maximum Found\" TS.castep * Try and find the QST Transition state in the .castep file. grep -A 7 \"Transition State Found\" TS.castep * Can you explain why the QST result seems odd? What about the initial geometry optimisation could be improved to give a better result? Extensions Think about XC-functional choice; LDA overbinds - how does this affect the transition barrier and initial structures? What happens when the transition is between non-adjacent minima in the potential energy landscape? (This would require a more complex example than the tutorial) What about longer distances? When do we need Van der Waal's interactions (DFT+D) ? What effect did the constraints have? Can you improve them?","title":"Transition State Search Tutorial"},{"location":"workshop/LST_QST/#transition-state-search-tutorial","text":"","title":"Transition State Search Tutorial"},{"location":"workshop/LST_QST/#how-transition-state-searches-work","text":"There have been many suggestions for ways to identify transition states over the years, of which the two most popular are Linear Synchronous Transit / Quadratic Synchronous Transit (LST/QST) and Nudged Elastic Band (NEB) . These two techniques belong to the family of close-ended transition state searches - that is they require both an initial and final structure (reactant and product) and then they attempt to find the lowest barrier between them, the transition state. Open ended searches also exist in the literature, but they find the lowest barrier away from a reactant, which may not be useful for modelling a complex multi-step process. Finally, the gold standard technique (which can be performed in practice but is prohibitively expensive to use for more than verification of transition states) is mode following; the transition state is a stationary state at a saddle point, and accordingly it should have only one imaginary vibrational (phonon) mode. Once a transition structure is predicted, it is possible to perform a phonon calculation in CASTEP to verify this (see phonon tutorials).","title":"How Transition State Searches Work"},{"location":"workshop/LST_QST/#lstqst","text":"LST/QST is probably the most conceptually simple of the transition state search techniques, and is in itself an extension to the simple LST technique. In LST, a linear interpolation between reactant and product states is made (with a variable weighting), and then the total energy of the system is evaluated at various points (choices of weighting) along this linear interpolation. A bisection search is then performed to find the local maximum along this path. Since LST performs a linear interpolation it is only guaranteed to find the energy maximum on that line - there is no guarantee that this sill in fact be the saddle point. Accordingly in QST , an energy minimisation is performed in directions orthogonal to the LST search direction. This then tends towards the saddle point, improving the estimate of the transition state. It is, however, possible that the QST optimisation will fall off the saddle point, which can make it a tricky process to converge, or cause the saddle point itself to be missed.","title":"LST/QST"},{"location":"workshop/LST_QST/#example-lstqst","text":"Linear Synchronous Transit/ Quadratic Synchronous Transit (commonly known as LST/QST ) is a quick and reasonably accurate method to find a transition state. In this example, you will determine the transition barrier for a simple (and somewhat uninteresting) reaction, H + H2 -> H2 + H The files for this tutorial may be found at LST_Tutorial Geometry Optimisation Good transition state searches are based upon good structural relaxations of the initial and final states. The first step is therefore to perform geometry optimisations for your reactant H_Initial and product H_Final . Note that ionic constraints have been used in these to prevent translations of 2 of the ions and accelerate the geometry optimisation. You may wish to investigate what happens when these constraints are relaxed. Once you have checked your end points are relaxed (ask if you are unsure how to confirm this!), you will need to create a new block: %block positions_frac_product . . . %endblock positions_frac_product where you need to place the atomic positions from H_Final-out.cell . If doing this manually, you may find the following bash commands useful cp reactant-out.cell TS.cell cat product-out.cell >> TS.cell This will append the contents of a hypothetical product-out.cell to the end of the reactant-out.cell in a new file TS.cell . You will then need to rename the second positions_frac block and delete any repeated entries. FOR THIS TUTORIAL: An Example TS.cell and TS.param file have been provided! Run the TS Search job Using castepsub submit the TS job. Results Interpretation To watch the path of the transition search, you can drag the .ts file into Jmol and watch the animations in the same way outlined in the geometry optimisation tutorial. Try and find the LST Transition State in the .castep file. Is this what you would expect? grep -A 7 \"LST Maximum Found\" TS.castep * Try and find the QST Transition state in the .castep file. grep -A 7 \"Transition State Found\" TS.castep * Can you explain why the QST result seems odd? What about the initial geometry optimisation could be improved to give a better result?","title":"Example: LST/QST"},{"location":"workshop/LST_QST/#extensions","text":"Think about XC-functional choice; LDA overbinds - how does this affect the transition barrier and initial structures? What happens when the transition is between non-adjacent minima in the potential energy landscape? (This would require a more complex example than the tutorial) What about longer distances? When do we need Van der Waal's interactions (DFT+D) ? What effect did the constraints have? Can you improve them?","title":"Extensions"},{"location":"workshop/optados/6a_dos/","text":"Density of States Outline This is a simple example of using optados for calculating electronic density of states of crystalline silicon in a 2 atom cell. It shows how optados's adaptive broadening can be used to resolve fine spectral features that a fixed broadening scheme will obscure. Input Files: examples/Si2_DOS/Si2.cell - The castep cell file containing information about the simulation cell. examples/Si2_DOS/Si2.param - The castep param file containing information about the parameters for the SCF and spectral calculations. examples/Si2_DOS/Si2.odi - The optados input file, containing the parameters necessary to run optados. Instructions: Perform a castep calculation on the bulk silicon using the Si2.cell and Si2.param input files. $ castepsub -n 16 Si2 This should take a couple of seconds to run. Examine the optados input file - Si2.odi Perform an optados calculation. $ optados Si2 This generates 3 files: Si2.odo -- optados general output file. Si2.adaptive.dat -- The adaptive broadened DOS raw output data. Si2.adaptive.agr -- The adaptive broadened DOS in a file suitable to be plotted by xmgrace. Examine the Si2.odo file. optados has performed a Density of States calculation. +--------------- Fermi Energy Analysis ------------------------+ | From Adaptive broadening | | Spin Component:1 occupation between 3.99961 and 4.00003 <-Oc | | Spin Component:2 occupation between 3.99961 and 4.00003 <-Oc | | Fermi energy (Adaptive broadening) : 5.4109 eV <- EfA | +--------------------------------------------------------------+ It has used the integrated DOS to work out the Fermi level, and has suggested the error in the integration by indicating the number of electrons at the Fermi level. Since we had 4 up electrons and 4 down in the input file this analysis seems satisfactory. +----------------------- Electronic Data ---------------------+ | Number of Bands : 23 | | Grid size : 10 x 10 x 10 | | Number of K-points : 110 | | Spin-Polarised Calculation : True | | Number of up-spin electrons : 4.00 | | Number of down-spin electrons : 4.00 | +-------------------------------------------------------------+ Since we had efermi : optados , optados sets the internal value of the Fermi level to the one it has derived from the DOS. This is important for subsequent calculations. Other valid options are file , where optados uses the value calculated by the electronic structure code that generated the eigenvalues; insulator , where optados uses a value calculated from assuming the system is non-metallic; or a value set by the user. optados now performs some analysis of the DOS at the Fermi level, +-------------- DOS at Fermi Energy Analysis ----------------+ | Fermi energy used : 5.4109 eV | | From Adaptive broadening | | Spin Component:1 DOS at Fermi Energy:0.0011 eln/cell <-DEA | | Spin Component:2 DOS at Fermi Energy:0.0011 eln/cell<- DEA | +------------------------------------------------------------+ From this we may assume that there is a band gap. Importantly, then optados calculates the band energy from the DOS is has calculated. +------------------- Band Energy Analysis -------------------+ | Band energy (Adaptive broadening) : 1.3609 eV <- BEA | | Band energy (From CASTEP) : 1.3622 eV <- BEC | +------------------------------------------------------------+ As the quality of the optados calculation is increased these two values should converge to the same answer. Finally optados shifts the Fermi level to 0 eV, for the output files. The DOS is written to Si2.adaptive.dat . This contains 5 columns as described in the header of the file: ################################################################ # # O p t a D O S o u t p u t f i l e # # Density of States using adaptive broadening # Generated on 12 Feb 2012 at 16:50:37 # Column Data # 1 Energy (eV) # 2 Up-spin DOS (electrons per eV) # 3 Down-spin DOS (electrons per eV) # 4 Up-spin Integrated DOS (electrons) # 5 Down-spin Integrated DOS (electrons) # ################################################################ This file can be plotted by your favourite graph-plotting software. However, optados has made things easy and generated a Si2.adaptive.agr file which is directly plottable using xmgrace . $ xmgrace Si2.adaptive.agr 1. We now try again with a better sampling of the DOS, by setting DOS_SPACING : 0.001 and also analyse the band gap, by setting COMPUTE_BAND_GAP : true . You can set IPRINT : 2 to see a progress report in Si2.odo . In Si2.odo we now have a new section analysing the band gap in various ways. +----------------------------- Bandgap Analysis ---------------+ | Number of kpoints at VBM CBM | | Spin : 1 : 1 1 | | Spin : 2 : 1 1 | | Thermal Bandgap : 0.6676272107 eV <- TBg | | Between VBM kpoint : 0.05000 0.05000 0.05000| | and CBM kpoint: -0.45000 -0.05000 -0.45000| | ==> Indirect Gap | +--------------------------------------------------------------+ | Optical Bandgap | | Spin : 1 : 2.5542517447 eV <- OBg | | Spin : 2 : 2.5542463024 eV <- OBg | | Number of kpoints with this gap | | Spin : 1 : 1 | | Spin : 2 : 1 | +--------------------------------------------------------------+ | Average Bandgap | | Spin : 1 : 3.8121372691 eV <- ABg | | Spin : 2 : 3.8121342659 eV <- ABg | | Weighted Average : 3.8121357675 eV <- wAB | +--------------------------------------------------------------+ optados is very careful in its band gap analysis. It uses the bare eigenvalues (un-broadened) and works out the nature and size of the thermal gap, optical gap and the average gap over all of the Brillouin zone. In cases of multi-valleyed semiconductors optados will report the number of conduction band minima or valence band maxima with identical energies, but will not report the nature of the gap. Increasing the number of integration points has improved the band energy of the adaptive smearing: | Band energy (Adaptive broadening) : 1.3623 eV <- BEA | We will now compare the DOS with the adaptive broadening scheme with simple Gaussian smearing. In the optados input file ( Si2.odi ) change the value of BROADENING to fixed . Plotting the fixed broadened DOS over the adaptive we see the advantages of the adaptive broadening. xmgrace Si2.adaptive.agr Si2.fixed.age","title":"6a DOS"},{"location":"workshop/optados/6a_dos/#density-of-states","text":"","title":"Density of States"},{"location":"workshop/optados/6a_dos/#outline","text":"This is a simple example of using optados for calculating electronic density of states of crystalline silicon in a 2 atom cell. It shows how optados's adaptive broadening can be used to resolve fine spectral features that a fixed broadening scheme will obscure.","title":"Outline"},{"location":"workshop/optados/6a_dos/#input-files","text":"examples/Si2_DOS/Si2.cell - The castep cell file containing information about the simulation cell. examples/Si2_DOS/Si2.param - The castep param file containing information about the parameters for the SCF and spectral calculations. examples/Si2_DOS/Si2.odi - The optados input file, containing the parameters necessary to run optados.","title":"Input Files:"},{"location":"workshop/optados/6a_dos/#instructions","text":"Perform a castep calculation on the bulk silicon using the Si2.cell and Si2.param input files. $ castepsub -n 16 Si2 This should take a couple of seconds to run. Examine the optados input file - Si2.odi Perform an optados calculation. $ optados Si2 This generates 3 files: Si2.odo -- optados general output file. Si2.adaptive.dat -- The adaptive broadened DOS raw output data. Si2.adaptive.agr -- The adaptive broadened DOS in a file suitable to be plotted by xmgrace. Examine the Si2.odo file. optados has performed a Density of States calculation. +--------------- Fermi Energy Analysis ------------------------+ | From Adaptive broadening | | Spin Component:1 occupation between 3.99961 and 4.00003 <-Oc | | Spin Component:2 occupation between 3.99961 and 4.00003 <-Oc | | Fermi energy (Adaptive broadening) : 5.4109 eV <- EfA | +--------------------------------------------------------------+ It has used the integrated DOS to work out the Fermi level, and has suggested the error in the integration by indicating the number of electrons at the Fermi level. Since we had 4 up electrons and 4 down in the input file this analysis seems satisfactory. +----------------------- Electronic Data ---------------------+ | Number of Bands : 23 | | Grid size : 10 x 10 x 10 | | Number of K-points : 110 | | Spin-Polarised Calculation : True | | Number of up-spin electrons : 4.00 | | Number of down-spin electrons : 4.00 | +-------------------------------------------------------------+ Since we had efermi : optados , optados sets the internal value of the Fermi level to the one it has derived from the DOS. This is important for subsequent calculations. Other valid options are file , where optados uses the value calculated by the electronic structure code that generated the eigenvalues; insulator , where optados uses a value calculated from assuming the system is non-metallic; or a value set by the user. optados now performs some analysis of the DOS at the Fermi level, +-------------- DOS at Fermi Energy Analysis ----------------+ | Fermi energy used : 5.4109 eV | | From Adaptive broadening | | Spin Component:1 DOS at Fermi Energy:0.0011 eln/cell <-DEA | | Spin Component:2 DOS at Fermi Energy:0.0011 eln/cell<- DEA | +------------------------------------------------------------+ From this we may assume that there is a band gap. Importantly, then optados calculates the band energy from the DOS is has calculated. +------------------- Band Energy Analysis -------------------+ | Band energy (Adaptive broadening) : 1.3609 eV <- BEA | | Band energy (From CASTEP) : 1.3622 eV <- BEC | +------------------------------------------------------------+ As the quality of the optados calculation is increased these two values should converge to the same answer. Finally optados shifts the Fermi level to 0 eV, for the output files. The DOS is written to Si2.adaptive.dat . This contains 5 columns as described in the header of the file: ################################################################ # # O p t a D O S o u t p u t f i l e # # Density of States using adaptive broadening # Generated on 12 Feb 2012 at 16:50:37 # Column Data # 1 Energy (eV) # 2 Up-spin DOS (electrons per eV) # 3 Down-spin DOS (electrons per eV) # 4 Up-spin Integrated DOS (electrons) # 5 Down-spin Integrated DOS (electrons) # ################################################################ This file can be plotted by your favourite graph-plotting software. However, optados has made things easy and generated a Si2.adaptive.agr file which is directly plottable using xmgrace . $ xmgrace Si2.adaptive.agr 1. We now try again with a better sampling of the DOS, by setting DOS_SPACING : 0.001 and also analyse the band gap, by setting COMPUTE_BAND_GAP : true . You can set IPRINT : 2 to see a progress report in Si2.odo . In Si2.odo we now have a new section analysing the band gap in various ways. +----------------------------- Bandgap Analysis ---------------+ | Number of kpoints at VBM CBM | | Spin : 1 : 1 1 | | Spin : 2 : 1 1 | | Thermal Bandgap : 0.6676272107 eV <- TBg | | Between VBM kpoint : 0.05000 0.05000 0.05000| | and CBM kpoint: -0.45000 -0.05000 -0.45000| | ==> Indirect Gap | +--------------------------------------------------------------+ | Optical Bandgap | | Spin : 1 : 2.5542517447 eV <- OBg | | Spin : 2 : 2.5542463024 eV <- OBg | | Number of kpoints with this gap | | Spin : 1 : 1 | | Spin : 2 : 1 | +--------------------------------------------------------------+ | Average Bandgap | | Spin : 1 : 3.8121372691 eV <- ABg | | Spin : 2 : 3.8121342659 eV <- ABg | | Weighted Average : 3.8121357675 eV <- wAB | +--------------------------------------------------------------+ optados is very careful in its band gap analysis. It uses the bare eigenvalues (un-broadened) and works out the nature and size of the thermal gap, optical gap and the average gap over all of the Brillouin zone. In cases of multi-valleyed semiconductors optados will report the number of conduction band minima or valence band maxima with identical energies, but will not report the nature of the gap. Increasing the number of integration points has improved the band energy of the adaptive smearing: | Band energy (Adaptive broadening) : 1.3623 eV <- BEA | We will now compare the DOS with the adaptive broadening scheme with simple Gaussian smearing. In the optados input file ( Si2.odi ) change the value of BROADENING to fixed . Plotting the fixed broadened DOS over the adaptive we see the advantages of the adaptive broadening. xmgrace Si2.adaptive.agr Si2.fixed.age","title":"Instructions:"},{"location":"workshop/optados/6b_pdos/","text":"Projected Density of States We assume the reader is familiar with the previous section on Density of States calculations and is now familiar with running optados . Outline This is a simple example of using optados for calculating electronic density of states of 2 atoms of crystalline silicon projected onto LCAO basis states. Input Files examples/Si2_PDOS/Si2.cell - The castep .cell file containing information about the simulation cell. examples/Si2_PDOS/Si2.param - The castep .param file containing information about the parameters for the SCF and spectral calculations. examples/Si2_PDOS/Si2.odi - The optados input file, containing the parameters necessary to run optados. Instructions: Examine the optados input file noting TASK : pdos . We choose to decompose the DOS into angular momentum channels PDOS : angular and as in the previous example we choose to recalculate the Fermi level using the calculated DOS, rather than use the Fermi level suggested by castep. Execute optados. The output can be found in Si2.pdos.dat . ################################################################ # # O p t a D O S o u t p u t f i l e # # Generated on 13 Feb 2012 at 10:15:10 ################################################################ #+-------------------------------------------------------------+ #| Partial Density of States -- Projectors | #+-------------------------------------------------------------+ #| Projector: 1 contains: | #| Atom AngM Channel | #| Si 1 s | #| Si 2 s | #+-------------------------------------------------------------+ #| Projector: 2 contains: | #| Atom AngM Channel | #| Si 1 p | #| Si 2 p | #+-------------------------------------------------------------+ #| Projector: 3 contains: | #| Atom AngM Channel | #| Si 1 d | #| Si 2 d | #+-------------------------------------------------------------+ #| Projector: 4 contains: | #| Atom AngM Channel | #| Si 1 f | #| Si 2 f | #+-------------------------------------------------------------+ The header shows that there are four projectors described below. The first containing the s-channels of both silicon atoms, the second the p-channels etc. The output is easily plotted using xmgrace . Setting DOS_SPACING : 0.001 gives a high quality plot, as shown in the figure below. Density of States of Silicon generated by adaptive broadening projected onto LCAO momentum states Other projections to try are: PDOS : Si1;Si2(s) -- Output the PDOS on Si atom 1 and the PDOS on the s-channel of Si atom 2. (Resulting in two projectors) PDOS : sum:Si1-2(s) -- Output the sum of the s-channels on the two Si atoms. (Resulting in one projector) PDOS : Si1(p) -- Output the p-channel on Si atom 1. (Resulting in one projector)","title":"6b Projected DOS"},{"location":"workshop/optados/6b_pdos/#projected-density-of-states","text":"We assume the reader is familiar with the previous section on Density of States calculations and is now familiar with running optados .","title":"Projected Density of States"},{"location":"workshop/optados/6b_pdos/#outline","text":"This is a simple example of using optados for calculating electronic density of states of 2 atoms of crystalline silicon projected onto LCAO basis states.","title":"Outline"},{"location":"workshop/optados/6b_pdos/#input-files","text":"examples/Si2_PDOS/Si2.cell - The castep .cell file containing information about the simulation cell. examples/Si2_PDOS/Si2.param - The castep .param file containing information about the parameters for the SCF and spectral calculations. examples/Si2_PDOS/Si2.odi - The optados input file, containing the parameters necessary to run optados.","title":"Input Files"},{"location":"workshop/optados/6b_pdos/#instructions","text":"Examine the optados input file noting TASK : pdos . We choose to decompose the DOS into angular momentum channels PDOS : angular and as in the previous example we choose to recalculate the Fermi level using the calculated DOS, rather than use the Fermi level suggested by castep. Execute optados. The output can be found in Si2.pdos.dat . ################################################################ # # O p t a D O S o u t p u t f i l e # # Generated on 13 Feb 2012 at 10:15:10 ################################################################ #+-------------------------------------------------------------+ #| Partial Density of States -- Projectors | #+-------------------------------------------------------------+ #| Projector: 1 contains: | #| Atom AngM Channel | #| Si 1 s | #| Si 2 s | #+-------------------------------------------------------------+ #| Projector: 2 contains: | #| Atom AngM Channel | #| Si 1 p | #| Si 2 p | #+-------------------------------------------------------------+ #| Projector: 3 contains: | #| Atom AngM Channel | #| Si 1 d | #| Si 2 d | #+-------------------------------------------------------------+ #| Projector: 4 contains: | #| Atom AngM Channel | #| Si 1 f | #| Si 2 f | #+-------------------------------------------------------------+ The header shows that there are four projectors described below. The first containing the s-channels of both silicon atoms, the second the p-channels etc. The output is easily plotted using xmgrace . Setting DOS_SPACING : 0.001 gives a high quality plot, as shown in the figure below. Density of States of Silicon generated by adaptive broadening projected onto LCAO momentum states Other projections to try are: PDOS : Si1;Si2(s) -- Output the PDOS on Si atom 1 and the PDOS on the s-channel of Si atom 2. (Resulting in two projectors) PDOS : sum:Si1-2(s) -- Output the sum of the s-channels on the two Si atoms. (Resulting in one projector) PDOS : Si1(p) -- Output the p-channel on Si atom 1. (Resulting in one projector)","title":"Instructions:"},{"location":"workshop/optados/6c_coreloss/","text":"Calculation of core-loss spectra for hBN We begin by running a CASTEP calculation using the files provided. Note that we specify a pseudopotential file for one B atom and both N atom, and use an on-the-fly pseudopotential for the other B atom. This looks a bit weird! It is simply a way to only compute the EELS for one atomic site (core-loss spectra can only be computed for atoms described by on-the-fly potentials). Execute optados using the optados input file provided and the file hBN_core_edge.dat will be created. The file contains two columns, the first is the energy and the second is the spectrum. This file contains the following edges: B 1 K1 B:1 OptaDOS has also written a grace file $ xmgrace hBN_core_edge.agr This spectrum has lots of fine detail. To compare with experiment we can include lifetime and instrument broadening effects. First let's add some Gaussian broadening to simulate instrument effects. Add the following the odi file and re-run. CORE_LAI_BROADENING : true LAI_GAUSSIAN_WIDTH : 1.0 The file hBN_core_edge.dat now has three columns. The third column is the broadened spectrum. To compare the broadened and un-broadened spectra xmgrace hBN_core_edge_broad.agr hBN_core_edge.agr Now add some lifetime broadening (look up the meaning of the keywords in the optados user guide) LAI_LORENTZIAN_WIDTH : 0.5 LAI_LORENTZIAN_SCALE : 0.1 Now try running CASTEP and OptaDOS to produce a N K-edge Including a core-hole First we will include a core-hole on atom B:1. To do this we add a modified pseudopotential string into the hBN.cell file B:1 2|1.2|12|14|16|20:21{1s1.00}(qc=8) The core-hole is created by removing a 1s electron from the electronic configuration used in the generation of the pseudopotential. Information about the pseudopotential is included at the top of the hBN.castep file ============================================================ | Pseudopotential Report - Date of generation 17-08-2018 | ------------------------------------------------------------ | Element: B Ionic charge: 3.00 Level of theory: PBE | | Atomic Solver: Koelling-Harmon | | | | Reference Electronic Structure | | Orbital Occupation Energy | | 2s 2.000 -0.347 | | 2p 1.000 -0.133 | | | | Pseudopotential Definition | | Beta l e Rc scheme norm | | 1 0 -0.347 1.199 qc 0 | | 2 0 0.250 1.199 qc 0 | | 3 1 -0.133 1.199 qc 0 | | 4 1 0.250 1.199 qc 0 | | loc 2 0.000 1.199 pn 0 | | | | Augmentation charge Rinner = 0.838 | | Partial core correction Rc = 0.838 | ------------------------------------------------------------ | \"2|1.2|12|14|16|20:21(qc=8)\" | ------------------------------------------------------------ | Author: Chris J. Pickard, Cambridge University | ============================================================ The line | \"2|1.2|12|14|16|20:21(qc=8)\" | specifies the parameters used to create the OFT B pseudopotential. We use this as a starting point and remove one of the core 1s electrons to create the core-hole pseudopotential by including {1s1.00} . To maintain the neutrality of the cell, we include CHARGE : +1 in the hBN.param file. Run the calculation. Compare the K-edge from the core-hole calculation with the previous non-core-hole calculation. The periodic images of the core-hole will interact with one another. As this is unphysical, we need to increase the distance between the core-holes. This is done by creating a supercell. Create a 2x2x1 supercell (talk to one of the tutors if you\u2019re unsure about how to do this) and carry out another core-loss B K-edge simulation. Compare the spectra to that from the primitive cell. Construct larger and larger unit cells until the spectrum stops changing with increasing separation between the periodic images. Other things to try include: Include the core-hole on the N atom rather than the B Compare your simulated spectra to experimental data (the EELS database is a good place to find experimental data) Compare to spectra from cubic BN Calculating spectra from graphite (graphene) and diamond","title":"6c Coreloss"},{"location":"workshop/optados/6c_coreloss/#calculation-of-core-loss-spectra-for-hbn","text":"We begin by running a CASTEP calculation using the files provided. Note that we specify a pseudopotential file for one B atom and both N atom, and use an on-the-fly pseudopotential for the other B atom. This looks a bit weird! It is simply a way to only compute the EELS for one atomic site (core-loss spectra can only be computed for atoms described by on-the-fly potentials). Execute optados using the optados input file provided and the file hBN_core_edge.dat will be created. The file contains two columns, the first is the energy and the second is the spectrum. This file contains the following edges: B 1 K1 B:1 OptaDOS has also written a grace file $ xmgrace hBN_core_edge.agr This spectrum has lots of fine detail. To compare with experiment we can include lifetime and instrument broadening effects. First let's add some Gaussian broadening to simulate instrument effects. Add the following the odi file and re-run. CORE_LAI_BROADENING : true LAI_GAUSSIAN_WIDTH : 1.0 The file hBN_core_edge.dat now has three columns. The third column is the broadened spectrum. To compare the broadened and un-broadened spectra xmgrace hBN_core_edge_broad.agr hBN_core_edge.agr Now add some lifetime broadening (look up the meaning of the keywords in the optados user guide) LAI_LORENTZIAN_WIDTH : 0.5 LAI_LORENTZIAN_SCALE : 0.1 Now try running CASTEP and OptaDOS to produce a N K-edge","title":"Calculation of core-loss spectra for hBN"},{"location":"workshop/optados/6c_coreloss/#including-a-core-hole","text":"First we will include a core-hole on atom B:1. To do this we add a modified pseudopotential string into the hBN.cell file B:1 2|1.2|12|14|16|20:21{1s1.00}(qc=8) The core-hole is created by removing a 1s electron from the electronic configuration used in the generation of the pseudopotential. Information about the pseudopotential is included at the top of the hBN.castep file ============================================================ | Pseudopotential Report - Date of generation 17-08-2018 | ------------------------------------------------------------ | Element: B Ionic charge: 3.00 Level of theory: PBE | | Atomic Solver: Koelling-Harmon | | | | Reference Electronic Structure | | Orbital Occupation Energy | | 2s 2.000 -0.347 | | 2p 1.000 -0.133 | | | | Pseudopotential Definition | | Beta l e Rc scheme norm | | 1 0 -0.347 1.199 qc 0 | | 2 0 0.250 1.199 qc 0 | | 3 1 -0.133 1.199 qc 0 | | 4 1 0.250 1.199 qc 0 | | loc 2 0.000 1.199 pn 0 | | | | Augmentation charge Rinner = 0.838 | | Partial core correction Rc = 0.838 | ------------------------------------------------------------ | \"2|1.2|12|14|16|20:21(qc=8)\" | ------------------------------------------------------------ | Author: Chris J. Pickard, Cambridge University | ============================================================ The line | \"2|1.2|12|14|16|20:21(qc=8)\" | specifies the parameters used to create the OFT B pseudopotential. We use this as a starting point and remove one of the core 1s electrons to create the core-hole pseudopotential by including {1s1.00} . To maintain the neutrality of the cell, we include CHARGE : +1 in the hBN.param file. Run the calculation. Compare the K-edge from the core-hole calculation with the previous non-core-hole calculation. The periodic images of the core-hole will interact with one another. As this is unphysical, we need to increase the distance between the core-holes. This is done by creating a supercell. Create a 2x2x1 supercell (talk to one of the tutors if you\u2019re unsure about how to do this) and carry out another core-loss B K-edge simulation. Compare the spectra to that from the primitive cell. Construct larger and larger unit cells until the spectrum stops changing with increasing separation between the periodic images. Other things to try include: Include the core-hole on the N atom rather than the B Compare your simulated spectra to experimental data (the EELS database is a good place to find experimental data) Compare to spectra from cubic BN Calculating spectra from graphite (graphene) and diamond","title":"Including a core-hole"},{"location":"workshop/optados/6d_lowloss/","text":"JDOS and OPTICS Joint DOS See examples/Si2_JDOS . This is a simple example of using optados for calculating joint electronic density of states. We choose to recalculate the Fermi level using the calculated DOS, rather than use the Fermi level suggested by castep, and so EFERMI: OPTADOS is included in the Si2.odi file. Execute castep and optados using the example files. The JDOS is written to Si2.jadaptive.dat . A file suitable for plotting using xmgrace is written to Si2.jadaptive.agr . Check the effect of changing the sampling by increasing and decreasing the value of JDOS_SPACING in the Si2.odi file. Optics Two sets of example files are provided for calculations of optical properties. For each example, the .castep files containing all the cell and simulation parameters are included, along with an optados input file. We assume that the reader is familiar with the previous sections on DOS and JDOS. Silicon See examples/Si2_OPTICS/ . This is a simple example of using optados to calculate the optical properties of crystalline silicon, which is an insulator. Instructions: Execute optados to calculate the optical properties. Several .dat files are produced: Si2_OPTICS_absorption.dat : This file contains the absorption coefficient (second column) as function of energy (first column). Si2_OPTICS_conductivity.dat : This file contains the conductivity outputted in SI units (Siemens per metre). The columns are the energy, real part and imaginary part of the conductivity respectively. Si2_OPTICS_epsilon.dat : This file contains the dielectric function. The columns are the energy and real and imaginary parts of the dielectric function respectively. The file header also includes the result of the sum rule \\int_0^{\\omega'} \\textrm{Im} \\epsilon(\\omega) \\mathrm{d}\\omega = N_\\textrm{eff}(\\omega') \\int_0^{\\omega'} \\textrm{Im} \\epsilon(\\omega) \\mathrm{d}\\omega = N_\\textrm{eff}(\\omega') . N_\\textrm{eff} N_\\textrm{eff} is the effective number of electrons contributing to the absorption process, and is a function of energy. Si2_OPTICS_loss_fn.dat : This file contains the loss function (second column) as a function of energy (first column). The header of the file shows the results of the two sum rules associated with the loss function \\int_0^{\\omega'} \\textrm{Im} -\\frac{1}{\\epsilon(\\omega)}\\omega \\mathrm{d}\\omega = N_\\textrm{eff} \\int_0^{\\omega'} \\textrm{Im} -\\frac{1}{\\epsilon(\\omega)}\\omega \\mathrm{d}\\omega = N_\\textrm{eff} and \\int_0^{\\omega'} \\textrm{Im} -\\frac{1}{\\epsilon(\\omega)}\\frac{1}{\\omega} \\mathrm{d}\\omega = \\frac{\\pi}{2} \\int_0^{\\omega'} \\textrm{Im} -\\frac{1}{\\epsilon(\\omega)}\\frac{1}{\\omega} \\mathrm{d}\\omega = \\frac{\\pi}{2} Si2_OPTICS_reflection.dat : This file contains the reflection coefficient (second column) as a function of energy (first column). Si2_OPTICS_refractive_index.dat : This file contains the refractive index. The columns are the energy and real and imaginary parts of the refractive index respectively. Corresponding .agr files are also generated which can be plotted easily using xmgrace. Change parameters JDOS_SPACING and JDOS_MAX and check the effect on the optical properties. Note: all of the other optical properties are derived from the dielectric function. The optados input file has been set up to calculate the optical properties in the polycrystalline geometry ( optics_geom = polycrystalline ). It is possible to calculate either polarised or unpolarised geometries, or to calculate the full dielectric tensor. To calculate the full dielectric tensor set optics_geom = tensor . This time only the file Si2_OPTICS_epsilon.dat is generated. The format of this file is the same as before (the columns are the energy and the real and imaginary parts of the dielectric function respectively), but this time the six different components of the tensor are listed sequentially in the order \\epsilon_{xx} \\epsilon_{xx} , \\epsilon_{yy} \\epsilon_{yy} , \\epsilon_{zz} \\epsilon_{zz} , \\epsilon_{xy} \\epsilon_{xy} , \\epsilon_{xz} \\epsilon_{xz} and \\epsilon_{yz} \\epsilon_{yz} . Additional broadening can be included in the calculation of the loss function. This is done by including the keyword optics_lossfn_broadening in the optados input file. If you include this keyword and re-run optados, you will find that the file Si2_OPTICS_loss_fn.dat now has three columns. These are the energy, unbroadened spectrum and broadened spectrum respectively. Aluminium Aluminium is a metal so we need to include both the interband and intraband contributions to the dielectric function. To include the intraband contribution optics_intraband = true must be included in the optados input file. When you run optados, the same files are generated as when only the interband term is included. The Al_OPTICS_epsilon.dat file has the same format as before, but it now contains sequentially the interband contribution, the intraband contribution and the total dielectric function. The file Al_OPTICS_epsilon.agr only contains the interband term. In the same way, Al_OPTICS_loss_fn.dat contains the interband contribution, intraband contribution and total loss function. All other optical properties are calculated from the total dielectric function and the format of the output files remains the same. In the case where the dielectric tensor is calculated and the intraband term is included, only the Al_OPTICS_epsilon.dat file is generated. As before it contains each component, but this time it lists sequentially the interband contribution, intraband contribution and total dielectric function for each component. This time, if additional broadening for the loss function is included by using the key word optics_lossfn_broadening , AL_OPTICS_loss_fn.dat will contains four sequential data sets. These are the interband contribution, the intraband contribution, the total loss function without the additional broadening and the broadened total loss function.","title":"6d Lowloss"},{"location":"workshop/optados/6d_lowloss/#jdos-and-optics","text":"","title":"JDOS and OPTICS"},{"location":"workshop/optados/6d_lowloss/#joint-dos","text":"See examples/Si2_JDOS . This is a simple example of using optados for calculating joint electronic density of states. We choose to recalculate the Fermi level using the calculated DOS, rather than use the Fermi level suggested by castep, and so EFERMI: OPTADOS is included in the Si2.odi file. Execute castep and optados using the example files. The JDOS is written to Si2.jadaptive.dat . A file suitable for plotting using xmgrace is written to Si2.jadaptive.agr . Check the effect of changing the sampling by increasing and decreasing the value of JDOS_SPACING in the Si2.odi file.","title":"Joint DOS"},{"location":"workshop/optados/6d_lowloss/#optics","text":"Two sets of example files are provided for calculations of optical properties. For each example, the .castep files containing all the cell and simulation parameters are included, along with an optados input file. We assume that the reader is familiar with the previous sections on DOS and JDOS.","title":"Optics"},{"location":"workshop/optados/6d_lowloss/#silicon","text":"See examples/Si2_OPTICS/ . This is a simple example of using optados to calculate the optical properties of crystalline silicon, which is an insulator. Instructions: Execute optados to calculate the optical properties. Several .dat files are produced: Si2_OPTICS_absorption.dat : This file contains the absorption coefficient (second column) as function of energy (first column). Si2_OPTICS_conductivity.dat : This file contains the conductivity outputted in SI units (Siemens per metre). The columns are the energy, real part and imaginary part of the conductivity respectively. Si2_OPTICS_epsilon.dat : This file contains the dielectric function. The columns are the energy and real and imaginary parts of the dielectric function respectively. The file header also includes the result of the sum rule \\int_0^{\\omega'} \\textrm{Im} \\epsilon(\\omega) \\mathrm{d}\\omega = N_\\textrm{eff}(\\omega') \\int_0^{\\omega'} \\textrm{Im} \\epsilon(\\omega) \\mathrm{d}\\omega = N_\\textrm{eff}(\\omega') . N_\\textrm{eff} N_\\textrm{eff} is the effective number of electrons contributing to the absorption process, and is a function of energy. Si2_OPTICS_loss_fn.dat : This file contains the loss function (second column) as a function of energy (first column). The header of the file shows the results of the two sum rules associated with the loss function \\int_0^{\\omega'} \\textrm{Im} -\\frac{1}{\\epsilon(\\omega)}\\omega \\mathrm{d}\\omega = N_\\textrm{eff} \\int_0^{\\omega'} \\textrm{Im} -\\frac{1}{\\epsilon(\\omega)}\\omega \\mathrm{d}\\omega = N_\\textrm{eff} and \\int_0^{\\omega'} \\textrm{Im} -\\frac{1}{\\epsilon(\\omega)}\\frac{1}{\\omega} \\mathrm{d}\\omega = \\frac{\\pi}{2} \\int_0^{\\omega'} \\textrm{Im} -\\frac{1}{\\epsilon(\\omega)}\\frac{1}{\\omega} \\mathrm{d}\\omega = \\frac{\\pi}{2} Si2_OPTICS_reflection.dat : This file contains the reflection coefficient (second column) as a function of energy (first column). Si2_OPTICS_refractive_index.dat : This file contains the refractive index. The columns are the energy and real and imaginary parts of the refractive index respectively. Corresponding .agr files are also generated which can be plotted easily using xmgrace. Change parameters JDOS_SPACING and JDOS_MAX and check the effect on the optical properties. Note: all of the other optical properties are derived from the dielectric function. The optados input file has been set up to calculate the optical properties in the polycrystalline geometry ( optics_geom = polycrystalline ). It is possible to calculate either polarised or unpolarised geometries, or to calculate the full dielectric tensor. To calculate the full dielectric tensor set optics_geom = tensor . This time only the file Si2_OPTICS_epsilon.dat is generated. The format of this file is the same as before (the columns are the energy and the real and imaginary parts of the dielectric function respectively), but this time the six different components of the tensor are listed sequentially in the order \\epsilon_{xx} \\epsilon_{xx} , \\epsilon_{yy} \\epsilon_{yy} , \\epsilon_{zz} \\epsilon_{zz} , \\epsilon_{xy} \\epsilon_{xy} , \\epsilon_{xz} \\epsilon_{xz} and \\epsilon_{yz} \\epsilon_{yz} . Additional broadening can be included in the calculation of the loss function. This is done by including the keyword optics_lossfn_broadening in the optados input file. If you include this keyword and re-run optados, you will find that the file Si2_OPTICS_loss_fn.dat now has three columns. These are the energy, unbroadened spectrum and broadened spectrum respectively.","title":"Silicon"},{"location":"workshop/optados/6d_lowloss/#aluminium","text":"Aluminium is a metal so we need to include both the interband and intraband contributions to the dielectric function. To include the intraband contribution optics_intraband = true must be included in the optados input file. When you run optados, the same files are generated as when only the interband term is included. The Al_OPTICS_epsilon.dat file has the same format as before, but it now contains sequentially the interband contribution, the intraband contribution and the total dielectric function. The file Al_OPTICS_epsilon.agr only contains the interband term. In the same way, Al_OPTICS_loss_fn.dat contains the interband contribution, intraband contribution and total loss function. All other optical properties are calculated from the total dielectric function and the format of the output files remains the same. In the case where the dielectric tensor is calculated and the intraband term is included, only the Al_OPTICS_epsilon.dat file is generated. As before it contains each component, but this time it lists sequentially the interband contribution, intraband contribution and total dielectric function for each component. This time, if additional broadening for the loss function is included by using the key word optics_lossfn_broadening , AL_OPTICS_loss_fn.dat will contains four sequential data sets. These are the interband contribution, the intraband contribution, the total loss function without the additional broadening and the broadened total loss function.","title":"Aluminium"}]}